# Parameters:
# instance.parameter=value       #(type, mode) default = 'def value' : description : [min..max]
#------------------------------------------------------------------------------
REMOTE_CONNECTION.CADIServer.enable_remote_cadi=0     # (bool  , init-time) default = '0'      : Allow connections from remote hosts
REMOTE_CONNECTION.CADIServer.listen_address=127.0.0.1  # (string, init-time) default = '127.0.0.1' : Network address the server should listen on if enable_remote_cadi is set ("127.0.0.1" by default)
REMOTE_CONNECTION.CADIServer.port=31627               # (int   , init-time) default = '0x7b8b' : TCP port the server should listen on if enable_remote_cadi is set (31627 by default)
REMOTE_CONNECTION.CADIServer.range=0                  # (int   , init-time) default = '0x0'    : If requested port is not available, search for next available port in range: [port:port+range] (0 by default, only try specified port)
bp.Timer_0_1.clk_div0.div=1                           # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.Timer_0_1.clk_div0.mul=1                           # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.Timer_0_1.clk_div1.div=1                           # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.Timer_0_1.clk_div1.mul=1                           # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.Timer_2_3.clk_div0.div=1                           # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.Timer_2_3.clk_div0.mul=1                           # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.Timer_2_3.clk_div1.div=1                           # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.Timer_2_3.clk_div1.mul=1                           # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.ap_refclk.bypass_ctlbase=0                         # (bool  , init-time) default = '0'      : Bypass CNTBase Access Control. Enable if only timer frame feature is required without CNTBase access control
bp.ap_refclk.cntel0acr_implemented=0                  # (int   , init-time) default = '0x0'    : A bit-field of 8 bits, where bit {n} enables CNTEL0ACR for timer frame {n}
bp.ap_refclk.diagnostics=0                            # (int   , init-time) default = '0x0'    : Diagnostics
bp.ap_refclk.frame_security=                          # (string, init-time) default = ''       : Hard-wired/configurable security for frames (N/S/X, one character per timer frame)
bp.clock100Hz.div=1                                   # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.clock24MHz.div=1                                   # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.clock300MHz.div=1                                  # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.clock32KHz.div=1                                   # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.clock35MHz.div=1                                   # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.clock50Hz.div=1                                    # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.clockCLCD.div=1                                    # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.clockdivider.div=1                                 # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.dmc.enable_atomic_ops=0                            # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.dmc.fill1=3755990991                               # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.dmc.fill2=3487555551                               # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.dmc_phy.enable_atomic_ops=0                        # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.dmc_phy.fill1=3755990991                           # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.dmc_phy.fill2=3487555551                           # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.dram_alias_warning.diagnostics=2                   # (int   , init-time) default = '0x2'    : Diagnostics 0-4 (0:FATAL 1:ERROR 2:WARNING 3:INFO 4:DEBUG - DEFAULT==2)
bp.dram_metadata.init_value=13                        # (int   , init-time) default = '0xd'    : Initialize metadata memory with this value. If one of init_values_json or init_values_json_file is specified this value applies only to any metadata not specified in the JSON.
bp.dram_metadata.init_values_json=                    # (string, init-time) default = ''       : A JSON value describing initial metadata values. Mutually exclusive with init_values_json_file. The format is as follows:
                                                      #                                        : { "regions": [
                                                      #                                        : { "begin": 0x0, "end": 0x10000, "mte_tag": 0xa },
                                                      #                                        : { "begin": 0x20000, "end": 0x50000, "mte_tag": 0xc }
                                                      #                                        : ]}
bp.dram_metadata.init_values_json_file=               # (string, init-time) default = ''       : Path to a JSON file with initial metadata values. Mutually exclusive with init_values_json. The format is as follows:
                                                      #                                        : { "regions": [
                                                      #                                        : { "begin": 0x0, "end": 0x10000, "mte_tag": 0xa },
                                                      #                                        : { "begin": 0x20000, "end": 0x50000, "mte_tag": 0xc }
                                                      #                                        : ]}
bp.dram_metadata.is_enabled=0                         # (bool  , init-time) default = '0'      : If false it disables Memory tagging(MTE) functionality on DRAM
bp.dram_size=4                                        # (int   , init-time) default = '0x4'    : Size of main memory in gigabytes (2, 4, 8 to maximum 4000000)
bp.dummy_CF.diagnostics=2                             # (int   , init-time) default = '0x2'    : Diagnostics 0-4 (0:FATAL 1:ERROR 2:WARNING 3:INFO 4:DEBUG - DEFAULT==2)
bp.dummy_local_dap_rom.enable_atomic_ops=0            # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.dummy_local_dap_rom.fill1=3755990991               # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.dummy_local_dap_rom.fill2=3487555551               # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.dummy_ram.enable_atomic_ops=0                      # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.dummy_ram.fill1=3755990991                         # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.dummy_ram.fill2=3487555551                         # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.dummy_usb.enable_atomic_ops=0                      # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.dummy_usb.fill1=3755990991                         # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.dummy_usb.fill2=3487555551                         # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.exclusive_monitor.apply_access_width_criteria_to_non_excl_stores=1  # (bool  , init-time) default = '1'      : Apply the given exclusive store width matching criteria to non-exclusive stores
bp.exclusive_monitor.clear_on_strex_address_mismatch=1  # (bool  , init-time) default = '1'      : Whether monitor is cleared when strex fails due to address mismatch
bp.exclusive_monitor.enable_component=1               # (bool  , init-time) default = '1'      : Enable component
bp.exclusive_monitor.exclusive_monitor_clear_on_atomic_from_same_master=1  # (bool  , init-time) default = '1'      : Monitor atomics from the same master
bp.exclusive_monitor.match_access_width=0             # (bool  , init-time) default = '0'      : Fail STREX if not the same access width as LDREX
bp.exclusive_monitor.match_secure_state=1             # (bool  , init-time) default = '1'      : Treat the secure state like an address bit
bp.exclusive_monitor.monitor_access_level=0           # (int   , init-time) default = '0x0'    : 0: Monitor all accesses, 1: Monitor all accesses except WriteBack, 2: Only monitor accesses with memory type NonCacheable or Device
bp.exclusive_monitor.monitor_non_excl_stores=0        # (bool  , init-time) default = '0'      : Monitor non-exclusive stores from the same master
bp.exclusive_monitor.number_of_monitors=8             # (int   , init-time) default = '0x8'    : Number of monitors
bp.exclusive_monitor.shareability_domain=3            # (int   , init-time) default = '0x3'    : Maximum shareability domain of interest, transactions outside of the domain will pass through un-monitored (0-non-shared, 1-inner, 2-outer, 3-system)
bp.flash0.diagnostics=0                               # (int   , init-time) default = '0x0'    : Diagnostic level
bp.flash0.enable_read_status_logic=0                  # (bool  , init-time) default = '0'      : Enables logic to handle the status register reads as per the '3 Volt Intel StrataFlash Memory' specification
bp.flash0.model_blocklock=0                           # (bool  , init-time) default = '0'      : Model per-block locking and set all the blocks to locked state on reset
bp.flash0.trapwrite=0                                 # (bool  , init-time) default = '0'      : Generate abort on write
bp.flash0.unphysical_writes=1                         # (bool  , init-time) default = '1'      : Writes to flash are overwrite not AND
bp.flash1.diagnostics=0                               # (int   , init-time) default = '0x0'    : Diagnostic level
bp.flash1.enable_read_status_logic=0                  # (bool  , init-time) default = '0'      : Enables logic to handle the status register reads as per the '3 Volt Intel StrataFlash Memory' specification
bp.flash1.model_blocklock=0                           # (bool  , init-time) default = '0'      : Model per-block locking and set all the blocks to locked state on reset
bp.flash1.trapwrite=0                                 # (bool  , init-time) default = '0'      : Generate abort on write
bp.flash1.unphysical_writes=1                         # (bool  , init-time) default = '1'      : Writes to flash are overwrite not AND
bp.flashloader0.fname=(none)                          # (string, init-time) default = '(none)' : Filename (Default '(none)' means: Do not load any file. An empty string will cause a warning.)
bp.flashloader0.fnameWrite=(none)                     # (string, init-time) default = '(none)' : FilenameWrite (Default '(none)' means: Do not save any file. An empty string will cause a warning.)
bp.flashloader1.fname=(none)                          # (string, init-time) default = '(none)' : Filename (Default '(none)' means: Do not load any file. An empty string will cause a warning.)
bp.flashloader1.fnameWrite=(none)                     # (string, init-time) default = '(none)' : FilenameWrite (Default '(none)' means: Do not save any file. An empty string will cause a warning.)
bp.generic_watchdog.arch_version=0                    # (int   , init-time) default = '0x0'    : Architecture version. Available 0 and 1
bp.generic_watchdog.diagnostics=0                     # (int   , init-time) default = '0x0'    : Diagnostics
bp.generic_watchdog.product_id=0                      # (int   , init-time) default = '0x0'    : Product Identifier
bp.has_rme=0                                          # (bool  , init-time) default = '0'      : enable Realm Management Extension(RME) support
bp.has_utility_bus=0                                  # (bool  , init-time) default = '0'      : Has support for utility bus
bp.hdlcd0.diagnostics=0                               # (int   , init-time) default = '0x0'    : Diagnostics level
bp.hdlcd0.disable_snooping_dma=0                      # (bool  , init-time) default = '0'      : Disable DMA snooping
bp.hdlcd0.force_frame_rate=50                         # (int   , init-time) default = '0x32'   : Force frame rate to the value of the parameter in frames per simulated second, regardless of the input clock. When 0, use the input clock as a pixel clock
bp.hostbridge.interfaceName=                          # (string, init-time) default = ''       : Host Interface
bp.hostbridge.userNetOptions=                         # (string, init-time) default = ''       : Control options for UserNet TCP/IP (for internal use only, please do not use)
bp.hostbridge.userNetPorts=                           # (string, init-time) default = ''       : Listening ports to expose in user-mode networking
bp.hostbridge.userNetSubnet=172.20.51.0/24            # (string, init-time) default = '172.20.51.0/24' : Virtual subnet for user-mode networking
bp.hostbridge.userNetworking=0                        # (bool  , init-time) default = '0'      : Enable user-mode networking
bp.mmc.card_type=SDHC                                 # (string, init-time) default = 'SDHC'   : Card type ('SD' or 'SDHC')
bp.mmc.diagnostics=0                                  # (int   , init-time) default = '0x0'    : Diagnostics level
bp.mmc.force_sector_addressing=0                      # (bool  , init-time) default = '0'      : Use sector addressing even on small cards
bp.mmc.p_OEMid=0                                      # (int   , init-time) default = '0x0'    : Card ID OEM ID
bp.mmc.p_fast_access=1                                # (bool  , init-time) default = '1'      : Don't simulate MMC block access delays
bp.mmc.p_manid=2                                      # (int   , init-time) default = '0x2'    : Card ID Manufacturer ID
bp.mmc.p_max_block_count=128                          # (int   , init-time) default = '0x80'   : Default maximum block count reg. Default 0x80
bp.mmc.p_mmc_file=mmc.dat                             # (string, init-time) default = 'mmc.dat' : MMCard filename
bp.mmc.p_prodName=ARMmmc                              # (string, init-time) default = 'ARMmmc' : Card ID Product Name (6 chars)
bp.mmc.p_prodRev=1                                    # (int   , init-time) default = '0x1'    : Card ID Product Revision
bp.mmc.p_sernum=3394043905                            # (int   , init-time) default = '0xca4d0001' : Card Serial Number
bp.nontrustedrom.diagnostics=0                        # (int   , init-time) default = '0x0'    : Diagnostic level
bp.nontrustedrom.enable_read_status_logic=0           # (bool  , init-time) default = '0'      : Enables logic to handle the status register reads as per the '3 Volt Intel StrataFlash Memory' specification
bp.nontrustedrom.model_blocklock=0                    # (bool  , init-time) default = '0'      : Model per-block locking and set all the blocks to locked state on reset
bp.nontrustedrom.trapwrite=0                          # (bool  , init-time) default = '0'      : Generate abort on write
bp.nontrustedrom.unphysical_writes=1                  # (bool  , init-time) default = '1'      : Writes to flash are overwrite not AND
bp.nontrustedromloader.fname=(none)                   # (string, init-time) default = '(none)' : Filename (Default '(none)' means: Do not load any file. An empty string will cause a warning.)
bp.nontrustedromloader.fnameWrite=(none)              # (string, init-time) default = '(none)' : FilenameWrite (Default '(none)' means: Do not save any file. An empty string will cause a warning.)
bp.ns_dram.enable_atomic_ops=0                        # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.ns_dram.fill1=3755990991                           # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.ns_dram.fill2=3487555551                           # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.pas_switch.non_secure_port_index=1                 # (int   , init-time) default = '0x1'    : Port Index for Secure world transactions to exit or -2 for IGNORE or -1 for ABORT [Default Index of 0]
bp.pas_switch.port_map_json=                          # (string, init-time) default = ''       : A JSON value describing ports for different address regions. The begin address and size values should be aligned to 4KiB. The format is as follows:[{ "begin": 0x0, "size": 0x1000, "port": 0 },{ "begin": 0x20000, "size": 0x50000, "port": 2 }]
bp.pas_switch.realm_port_index=3                      # (int   , init-time) default = '0x3'    : Port Index for Realm world transactions to exit or -2 for IGNORE or -1 for ABORT [Default Index of 0]
bp.pas_switch.root_port_index=2                       # (int   , init-time) default = '0x2'    : Port Index for Root world transactions to exit or -2 for IGNORE or -1 for ABORT [Default Index of 0]
bp.pas_switch.secure_port_index=0                     # (int   , init-time) default = '0x0'    : Port Index for Secure world transactions to exit or -2 for IGNORE or -1 for ABORT [Default Index of 0]
bp.pl011_uart0.baud_rate=38400                        # (int   , init-time) default = '0x9600' : Baud rate.
bp.pl011_uart0.clk_divider.div=1                      # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.pl011_uart0.clk_divider.mul=1                      # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.pl011_uart0.clock_rate=14745600                    # (int   , init-time) default = '0xe10000' : Clock rate for PL011.
bp.pl011_uart0.enable_dc4=1                           # (bool  , run-time ) default = '1'      : Enable DC4 commands (try echo -e "help\024" in a Linux shell in a serial console)
bp.pl011_uart0.flow_ctrl_mask_en=0                    # (bool  , init-time) default = '0'      : Enable hardware flow control workaround which forcefully disables CTSen and RTSen bits in UARTCR register
bp.pl011_uart0.halt=0                                 # (bool  , run-time ) default = '0'      : Halt instead of shutdown for shutdown_on_eot and shutdown_tag
bp.pl011_uart0.in_file=                               # (string, init-time) default = ''       : Input file for data to be read by the UART
bp.pl011_uart0.in_file_escape_sequence=##             # (string, init-time) default = '##'     : Input file escape sequence
bp.pl011_uart0.out_file=                              # (string, init-time) default = ''       : Output file to hold data written by the UART (use '-' to send all output to stdout)
bp.pl011_uart0.revision=r1p4                          # (string, init-time) default = 'r1p4'   : Revision to simulate
bp.pl011_uart0.shutdown_on_eot=0                      # (bool  , init-time) default = '0'      : Shutdown simulation when a EOT (ASCII 4) char is transmitted (useful for regression tests when semihosting is not available)
bp.pl011_uart0.shutdown_tag=                          # (string, run-time ) default = ''       : Shutdown simulation when a string is transmitted
bp.pl011_uart0.toggle_mti=                            # (string, init-time) default = ''       : Start/stop token for any ToggleMTI source. Argument uses the JSON format:
                                                      #                                        : [{ "start": "START-TOKEN", "stop": "STOP-TOKEN" }]
                                                      #                                        : where 'START-TOKEN/END-TOKEN' are the corresponding start/stop tokens for toggling the trace plugins. Note that '\n' will be ignored if at start or end of the token. 
                                                      #                                        : For additional information, use 'help' as the value of this parameter.
bp.pl011_uart0.uart_enable=0                          # (bool  , init-time) default = '0'      : Enable uart when the system starts up. (clock_rate and baud_rate are only valid when this option is enabled.)
bp.pl011_uart0.unbuffered_output=0                    # (bool  , init-time) default = '0'      : Unbuffered output
bp.pl011_uart0.untimed_fifos=1                        # (bool  , init-time) default = '1'      : Ignore the clock rate and transmit/receive serial data immediately
bp.pl011_uart1.baud_rate=38400                        # (int   , init-time) default = '0x9600' : Baud rate.
bp.pl011_uart1.clk_divider.div=1                      # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.pl011_uart1.clk_divider.mul=1                      # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.pl011_uart1.clock_rate=14745600                    # (int   , init-time) default = '0xe10000' : Clock rate for PL011.
bp.pl011_uart1.enable_dc4=1                           # (bool  , run-time ) default = '1'      : Enable DC4 commands (try echo -e "help\024" in a Linux shell in a serial console)
bp.pl011_uart1.flow_ctrl_mask_en=0                    # (bool  , init-time) default = '0'      : Enable hardware flow control workaround which forcefully disables CTSen and RTSen bits in UARTCR register
bp.pl011_uart1.halt=0                                 # (bool  , run-time ) default = '0'      : Halt instead of shutdown for shutdown_on_eot and shutdown_tag
bp.pl011_uart1.in_file=                               # (string, init-time) default = ''       : Input file for data to be read by the UART
bp.pl011_uart1.in_file_escape_sequence=##             # (string, init-time) default = '##'     : Input file escape sequence
bp.pl011_uart1.out_file=                              # (string, init-time) default = ''       : Output file to hold data written by the UART (use '-' to send all output to stdout)
bp.pl011_uart1.revision=r1p4                          # (string, init-time) default = 'r1p4'   : Revision to simulate
bp.pl011_uart1.shutdown_on_eot=0                      # (bool  , init-time) default = '0'      : Shutdown simulation when a EOT (ASCII 4) char is transmitted (useful for regression tests when semihosting is not available)
bp.pl011_uart1.shutdown_tag=                          # (string, run-time ) default = ''       : Shutdown simulation when a string is transmitted
bp.pl011_uart1.toggle_mti=                            # (string, init-time) default = ''       : Start/stop token for any ToggleMTI source. Argument uses the JSON format:
                                                      #                                        : [{ "start": "START-TOKEN", "stop": "STOP-TOKEN" }]
                                                      #                                        : where 'START-TOKEN/END-TOKEN' are the corresponding start/stop tokens for toggling the trace plugins. Note that '\n' will be ignored if at start or end of the token. 
                                                      #                                        : For additional information, use 'help' as the value of this parameter.
bp.pl011_uart1.uart_enable=0                          # (bool  , init-time) default = '0'      : Enable uart when the system starts up. (clock_rate and baud_rate are only valid when this option is enabled.)
bp.pl011_uart1.unbuffered_output=0                    # (bool  , init-time) default = '0'      : Unbuffered output
bp.pl011_uart1.untimed_fifos=1                        # (bool  , init-time) default = '1'      : Ignore the clock rate and transmit/receive serial data immediately
bp.pl011_uart2.baud_rate=38400                        # (int   , init-time) default = '0x9600' : Baud rate.
bp.pl011_uart2.clk_divider.div=1                      # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.pl011_uart2.clk_divider.mul=1                      # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.pl011_uart2.clock_rate=14745600                    # (int   , init-time) default = '0xe10000' : Clock rate for PL011.
bp.pl011_uart2.enable_dc4=1                           # (bool  , run-time ) default = '1'      : Enable DC4 commands (try echo -e "help\024" in a Linux shell in a serial console)
bp.pl011_uart2.flow_ctrl_mask_en=0                    # (bool  , init-time) default = '0'      : Enable hardware flow control workaround which forcefully disables CTSen and RTSen bits in UARTCR register
bp.pl011_uart2.halt=0                                 # (bool  , run-time ) default = '0'      : Halt instead of shutdown for shutdown_on_eot and shutdown_tag
bp.pl011_uart2.in_file=                               # (string, init-time) default = ''       : Input file for data to be read by the UART
bp.pl011_uart2.in_file_escape_sequence=##             # (string, init-time) default = '##'     : Input file escape sequence
bp.pl011_uart2.out_file=                              # (string, init-time) default = ''       : Output file to hold data written by the UART (use '-' to send all output to stdout)
bp.pl011_uart2.revision=r1p4                          # (string, init-time) default = 'r1p4'   : Revision to simulate
bp.pl011_uart2.shutdown_on_eot=0                      # (bool  , init-time) default = '0'      : Shutdown simulation when a EOT (ASCII 4) char is transmitted (useful for regression tests when semihosting is not available)
bp.pl011_uart2.shutdown_tag=                          # (string, run-time ) default = ''       : Shutdown simulation when a string is transmitted
bp.pl011_uart2.toggle_mti=                            # (string, init-time) default = ''       : Start/stop token for any ToggleMTI source. Argument uses the JSON format:
                                                      #                                        : [{ "start": "START-TOKEN", "stop": "STOP-TOKEN" }]
                                                      #                                        : where 'START-TOKEN/END-TOKEN' are the corresponding start/stop tokens for toggling the trace plugins. Note that '\n' will be ignored if at start or end of the token. 
                                                      #                                        : For additional information, use 'help' as the value of this parameter.
bp.pl011_uart2.uart_enable=0                          # (bool  , init-time) default = '0'      : Enable uart when the system starts up. (clock_rate and baud_rate are only valid when this option is enabled.)
bp.pl011_uart2.unbuffered_output=0                    # (bool  , init-time) default = '0'      : Unbuffered output
bp.pl011_uart2.untimed_fifos=1                        # (bool  , init-time) default = '1'      : Ignore the clock rate and transmit/receive serial data immediately
bp.pl011_uart3.baud_rate=38400                        # (int   , init-time) default = '0x9600' : Baud rate.
bp.pl011_uart3.clk_divider.div=1                      # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.pl011_uart3.clk_divider.mul=1                      # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.pl011_uart3.clock_rate=14745600                    # (int   , init-time) default = '0xe10000' : Clock rate for PL011.
bp.pl011_uart3.enable_dc4=1                           # (bool  , run-time ) default = '1'      : Enable DC4 commands (try echo -e "help\024" in a Linux shell in a serial console)
bp.pl011_uart3.flow_ctrl_mask_en=0                    # (bool  , init-time) default = '0'      : Enable hardware flow control workaround which forcefully disables CTSen and RTSen bits in UARTCR register
bp.pl011_uart3.halt=0                                 # (bool  , run-time ) default = '0'      : Halt instead of shutdown for shutdown_on_eot and shutdown_tag
bp.pl011_uart3.in_file=                               # (string, init-time) default = ''       : Input file for data to be read by the UART
bp.pl011_uart3.in_file_escape_sequence=##             # (string, init-time) default = '##'     : Input file escape sequence
bp.pl011_uart3.out_file=                              # (string, init-time) default = ''       : Output file to hold data written by the UART (use '-' to send all output to stdout)
bp.pl011_uart3.revision=r1p4                          # (string, init-time) default = 'r1p4'   : Revision to simulate
bp.pl011_uart3.shutdown_on_eot=0                      # (bool  , init-time) default = '0'      : Shutdown simulation when a EOT (ASCII 4) char is transmitted (useful for regression tests when semihosting is not available)
bp.pl011_uart3.shutdown_tag=                          # (string, run-time ) default = ''       : Shutdown simulation when a string is transmitted
bp.pl011_uart3.toggle_mti=                            # (string, init-time) default = ''       : Start/stop token for any ToggleMTI source. Argument uses the JSON format:
                                                      #                                        : [{ "start": "START-TOKEN", "stop": "STOP-TOKEN" }]
                                                      #                                        : where 'START-TOKEN/END-TOKEN' are the corresponding start/stop tokens for toggling the trace plugins. Note that '\n' will be ignored if at start or end of the token. 
                                                      #                                        : For additional information, use 'help' as the value of this parameter.
bp.pl011_uart3.uart_enable=0                          # (bool  , init-time) default = '0'      : Enable uart when the system starts up. (clock_rate and baud_rate are only valid when this option is enabled.)
bp.pl011_uart3.unbuffered_output=0                    # (bool  , init-time) default = '0'      : Unbuffered output
bp.pl011_uart3.untimed_fifos=1                        # (bool  , init-time) default = '1'      : Ignore the clock rate and transmit/receive serial data immediately
bp.pl031_rtc.RTCDR_reset_value=0                      # (int   , init-time) default = '0x0'    : Reset value for RTCDR
bp.pl031_rtc.RTCDR_use_current_time=1                 # (bool  , init-time) default = '1'      : Use current Unix/POSIX time for reset value for RTCDR. If true RTCDR_reset_value is ignored
bp.pl041_aaci.enabled=1                               # (bool  , init-time) default = '1'      : Host interface connection enabled
bp.pl050_kmi0.clk_divider.div=1                       # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.pl050_kmi0.clk_divider.mul=1                       # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.pl050_kmi1.clk_divider.div=1                       # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.pl050_kmi1.clk_divider.mul=1                       # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.pl111_clcd.disable_snooping_dma=0                  # (bool  , init-time) default = '0'      : Disable DMA snooping
bp.pl111_clcd.pixel_double_limit=300                  # (int   , init-time) default = '0x12c'  : Minimum LCD pixel width before display will be zoomed
bp.pl180_mci.pl180_fifo_depth=16                      # (int   , init-time) default = '0x10'   : PL180 FIFO Depth
bp.proc_id0=1143                                      # (int   , init-time) default = '0x477'  : Processor ID at CoreTile Express Site 1
bp.proc_id1=1143                                      # (int   , init-time) default = '0x477'  : Processor ID at CoreTile Express Site 2
bp.psram.enable_atomic_ops=0                          # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.psram.fill1=3755990991                             # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.psram.fill2=3487555551                             # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.refcounter.base_frequency=100000000                # (int   , init-time) default = '0x5f5e100' : Reset value for CNTFID0, base frequency in Hz
bp.refcounter.diagnostics=0                           # (int   , init-time) default = '0x0'    : Diagnostics
bp.refcounter.has_counter_scaling=0                   # (bool  , init-time) default = '0'      : Implements ARMv8.4 generic counter scaling (FEAT_CNTSC).
bp.refcounter.non_arch_fixed_frequency=0              # (int   , init-time) default = '0x0'    : If set, ignore CNTFID0 and instead use this frequency in Hz
bp.refcounter.non_arch_start_at_default=0             # (bool  , init-time) default = '0'      : Firmware is expected to enable the timer at boot time. However, turning this parameter on is a model-specific way of enabling the counter module out of reset.
bp.refcounter.readonly_is_WI=0                        # (bool  , init-time) default = '0'      : Ignore (rather than failing) on writes to read-frame
bp.refcounter.use_real_time=0                         # (bool  , init-time) default = '0'      : **Deprecated, this parameter will be removed in future versions** Update the Generic Timer counter at a real-time base frequency instead of simulator time
bp.rl_dram.enable_atomic_ops=0                        # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.rl_dram.fill1=3755990991                           # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.rl_dram.fill2=3487555551                           # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.rt_dram.enable_atomic_ops=0                        # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.rt_dram.fill1=3755990991                           # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.rt_dram.fill2=3487555551                           # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.s_dram.enable_atomic_ops=0                         # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.s_dram.fill1=3755990991                            # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.s_dram.fill2=3487555551                            # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.secureDRAM.enable_atomic_ops=0                     # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.secureDRAM.fill1=3755990991                        # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.secureDRAM.fill2=3487555551                        # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.secureSRAM.enable_atomic_ops=0                     # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.secureSRAM.fill1=3755990991                        # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.secureSRAM.fill2=3487555551                        # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.secure_memory=1                                    # (bool  , init-time) default = '1'      : enable security checking by TZC-400
bp.secureflash.diagnostics=0                          # (int   , init-time) default = '0x0'    : Diagnostic level
bp.secureflash.enable_read_status_logic=0             # (bool  , init-time) default = '0'      : Enables logic to handle the status register reads as per the '3 Volt Intel StrataFlash Memory' specification
bp.secureflash.model_blocklock=0                      # (bool  , init-time) default = '0'      : Model per-block locking and set all the blocks to locked state on reset
bp.secureflash.trapwrite=0                            # (bool  , init-time) default = '0'      : Generate abort on write
bp.secureflash.unphysical_writes=1                    # (bool  , init-time) default = '1'      : Writes to flash are overwrite not AND
bp.secureflashloader.fname=(none)                     # (string, init-time) default = '(none)' : Filename (Default '(none)' means: Do not load any file. An empty string will cause a warning.)
bp.secureflashloader.fnameWrite=(none)                # (string, init-time) default = '(none)' : FilenameWrite (Default '(none)' means: Do not save any file. An empty string will cause a warning.)
bp.separate_rme_world=0                               # (bool  , init-time) default = '0'      : Enables separate pas memory for rme worlds (root/realm/secure/non-secure). If not enabled or no RME Support, ignores root/realm regions
bp.smsc_91c111.cache_size=65536                       # (int   , init-time) default = '0x10000' : Size of cache memory in SMSC MMU
bp.smsc_91c111.enabled=0                              # (bool  , init-time) default = '0'      : Host interface connection enabled
bp.smsc_91c111.mac_address=00:02:f7:ef:cd:0e          # (string, init-time) default = '00:02:f7:ef:cd:0e' : Host/model MAC address
bp.smsc_91c111.not_lan911x=0                          # (bool  , init-time) default = '0'      : Gracefully fail SMSC LAN911x driver probe
bp.smsc_91c111.promiscuous=1                          # (bool  , init-time) default = '1'      : Put host into promiscuous mode
bp.sp805_wdog.simhalt=0                               # (bool  , run-time ) default = '0'      : Halt on reset.
bp.sp810_sysctrl.clkdiv_clk0.div=1                    # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.sp810_sysctrl.clkdiv_clk0.mul=1                    # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.sp810_sysctrl.clkdiv_clk1.div=1                    # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.sp810_sysctrl.clkdiv_clk1.mul=1                    # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.sp810_sysctrl.clkdiv_clk2.div=1                    # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.sp810_sysctrl.clkdiv_clk2.mul=1                    # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.sp810_sysctrl.clkdiv_clk3.div=1                    # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.sp810_sysctrl.clkdiv_clk3.mul=1                    # (int   , init-time) default = '0x1'    : Clock Rate Multiplier. This parameter is not exposed via CADI and can only be set in LISA
bp.sp810_sysctrl.sysid=0                              # (int   , init-time) default = '0x0'    : System Identification Register.
bp.sp810_sysctrl.use_s8=0                             # (bool  , init-time) default = '0'      : Use Switch 8 (S1-S4)
bp.sram.enable_atomic_ops=0                           # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.sram.fill1=3755990991                              # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.sram.fill2=3487555551                              # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.terminal_0.mode=telnet                             # (string, init-time) default = 'telnet' : Terminal initialisation mode
bp.terminal_0.quiet=0                                 # (bool  , init-time) default = '0'      : Avoid output on stdout/stderr
bp.terminal_0.start_port=5000                         # (int   , init-time) default = '0x1388' : Telnet TCP Port Number
bp.terminal_0.start_telnet=1                          # (bool  , init-time) default = '1'      : Start telnet if nothing connected
bp.terminal_0.terminal_command=                       # (string, init-time) default = ''       : Commandline to launch a terminal application and connect to the opened TCP port. Keywords %port and %title will be replaced with the opened port number and component name respectively. An empty string (default behaviour) will launch xterm (Linux) or telnet.exe (Windows)
bp.terminal_1.mode=telnet                             # (string, init-time) default = 'telnet' : Terminal initialisation mode
bp.terminal_1.quiet=0                                 # (bool  , init-time) default = '0'      : Avoid output on stdout/stderr
bp.terminal_1.start_port=5000                         # (int   , init-time) default = '0x1388' : Telnet TCP Port Number
bp.terminal_1.start_telnet=1                          # (bool  , init-time) default = '1'      : Start telnet if nothing connected
bp.terminal_1.terminal_command=                       # (string, init-time) default = ''       : Commandline to launch a terminal application and connect to the opened TCP port. Keywords %port and %title will be replaced with the opened port number and component name respectively. An empty string (default behaviour) will launch xterm (Linux) or telnet.exe (Windows)
bp.terminal_2.mode=telnet                             # (string, init-time) default = 'telnet' : Terminal initialisation mode
bp.terminal_2.quiet=0                                 # (bool  , init-time) default = '0'      : Avoid output on stdout/stderr
bp.terminal_2.start_port=5000                         # (int   , init-time) default = '0x1388' : Telnet TCP Port Number
bp.terminal_2.start_telnet=1                          # (bool  , init-time) default = '1'      : Start telnet if nothing connected
bp.terminal_2.terminal_command=                       # (string, init-time) default = ''       : Commandline to launch a terminal application and connect to the opened TCP port. Keywords %port and %title will be replaced with the opened port number and component name respectively. An empty string (default behaviour) will launch xterm (Linux) or telnet.exe (Windows)
bp.terminal_3.mode=telnet                             # (string, init-time) default = 'telnet' : Terminal initialisation mode
bp.terminal_3.quiet=0                                 # (bool  , init-time) default = '0'      : Avoid output on stdout/stderr
bp.terminal_3.start_port=5000                         # (int   , init-time) default = '0x1388' : Telnet TCP Port Number
bp.terminal_3.start_telnet=1                          # (bool  , init-time) default = '1'      : Start telnet if nothing connected
bp.terminal_3.terminal_command=                       # (string, init-time) default = ''       : Commandline to launch a terminal application and connect to the opened TCP port. Keywords %port and %title will be replaced with the opened port number and component name respectively. An empty string (default behaviour) will launch xterm (Linux) or telnet.exe (Windows)
bp.trusted_key_storage.diagnostics=0                  # (int   , init-time) default = '0x0'    : Diagnostics
bp.trusted_key_storage.hw_unique_key=00000000 00000000 00000000 00000000  # (string, init-time) default = '00000000 00000000 00000000 00000000' : Hardware Unique Key (128-bit, 4 hex words)
bp.trusted_key_storage.hw_unique_key_hex=             # (string, init-time) default = ''       : Hardware Unique Key (128-bit, little-endian hex byte stream)
bp.trusted_key_storage.private_key=00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  # (string, init-time) default = '00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000' : Private Endorsement Key (256-bit, 8 hex words)
bp.trusted_key_storage.private_key_hex=               # (string, init-time) default = ''       : Private Key (256-bit, little-endian hex byte stream)
bp.trusted_key_storage.public_key=00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  # (string, init-time) default = '00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000' : Public Key (256-bit, 8 hex words)
bp.trusted_key_storage.public_key_hex=                # (string, init-time) default = ''       : Public Key (256-bit, little-endian hex byte stream)
bp.trusted_key_storage.ss_key=00000000 00000000 00000000 00000000  # (string, init-time) default = '00000000 00000000 00000000 00000000' : Secret Symmetric Key (128-bit, 4 hex words)
bp.trusted_key_storage.ss_key_hex=                    # (string, init-time) default = ''       : Secret Symmetric Key (128-bit, little-endian hex byte stream)
bp.trusted_key_storage.version=r1                     # (string, init-time) default = 'r1'     : Version of the model functionality. Valid values are r0 and r1.
bp.trusted_nv_counter.diagnostics=0                   # (int   , init-time) default = '0x0'    : Diagnostics
bp.trusted_nv_counter.rst_non_tz_fw_cnt=223           # (int   , init-time) default = '0xdf'   : Value of NON_TZ_FW_CNT at reset
bp.trusted_nv_counter.rst_tz_fw_cnt=31                # (int   , init-time) default = '0x1f'   : Value of TZ_FW_CNT at reset
bp.trusted_nv_counter.secure=1                        # (bool  , init-time) default = '1'      : Instantiate model as Secure (1) or NS (0)
bp.trusted_nv_counter.version=r0                      # (string, init-time) default = 'r0'     : Version of the model functionality. Valid values are r0 and r1.
bp.trusted_rng.diagnostics=0                          # (int   , init-time) default = '0x0'    : Diagnostics
bp.trusted_rng.seed=0                                 # (int   , init-time) default = '0x0'    : Random number seed
bp.trusted_watchdog.simhalt=0                         # (bool  , run-time ) default = '0'      : Halt on reset.
bp.tzc_400.diagnostics=0                              # (int   , init-time) default = '0x0'    : Diagnostics
bp.tzc_400.rst_action=0                               # (int   , init-time) default = '0x0'    : ACTION register value at reset
bp.tzc_400.rst_build_config=50347784                  # (int   , init-time) default = '0x3003f08' : BUILD_CONFIG register value at reset
bp.tzc_400.rst_gate_keeper=0                          # (int   , init-time) default = '0x0'    : GATE_KEEPER register value at reset
bp.tzc_400.rst_region_attributes_0=15                 # (int   , init-time) default = '0xf'    : Region 0 Secure attributes
bp.tzc_400.rst_region_attributes_1=0                  # (int   , init-time) default = '0x0'    : Region 1 Secure attributes
bp.tzc_400.rst_region_attributes_2=0                  # (int   , init-time) default = '0x0'    : Region 2 Secure attributes
bp.tzc_400.rst_region_attributes_3=0                  # (int   , init-time) default = '0x0'    : Region 3 Secure attributes
bp.tzc_400.rst_region_attributes_4=0                  # (int   , init-time) default = '0x0'    : Region 4 Secure attributes
bp.tzc_400.rst_region_attributes_5=0                  # (int   , init-time) default = '0x0'    : Region 5 Secure attributes
bp.tzc_400.rst_region_attributes_6=0                  # (int   , init-time) default = '0x0'    : Region 6 Secure attributes
bp.tzc_400.rst_region_attributes_7=0                  # (int   , init-time) default = '0x0'    : Region 7 Secure attributes
bp.tzc_400.rst_region_attributes_8=0                  # (int   , init-time) default = '0x0'    : Region 8 Secure attributes
bp.tzc_400.rst_region_base_high_1=0                   # (int   , init-time) default = '0x0'    : Region 1 base memory address (high 32 bits)
bp.tzc_400.rst_region_base_high_2=0                   # (int   , init-time) default = '0x0'    : Region 2 base memory address (high 32 bits)
bp.tzc_400.rst_region_base_high_3=0                   # (int   , init-time) default = '0x0'    : Region 3 base memory address (high 32 bits)
bp.tzc_400.rst_region_base_high_4=0                   # (int   , init-time) default = '0x0'    : Region 4 base memory address (high 32 bits)
bp.tzc_400.rst_region_base_high_5=0                   # (int   , init-time) default = '0x0'    : Region 5 base memory address (high 32 bits)
bp.tzc_400.rst_region_base_high_6=0                   # (int   , init-time) default = '0x0'    : Region 6 base memory address (high 32 bits)
bp.tzc_400.rst_region_base_high_7=0                   # (int   , init-time) default = '0x0'    : Region 7 base memory address (high 32 bits)
bp.tzc_400.rst_region_base_high_8=0                   # (int   , init-time) default = '0x0'    : Region 8 base memory address (high 32 bits)
bp.tzc_400.rst_region_base_low_1=0                    # (int   , init-time) default = '0x0'    : Region 1 base memory address (low 32 bits)
bp.tzc_400.rst_region_base_low_2=0                    # (int   , init-time) default = '0x0'    : Region 2 base memory address (low 32 bits)
bp.tzc_400.rst_region_base_low_3=0                    # (int   , init-time) default = '0x0'    : Region 3 base memory address (low 32 bits)
bp.tzc_400.rst_region_base_low_4=0                    # (int   , init-time) default = '0x0'    : Region 4 base memory address (low 32 bits)
bp.tzc_400.rst_region_base_low_5=0                    # (int   , init-time) default = '0x0'    : Region 5 base memory address (low 32 bits)
bp.tzc_400.rst_region_base_low_6=0                    # (int   , init-time) default = '0x0'    : Region 6 base memory address (low 32 bits)
bp.tzc_400.rst_region_base_low_7=0                    # (int   , init-time) default = '0x0'    : Region 7 base memory address (low 32 bits)
bp.tzc_400.rst_region_base_low_8=0                    # (int   , init-time) default = '0x0'    : Region 8 base memory address (low 32 bits)
bp.tzc_400.rst_region_id_access_0=0                   # (int   , init-time) default = '0x0'    : Region 0 NSAID permissions
bp.tzc_400.rst_region_id_access_1=0                   # (int   , init-time) default = '0x0'    : Region 1 NSAID permissions
bp.tzc_400.rst_region_id_access_2=0                   # (int   , init-time) default = '0x0'    : Region 2 NSAID permissions
bp.tzc_400.rst_region_id_access_3=0                   # (int   , init-time) default = '0x0'    : Region 3 NSAID permissions
bp.tzc_400.rst_region_id_access_4=0                   # (int   , init-time) default = '0x0'    : Region 4 NSAID permissions
bp.tzc_400.rst_region_id_access_5=0                   # (int   , init-time) default = '0x0'    : Region 5 NSAID permissions
bp.tzc_400.rst_region_id_access_6=0                   # (int   , init-time) default = '0x0'    : Region 6 NSAID permissions
bp.tzc_400.rst_region_id_access_7=0                   # (int   , init-time) default = '0x0'    : Region 7 NSAID permissions
bp.tzc_400.rst_region_id_access_8=0                   # (int   , init-time) default = '0x0'    : Region 8 NSAID permissions
bp.tzc_400.rst_region_top_high_0=0                    # (int   , init-time) default = '0x0'    : Region 0 (default) top memory address
bp.tzc_400.rst_region_top_high_1=0                    # (int   , init-time) default = '0x0'    : Region 1 top memory address (high 32 bits)
bp.tzc_400.rst_region_top_high_2=0                    # (int   , init-time) default = '0x0'    : Region 2 top memory address (high 32 bits)
bp.tzc_400.rst_region_top_high_3=0                    # (int   , init-time) default = '0x0'    : Region 3 top memory address (high 32 bits)
bp.tzc_400.rst_region_top_high_4=0                    # (int   , init-time) default = '0x0'    : Region 4 top memory address (high 32 bits)
bp.tzc_400.rst_region_top_high_5=0                    # (int   , init-time) default = '0x0'    : Region 5 top memory address (high 32 bits)
bp.tzc_400.rst_region_top_high_6=0                    # (int   , init-time) default = '0x0'    : Region 6 top memory address (high 32 bits)
bp.tzc_400.rst_region_top_high_7=0                    # (int   , init-time) default = '0x0'    : Region 7 top memory address (high 32 bits)
bp.tzc_400.rst_region_top_high_8=0                    # (int   , init-time) default = '0x0'    : Region 8 top memory address (high 32 bits)
bp.tzc_400.rst_region_top_low_1=0                     # (int   , init-time) default = '0x0'    : Region 1 top memory address (low 32 bits)
bp.tzc_400.rst_region_top_low_2=0                     # (int   , init-time) default = '0x0'    : Region 2 top memory address (low 32 bits)
bp.tzc_400.rst_region_top_low_3=0                     # (int   , init-time) default = '0x0'    : Region 3 top memory address (low 32 bits)
bp.tzc_400.rst_region_top_low_4=0                     # (int   , init-time) default = '0x0'    : Region 4 top memory address (low 32 bits)
bp.tzc_400.rst_region_top_low_5=0                     # (int   , init-time) default = '0x0'    : Region 5 top memory address (low 32 bits)
bp.tzc_400.rst_region_top_low_6=0                     # (int   , init-time) default = '0x0'    : Region 6 top memory address (low 32 bits)
bp.tzc_400.rst_region_top_low_7=0                     # (int   , init-time) default = '0x0'    : Region 7 top memory address (low 32 bits)
bp.tzc_400.rst_region_top_low_8=0                     # (int   , init-time) default = '0x0'    : Region 8 top memory address (low 32 bits)
bp.uart_base=470351872                                # (int   , init-time) default = '0x1c090000' : Base address of the UART IP's
bp.variant=1                                          # (int   , init-time) default = '0x1'    : Board variant for SYS_ID
bp.ve_sysregs.exit_on_shutdown=0                      # (bool  , init-time) default = '0'      : SYS_CFG_SHUTDOWN exits simulation
bp.ve_sysregs.mmbSiteDefault=1                        # (int   , init-time) default = '0x1'    : Default MMB source (0=MB, 1=DB1, 2=DB2)
bp.ve_sysregs.tilePresent=1                           # (bool  , init-time) default = '1'      : Tile fitted
bp.ve_sysregs.user_switches_value=0                   # (int   , init-time) default = '0x0'    : User switches
bp.virtio_net.checksum=                               # (string, init-time) default = ''       : For checksum-offloaded packets, if 'tx' is specified, outgoings will be checksumed by VirtioNet device; 'rx' is specified for incomings; 'all' for both
bp.virtio_net.enabled=0                               # (bool  , init-time) default = '0'      : Enable or disable device. If disabled, device can be accessed, but will not be activated
bp.virtio_net.hostbridge.interfaceName=               # (string, init-time) default = ''       : Host Interface
bp.virtio_net.hostbridge.userNetOptions=              # (string, init-time) default = ''       : Control options for UserNet TCP/IP (for internal use only, please do not use)
bp.virtio_net.hostbridge.userNetPorts=                # (string, init-time) default = ''       : Listening ports to expose in user-mode networking
bp.virtio_net.hostbridge.userNetSubnet=172.20.51.0/24  # (string, init-time) default = '172.20.51.0/24' : Virtual subnet for user-mode networking
bp.virtio_net.hostbridge.userNetworking=0             # (bool  , init-time) default = '0'      : Enable user-mode networking
bp.virtio_net.mac_address=                            # (string, init-time) default = ''       : Device MAC address, if not specified, a random MAC address is generated
bp.virtio_net.offload=gso, gro                        # (string, init-time) default = 'gso, gro' : Offload TCP/UDP segmentation/receiving operations to host
bp.virtio_net.secure_accesses=0                       # (bool  , init-time) default = '0'      : Make device generate transactions with NS=0
bp.virtio_net.target_endian=0                         # (bool  , init-time) default = '0'      : Target cpu endianness(0-LE, 1-BE)
bp.virtio_net.transport=modern                        # (string, init-time) default = 'modern' : Choose legacy or modern virtio transport, if not specified, modern transport is used
bp.virtio_rng.diagnostics=0                           # (int   , init-time) default = '0x0'    : Prints debug information: 0 = disabled; 1 = generated seed and device; 4 = generated seed, device and generated numbers
bp.virtio_rng.enabled=0                               # (bool  , init-time) default = '0'      : Enable or disable device. If disabled, device can be accessed, but will not be activated
bp.virtio_rng.generator=0                             # (int   , init-time) default = '0x0'    : User-defined generator: 0 = xorshiftstar; 1 = rand48; 2 = mersenne
bp.virtio_rng.secure_accesses=0                       # (bool  , init-time) default = '0'      : Make device generate transactions with NS=0
bp.virtio_rng.seed=0                                  # (int   , init-time) default = '0x0'    : User-defined seed: 0 = uses a random seed; > 0 = user-defined fixed seed value
bp.virtio_rng.target_endian=0                         # (bool  , init-time) default = '0'      : Target cpu endianness(0-LE, 1-BE)
bp.virtio_rng.transport=modern                        # (string, init-time) default = 'modern' : Choose legacy or modern virtio transport, if not specified, modern transport is used
bp.virtioblockdevice.image_path=                      # (string, init-time) default = ''       : image file path
bp.virtioblockdevice.quiet=0                          # (bool  , init-time) default = '0'      : Don't print warnings on malformed commands/descriptors
bp.virtioblockdevice.read_only=0                      # (bool  , init-time) default = '0'      : Only allow device to be read
bp.virtioblockdevice.secure_accesses=0                # (bool  , init-time) default = '0'      : Make device generate transactions with NS=0
bp.virtioblockdevice.transaction_attributes=2         # (int   , init-time) default = '0x2'    : Transaction attributes used by device.
                                                      #                                        : 	0x0 - inner-shared real access.
                                                      #                                        : 	0x1 - outer-shared real access.
                                                      #                                        : 	0x2 - outer-shared debug access.
bp.virtiop9device.mount_tag=FM                        # (string, init-time) default = 'FM'     : mount tag
bp.virtiop9device.quiet=0                             # (bool  , init-time) default = '0'      : Don't print warnings on malformed commands/descriptors
bp.virtiop9device.root_path=                          # (string, init-time) default = ''       : root directory path
bp.virtiop9device.secure_accesses=0                   # (bool  , init-time) default = '0'      : Make device generate transactions with NS=0
bp.vis.cluster0_name=Cluster0                         # (string, init-time) default = 'Cluster0' : Cluster0 name
bp.vis.cluster1_name=Cluster1                         # (string, init-time) default = 'Cluster1' : Cluster1 name
bp.vis.cluster2_name=Cluster2                         # (string, init-time) default = 'Cluster2' : Cluster2 name
bp.vis.cluster3_name=Cluster3                         # (string, init-time) default = 'Cluster3' : Cluster3 name
bp.vis.diagnostics=0                                  # (bool  , init-time) default = '0'      : Diagnostics
bp.vis.disable_visualisation=0                        # (bool  , init-time) default = '0'      : Enable/disable visualisation
bp.vis.idler.delay_ms=50                              # (int   , init-time) default = '0x32'   : Determines the period, in milliseconds of real time, between gui_callback() calls.
bp.vis.rate_limit-enable=1                            # (bool  , init-time) default = '1'      : Rate limit simulation.
bp.vis.recorder.checkInstructionCount=1               # (bool  , run-time ) default = '1'      : check instruction count in recording file against actual instruction count during playback
bp.vis.recorder.playbackDivider.div=1                 # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.vis.recorder.playbackFileName=                     # (string, init-time) default = ''       : playback filename (empty string disables playback)
bp.vis.recorder.recordingDivider.div=1                # (int   , init-time) default = '0x1'    : Clock Rate Divider. This parameter is not exposed via CADI and can only be set in LISA
bp.vis.recorder.recordingFileName=                    # (string, init-time) default = ''       : recording filename (empty string disables recording)
bp.vis.recorder.recordingTimeBase=100000000           # (int   , init-time) default = '0x5f5e100' : timebase in 1/s (relative to the master clock (e.g. 100000000 means 10 nanoseconds resolution simulated time for a 1Hz master clock)) to be used for recording (higher values -> higher time resolution, playback time base is always taken from the playback file)
bp.vis.recorder.verbose=0                             # (int   , run-time ) default = '0x0'    : enable verbose messages (1=normal, 2=even more)
bp.vis.trap_key=74                                    # (int   , init-time) default = '0x4a'   : Trap key that works with left Ctrl to toggle mouse display.
bp.vis.window_title=Fast Models - CLCD %cpu%          # (string, init-time) default = 'Fast Models - CLCD %cpu%' : Window title (%cpu% is replaced by cpu_name)
bp.vram.enable_atomic_ops=0                           # (bool  , init-time) default = '0'      : Supports Atomic Operations
bp.vram.fill1=3755990991                              # (int   , init-time) default = '0xdfdfdfcf' : Fill pattern 1, initialise memory at start of simulation with alternating fill1, fill2 pattern
bp.vram.fill2=3487555551                              # (int   , init-time) default = '0xcfdfdfdf' : Fill pattern 2, initialise memory at start of simulation with alternating fill1, fill2 pattern
cache_state_modelled=1                                # (bool  , init-time) default = '1'      : Enabled d-cache and i-cache state for all components
cci550.addr_width=40                                  # (int   , init-time) default = '0x28'   : The bit-width of the address that the CCI can accept.
cci550.dbgen=1                                        # (bool  , init-time) default = '1'      : Invasive debug enable.  If true, enables the counting of PMU events.
cci550.enable_logger=0                                # (bool  , init-time) default = '0'      : Enable PVBusLoggers for the downstream ports in the CCI model.
cci550.force_on_from_start=0                          # (bool  , init-time) default = '0'      : The interconnect will normally start up with snooping/DVM disabled. The
                                                      #                                        : parameter si_system_coherency_interface determines which connections are
                                                      #                                        : managed by the System Coherency Interface (SCI). For connections that are
                                                      #                                        : managed by SCI, then this parameter has no effect. For all other connections,
                                                      #                                        : this parameter enables the upstream system of a port to be snooped if the
                                                      #                                        : upstream is not in reset and if ACCHANNELENSx allows it. No software driver
                                                      #                                        : for the interconnect is needed. Any non-SCI port that could go into reset must
                                                      #                                        : have 'reset_state_of_upstream_port[]' reflect the reset state of that upstream
                                                      #                                        : system. Otherwise, the upstream system may receive snoop/DVM messages whilst
                                                      #                                        : in reset and may complain that it 'received a snoop request whilst it was in
                                                      #                                        : reset'. Do not use if software is directly controlling the interconnect. This
                                                      #                                        : option does not disavow the responsibility of the upstream system to clean any
                                                      #                                        : shared dirty data from its caches before going into reset.
cci550.niden=1                                        # (bool  , init-time) default = '1'      : Whether non-secure events are allowed to be counted in the performance monitor
cci550.num_ace_lite_ports=5                           # (int   , init-time) default = '0x5'    : The bottom num_ace_lite_ports are ACE-Lite+DVM.
cci550.number_of_phantom_entries=32                   # (int   , init-time) default = '0x20'   : Number of phantom entries in the cache. Phantom entries are used by certain cache
                                                      #                                        : operations to hold temporary data. Usually this should be left at the default value
                                                      #                                        : which is safe for all systems containing up to 32 masters.
cci550.qos_threshold_upper=12                         # (int   , init-time) default = '0xc'    : Reset value for the QoS threshold register.
cci550.reentrancy_support=env                         # (string, init-time) default = 'env'    : Must be one of: on/off/cacheglobal/env: 'on': hazard checking per cache line (normal mode), 'off': no hazard checking (use only for single master systems), 'cacheglobal': hazard checking globally for cache (not per cache line, testing feature, provokes more hazards than necessary), 'env' (or empty string): take value from FM_REENTRANCY_SUPPORT env var, if this is not set use 'on', default is 'env'
cci550.si0_qos_bw_regulator=0                         # (bool  , init-time) default = '0'      : For upstream port 0 determine if it has a BW regulator.  The effect of QoS is not modelled and this parameter only alters some registers.
cci550.si1_qos_bw_regulator=0                         # (bool  , init-time) default = '0'      : For upstream port 1 determine if it has a BW regulator.  The effect of QoS is not modelled and this parameter only alters some registers.
cci550.si2_qos_bw_regulator=0                         # (bool  , init-time) default = '0'      : For upstream port 2 determine if it has a BW regulator.  The effect of QoS is not modelled and this parameter only alters some registers.
cci550.si3_qos_bw_regulator=0                         # (bool  , init-time) default = '0'      : For upstream port 3 determine if it has a BW regulator.  The effect of QoS is not modelled and this parameter only alters some registers.
cci550.si4_qos_bw_regulator=0                         # (bool  , init-time) default = '0'      : For upstream port 4 determine if it has a BW regulator.  The effect of QoS is not modelled and this parameter only alters some registers.
cci550.si5_qos_bw_regulator=0                         # (bool  , init-time) default = '0'      : For upstream port 5 determine if it has a BW regulator.  The effect of QoS is not modelled and this parameter only alters some registers.
cci550.si6_qos_bw_regulator=0                         # (bool  , init-time) default = '0'      : For upstream port 6 determine if it has a BW regulator.  The effect of QoS is not modelled and this parameter only alters some registers.
cci550.si_system_coherency_interface=0                # (int   , init-time) default = '0x0'    : This parameter tells the interconnect which upstream ports should be controlled by
                                                      #                                        : the System Coherency Interface.
                                                      #                                        : Each bit corresponds to an upstream port, bit 0 to upstream port 0, etc.
                                                      #                                        : If the SCI port is connected but si_system_coherency_interface disable its use
                                                      #                                        : then messages from the upstream will be ignored and software must manage the upstream
                                                      #                                        : system's entrance and exit of the coherency domain.
cci550.spiden=1                                       # (bool  , init-time) default = '1'      : Secure invasive debug enable.  If both SPIDEN and DBGEN are high, enables the counting
                                                      #                                        : of both Non-secure and Secure events.
cci550.spniden=1                                      # (bool  , init-time) default = '1'      : Whether secure and non-secure events are allowed to be counted in the
                                                      #                                        : performance monitor
cluster0.ADFSR-AIFSR-implemented=0                    # (bool  , init-time) default = '0'      : ADFSR and AIFSR are implemented
cluster0.AIDR=0                                       # (int   , init-time) default = '0x0'    : Value of AIDR_EL1 register.
cluster0.AMIIDR=1083                                  # (int   , init-time) default = '0x43b'  : Value of AMU Implementation Identification Register
cluster0.AMPIDR=17192169472                           # (int   , init-time) default = '0x400bbb000' : Value of AMU Peripheral Identification Register
cluster0.BPIMVA_causes_translation_lookup=0           # (bool  , init-time) default = '0'      : Do a translation when BPIMVA instruction is executed (which may cause a translation fault).
cluster0.CCSIDR-L1D_override=0                        # (int   , init-time) default = '0x0'    : If nonzero, override the value presented in CCSIDR for L1D (this is cosmetic and does not affect cache behaviour).
cluster0.CCSIDR-L1I_override=0                        # (int   , init-time) default = '0x0'    : If nonzero, override the value presented in CCSIDR for L1I (this is cosmetic and does not affect cache behaviour).
cluster0.CCSIDR-L2_override=0                         # (int   , init-time) default = '0x0'    : If nonzero, override the value presented in CCSIDR for L2 (this is cosmetic and does not affect cache behaviour).
cluster0.CCSIDR-L3_override=0                         # (int   , init-time) default = '0x0'    : If nonzero, allow L3 selection in CSSELR and present this value in CCSIDR (this is cosmetic and does not affect cache behaviour).
cluster0.CPUCFR=0                                     # (int   , init-time) default = '0x0'    : Value of CPU Configuration Register
cluster0.CTIPIDR=0                                    # (int   , init-time) default = '0x0'    : If non-zero, override the CTI Peripheral Identification Register
cluster0.CTR-L1Ip-override=0                          # (int   , init-time) default = '0x0'    : If non-zero, override the L1Ip bits in CTR/CTR_EL0 system register. This does not change the behaviour of the cache, only what is present in the CTR register.
cluster0.DBGBCR_BT_applies_RES0_before_valid_check=1  # (bool  , init-time) default = '1'      : If true, RES0 behaviour is applied to DBGBCR(_EL1).BT before checking for reserved values for this field.
cluster0.DBGPIDR=0                                    # (int   , init-time) default = '0x0'    : If non-zero, override the Debug Peripheral Identification Register
cluster0.DCRPZID_log2_block_size=4                    # (int   , init-time) default = '0x4'    : Log2 of the block size cleared by DC RPZPA instruction (as read from DCRPZID_EL1) (FEAT_RPZ).
cluster0.ERXMISC0_mask=0                              # (int   , init-time) default = '0x0'    : Write Mask for ERXMISC0 RAS Register
cluster0.GMID-log2-block-size=4                       # (int   , init-time) default = '0x4'    : Log2 of the block size accessed by STGM/LDGM/STZGM instructions
cluster0.ISV_set_to_0_for_stage2_synch_external_abort=0  # (bool  , init-time) default = '0'      : Whether ESR_EL2.ISV is set to 0 on stage 2 synchronous external aborts
cluster0.MIDR=1091555568                              # (int   , init-time) default = '0x410fd0f0' : Value of MIDR_EL1 register.
cluster0.NUM_CORES=4                                  # (int   , init-time) default = '0x4'    : Number of cores in cluster0
cluster0.PA_SIZE=40                                   # (int   , init-time) default = '0x28'   : Physical address range supported   For ARMv8.0 and ARMv8.1 this is limited to 48 bits (FEAT_LPA/FEAT_LPA3).
cluster0.PMCEID0=4294967295                           # (int   , init-time) default = '0xffffffff' :  Performance Monitor Common Event ID Reg 0 value - 64 bit
cluster0.PMCEID1=4294967295                           # (int   , init-time) default = '0xffffffff' :  Performance Monitor Common Event ID Reg 1 value - 64 bit
cluster0.PMSIDR.ArchInst=1                            # (bool  , init-time) default = '1'      : Defines whether architecture instruction sampling is implemented or not, if not only micro op sampling is implemented. Model only supports architecture instruction sampling, but allows ID register field to be configured.
cluster0.PMSIDR.LDS=0                                 # (bool  , init-time) default = '0'      : Defines whether data source for sampled load instruction is implemented or not. Model does not implement loaded data source, but allows ID register field to be configured.
cluster0.PMUPIDR=0                                    # (int   , init-time) default = '0x0'    : If non-zero, override the PMU Peripheral Identification Register
cluster0.abort_execution_from_device_memory=0         # (bool  , init-time) default = '0'      : Execution from device memory generates a prefetch abort.
cluster0.advsimd_bf16_support_level=0                 # (int   , init-time) default = '0x0'    : Implement BFloat16 operations from ARMv8.6. AArch64 Advanced SIMD and FP BFloat16 instructions are automatically enabled when has_arm_v8-6 is true.
                                                      #                                        :   - 0, Not implemented.
                                                      #                                        :   - 1, AArch64 Advanced SIMD and FP BFloat16 instructions only (FEAT_BF16).
                                                      #                                        :   - 2, AArch32 Advanced SIMD and VFP BFloat16 instructions only (FEAT_AA32BF16).
                                                      #                                        :   - 3, Both AArch64 Advanced SIMD and FP and AArch32 Advanced SIMD and VFP BFloat16 instructions.
cluster0.advsimd_i8mm_support_level=0                 # (int   , init-time) default = '0x0'    : Implement Int8 matrix multiply operations from ARMv8.6. AArch64 Advanced SIMD and FP Int8 matrix multiply instructions are automatically enabled when has_arm_v8-6 is true.
                                                      #                                        :   - 0, Not implemented.
                                                      #                                        :   - 1, AArch64 Advanced SIMD and FP Int8 matrix multiply instructions only (FEAT_I8MM).
                                                      #                                        :   - 2, AArch32 Advanced SIMD and VFP Int8 matrix multiply instructions only (FEAT_AA32I8MM).
                                                      #                                        :   - 3, Both AArch64 Advanced SIMD and FP and AArch32 Advanced SIMD and VFP Int8 matrix multiply instructions (FEAT_I8MM, FEAT_AA32I8MM).
cluster0.advsimd_overread=0                           # (bool  , init-time) default = '0'      : AdvSIMD element load operations access all bytes of a 16-byte aligned window, even in Device memory
cluster0.align_pc_on_branch_to_unaligned_pc_aarch32=0  # (bool  , init-time) default = '0'      : Force PC align for branches to an unaligned PC counter in A32 state
cluster0.align_pc_on_debug_exit_to_aarch32=0          # (bool  , init-time) default = '0'      : Exit to AARCH32 state from debug state forces pc bit0 to 0
cluster0.align_pc_on_illegal_exception_return_to_aarch32=1  # (bool  , init-time) default = '1'      : Align PC when performing an illegal exception return from AArch64 to AArch32.
cluster0.amair_reg_rw_mask=0                          # (int   , init-time) default = '0x0'    : RW mask for implementation-defined registers.
cluster0.amu_aux_type_fixed=                          # (string, init-time) default = ''       : Lists which AMU auxiliary registers that are fixed and to which event type. The JSON schema is: {fixed_aux_reg:evt_type, ...}. For example {"0":0x300} would make auxiliary register 0 fixed to event type 0x300
cluster0.amu_aux_voffset_mask=0                       # (int   , init-time) default = '0x0'    : If ARMv8.6 is implemented, each bit of the field, 0 to 15, when 1 indicates that the corresponding virtual offset register, AMEVCNTVOFF1<n>_EL2, is implemented
cluster0.amu_has_external_interface=0                 # (int   , init-time) default = '0x0'    : Implement external memory-mapped access to system register of activity monitor unit from ARMv8.4.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.amu_has_sysreg_interface=1                   # (bool  , init-time) default = '1'      : Implement system register access to activity monitor unit from ARMv8.4.
cluster0.amu_mmap_address=                            # (string, init-time) default = ''       : AMU base address for each core on system bus. 0 means the AMU is not mapped, otherwise the address must be 4KB aligned. JSON schema for the parameter value is: {"format":"all_addrs_are_absolute_wrt_systembus","cores": [{"amu":0x0},{"amu":0x0},{"amu":0x0},{"amu":0x0}]}
cluster0.amu_num_auxiliary_counters=0                 # (int   , init-time) default = '0x0'    : Number of AMU auxiliary counters implemented
cluster0.amu_reset_domain=0                           # (int   , init-time) default = '0x0'    : Reset domain for activity monitor unit. 0, COLD_RESET. 1, WARM_RESET. 2, NONE.
cluster0.amu_version=1                                # (int   , init-time) default = '0x1'    : Selects the activity monitor version implemented   - 1, AMUv1 for Armv8.4 is implemented.
                                                      #                                        :    - 2, AMUv1 for Armv8.6 is implemented (FEAT_AMUv1p1).
cluster0.apsr_read_restrict=0                         # (bool  , init-time) default = '0'      : At EL0, unknown bits of APSR are RAZ.
cluster0.arm_v8_7_accelerator_support_level=0         # (int   , init-time) default = '0x0'    : Implements Armv8.7 accelerator support instructions LD/ST64B, ST64BV, ST64BV0, etc. (FEAT_LS64, FEAT_LS64_V, FEAT_LS64_ACCDATA)
cluster0.atomic_fault_priority_s1=0                   # (int   , init-time) default = '0x0'    : This parameter describes the priority of unsupported atomic hardware update fault w.r.t alignment and permission fault at stage1. 0, BEFORE_ALIGN_MEM_FAULT. 1, AFTER_ALIGN_BEFORE_PERM_FAULT. 2, AFTER_PERM_FAULT.
cluster0.atomic_fault_priority_s2=0                   # (int   , init-time) default = '0x0'    : This parameter describes the priority of unsupported atomic hardware update fault w.r.t alignment and permission fault at stage2. 0, BEFORE_ALIGN_MEM_FAULT. 1, AFTER_ALIGN_BEFORE_PERM_FAULT. 2, AFTER_PERM_FAULT.
cluster0.atomic_fault_priority_s2_on_s1=0             # (int   , init-time) default = '0x0'    : This parameter describes the priority of unsupported atomic hardware update fault w.r.t alignment and permission fault for stage2 on stage1. 0, BEFORE_ALIGN_MEM_FAULT. 1, AFTER_ALIGN_BEFORE_PERM_FAULT. 2, AFTER_PERM_FAULT.
cluster0.auxilliary_feature_register0=0               # (int   , init-time) default = '0x0'    : Value of AFR0 ID register.
cluster0.branch-predictor-clear-policy=2              # (int   , init-time) default = '0x2'    : Set branch prediction policy as defined for MMFR1[31:28].  This does not change the behaviour of the branch predictor, only what is reported in MMFR1.BPred.
cluster0.branch-predictor-supported-ops=1             # (int   , init-time) default = '0x1'    : Set branch prediction policy as defined for MMFR3[11:8].  This does not change the behaviour of the branch predictor, only what is reported in MMFR3.BPMaint.
cluster0.brbe_log2_num_records=6                      # (int   , init-time) default = '0x6'    : Log2 of number of BRB records supported. 3 -> 8 records, ... 6 -> 64 records.
cluster0.cache-log2linelen=6                          # (int   , init-time) default = '0x6'    : Log2 of the cache line length in bytes.
cluster0.cache_maintenance_hits_watchpoints=0         # (bool  , init-time) default = '0'      : DCIMVA operations executed in AArch32 modes hit watchpoints.
cluster0.changing_block_size_without_bbm_support=0    # (int   , init-time) default = '0x0'    : Level of support for changing block size without break-before-make (FEAT_BBM).
cluster0.check_memory_attributes=1                    # (bool  , init-time) default = '1'      : Detect and report TLB use of conflicting memory attributes for views of the same physical address
cluster0.clear_IT_when_IL_set=0                       # (bool  , init-time) default = '0'      : Clear IT bits when performing a *legal* exception return to AArch32 when IL is set
cluster0.clear_IT_when_IL_set_explicitly=0            # (bool  , init-time) default = '0'      : Apart from clear_IT_when_IL_set, also clear IT bits when loading CPSR from SPSR/memory and IL == 1 in the value being loaded.
cluster0.clear_ec_in_debug_state=0                    # (bool  , init-time) default = '0'      : When ARMv8.8 debug extension is implemented, whether EDESR.EC bit is set/cleared on entering debug state due to pending exception catch caused by EDESR.EC=1.
cluster0.clear_reg_top_eret=1                         # (int   , init-time) default = '0x1'    : Behaviour of the upper 32-bits of the Xn registers when changing between AArch32 state and AArch64 state.  0, upper 32-bits preserved for all registers.  1, upper 32-bits set to 0 for all accessible registers. 2,  upper 32-bits set to 0 for a random selection of accessible registers. 3, upper-32-bits set to 0 for registers touched in AArch32
cluster0.clear_reg_top_set=1                          # (bool  , init-time) default = '1'      : Whether to clear upper 32-bits of the Xn register when corresponding AArch32 register is set via CADI/Iris.
cluster0.configure_v8_6_pmu_events_with_json=         # (string, init-time) default = ''       : Configure v8.6 PMU events. Note : This param has high priority and overrides the setting of "has_v8_6_pmu_events"(Will be deprecated in the future releases) if both the params are provided. JSON schema for the parameter value is e.g. 1. {"all":false} 2. {"pmu_events":["BR_INDNR_RETIRED","BR_IND_RETIRED","BR_RETURN_SKIP_RETIRED","BR_RETURN_ANY_RETIRED","BR_INDNR_SKIP_RETIRED","BR_INDNR_TAKEN_RETIRED","BR_IND_SKIP_RETIRED","BR_IND_TAKEN_RETIRED","BR_IMMED_SKIP_RETIRED","BR_IMMED_TAKEN_RETIRED","BR_SKIP_RETIRED"]}
cluster0.configure_v8_8_pmu_events_with_json=         # (string, init-time) default = ''       : Configure v8.8 PMU events. Note : This param has high priority and overrides the setting of "has_v8_8_pmu_events"(Will be deprecated in the future releases) if both the params are provided. JSON schema for the parameter value is e.g. 1. {"all":false} 2. {"pmu_events":["BR_HINT_COND_RETIRED","BR_COND_TAKEN_RETIRED","BR_UNCOND_RETIRED","BR_COND_RETIRED","BRNL_TAKEN_RETIRED","BRNL_IND_TAKEN_RETIRED","BRNL_INDNR_TAKEN_RETIRED","BRNL_IMMED_TAKEN_RETIRED","BL_TAKEN_RETIRED","BL_IND_TAKEN_RETIRED","BL_IMMED_TAKEN_RETIRED"]}
cluster0.cpacr_trcdis_behaviour=2                     # (int   , init-time) default = '0x2'    : Behaviour of CPACR.TRCDIS/NSACR.NSTRCDIS when there is no CP14 ETM interface. 0, RAZ/WI. 2, implemented.
cluster0.cpi_div=1                                    # (int   , run-time ) default = '0x1'    : Divider for calculating CPI (Cycles Per Instruction)
cluster0.cpi_mul=1                                    # (int   , run-time ) default = '0x1'    : Multiplier for calculating CPI (Cycles Per Instruction)
cluster0.cpu0.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster0.cpu0.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster0.cpu0.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster0.cpu0.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster0.cpu0.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster0.cpu0.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster0.cpu0.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster0.cpu0.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster0.cpu0.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster0.cpu0.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster0.cpu0.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster0.cpu0.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster0.cpu0.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster0.cpu0.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster0.cpu0.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster0.cpu0.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu0.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu0.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster0.cpu0.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster0.cpu0.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster0.cpu0.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu0.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu0.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu0.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu0.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster0.cpu0.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster0.cpu0.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster0.cpu0.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster0.cpu0.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster0.cpu0.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster0.cpu0.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster0.cpu0.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster0.cpu0.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster0.cpu0.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster0.cpu0.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster0.cpu0.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster0.cpu0.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster0.cpu0.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster0.cpu0.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster0.cpu0.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster0.cpu0.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster0.cpu0.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster0.cpu0.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster0.cpu0.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster0.cpu0.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster0.cpu0.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster0.cpu0.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster0.cpu0.semihosting-heap_limit=4278190080       # (int   , init-time) default = '0xff000000' : Virtual address of top of heap.
cluster0.cpu0.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster0.cpu0.semihosting-stack_base=4294901760       # (int   , init-time) default = '0xffff0000' : Virtual address of base of descending stack.
cluster0.cpu0.semihosting-stack_limit=4278190080      # (int   , init-time) default = '0xff000000' : Virtual address of stack limit.
cluster0.cpu0.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster0.cpu0.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster0.cpu0.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster0.cpu0.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster0.cpu0.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster0.cpu0.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster0.cpu0.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster0.cpu0.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster0.cpu0.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster0.cpu0.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster0.cpu0.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu0.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu1.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster0.cpu1.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster0.cpu1.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster0.cpu1.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster0.cpu1.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster0.cpu1.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster0.cpu1.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster0.cpu1.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster0.cpu1.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster0.cpu1.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster0.cpu1.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster0.cpu1.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster0.cpu1.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster0.cpu1.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster0.cpu1.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster0.cpu1.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu1.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu1.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster0.cpu1.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster0.cpu1.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster0.cpu1.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu1.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu1.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu1.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu1.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster0.cpu1.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster0.cpu1.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster0.cpu1.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster0.cpu1.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster0.cpu1.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster0.cpu1.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster0.cpu1.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster0.cpu1.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster0.cpu1.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster0.cpu1.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster0.cpu1.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster0.cpu1.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster0.cpu1.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster0.cpu1.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster0.cpu1.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster0.cpu1.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster0.cpu1.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster0.cpu1.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster0.cpu1.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster0.cpu1.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster0.cpu1.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster0.cpu1.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster0.cpu1.semihosting-heap_limit=4278190080       # (int   , init-time) default = '0xff000000' : Virtual address of top of heap.
cluster0.cpu1.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster0.cpu1.semihosting-stack_base=4294901760       # (int   , init-time) default = '0xffff0000' : Virtual address of base of descending stack.
cluster0.cpu1.semihosting-stack_limit=4278190080      # (int   , init-time) default = '0xff000000' : Virtual address of stack limit.
cluster0.cpu1.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster0.cpu1.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster0.cpu1.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster0.cpu1.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster0.cpu1.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster0.cpu1.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster0.cpu1.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster0.cpu1.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster0.cpu1.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster0.cpu1.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster0.cpu1.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu1.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu2.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster0.cpu2.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster0.cpu2.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster0.cpu2.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster0.cpu2.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster0.cpu2.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster0.cpu2.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster0.cpu2.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster0.cpu2.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster0.cpu2.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster0.cpu2.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster0.cpu2.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster0.cpu2.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster0.cpu2.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster0.cpu2.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster0.cpu2.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu2.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu2.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster0.cpu2.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster0.cpu2.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster0.cpu2.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu2.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu2.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu2.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu2.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster0.cpu2.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster0.cpu2.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster0.cpu2.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster0.cpu2.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster0.cpu2.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster0.cpu2.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster0.cpu2.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster0.cpu2.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster0.cpu2.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster0.cpu2.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster0.cpu2.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster0.cpu2.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster0.cpu2.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster0.cpu2.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster0.cpu2.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster0.cpu2.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster0.cpu2.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster0.cpu2.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster0.cpu2.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster0.cpu2.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster0.cpu2.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster0.cpu2.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster0.cpu2.semihosting-heap_limit=4278190080       # (int   , init-time) default = '0xff000000' : Virtual address of top of heap.
cluster0.cpu2.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster0.cpu2.semihosting-stack_base=4294901760       # (int   , init-time) default = '0xffff0000' : Virtual address of base of descending stack.
cluster0.cpu2.semihosting-stack_limit=4278190080      # (int   , init-time) default = '0xff000000' : Virtual address of stack limit.
cluster0.cpu2.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster0.cpu2.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster0.cpu2.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster0.cpu2.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster0.cpu2.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster0.cpu2.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster0.cpu2.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster0.cpu2.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster0.cpu2.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster0.cpu2.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster0.cpu2.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu2.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu3.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster0.cpu3.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster0.cpu3.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster0.cpu3.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster0.cpu3.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster0.cpu3.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster0.cpu3.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster0.cpu3.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster0.cpu3.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster0.cpu3.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster0.cpu3.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster0.cpu3.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster0.cpu3.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster0.cpu3.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster0.cpu3.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster0.cpu3.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu3.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu3.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster0.cpu3.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster0.cpu3.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster0.cpu3.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu3.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu3.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu3.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu3.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster0.cpu3.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster0.cpu3.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster0.cpu3.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster0.cpu3.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster0.cpu3.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster0.cpu3.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster0.cpu3.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster0.cpu3.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster0.cpu3.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster0.cpu3.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster0.cpu3.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster0.cpu3.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster0.cpu3.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster0.cpu3.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster0.cpu3.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster0.cpu3.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster0.cpu3.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster0.cpu3.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster0.cpu3.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster0.cpu3.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster0.cpu3.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster0.cpu3.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster0.cpu3.semihosting-heap_limit=4278190080       # (int   , init-time) default = '0xff000000' : Virtual address of top of heap.
cluster0.cpu3.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster0.cpu3.semihosting-stack_base=4294901760       # (int   , init-time) default = '0xffff0000' : Virtual address of base of descending stack.
cluster0.cpu3.semihosting-stack_limit=4278190080      # (int   , init-time) default = '0xff000000' : Virtual address of stack limit.
cluster0.cpu3.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster0.cpu3.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster0.cpu3.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster0.cpu3.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster0.cpu3.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster0.cpu3.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster0.cpu3.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster0.cpu3.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster0.cpu3.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster0.cpu3.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster0.cpu3.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu3.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu4.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster0.cpu4.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster0.cpu4.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster0.cpu4.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster0.cpu4.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster0.cpu4.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster0.cpu4.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster0.cpu4.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster0.cpu4.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster0.cpu4.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster0.cpu4.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster0.cpu4.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster0.cpu4.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster0.cpu4.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster0.cpu4.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster0.cpu4.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu4.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu4.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster0.cpu4.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster0.cpu4.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster0.cpu4.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu4.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu4.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu4.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu4.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster0.cpu4.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster0.cpu4.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster0.cpu4.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster0.cpu4.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster0.cpu4.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster0.cpu4.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster0.cpu4.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster0.cpu4.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster0.cpu4.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster0.cpu4.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster0.cpu4.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster0.cpu4.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster0.cpu4.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster0.cpu4.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster0.cpu4.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster0.cpu4.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster0.cpu4.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster0.cpu4.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster0.cpu4.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster0.cpu4.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster0.cpu4.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster0.cpu4.semihosting-enable=1                    # (bool  , init-time) default = '1'      : Enable semihosting SVC/HLT traps.
cluster0.cpu4.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster0.cpu4.semihosting-heap_limit=251658240        # (int   , init-time) default = '0xf000000' : Virtual address of top of heap.
cluster0.cpu4.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster0.cpu4.semihosting-stack_base=268435456        # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cluster0.cpu4.semihosting-stack_limit=251658240       # (int   , init-time) default = '0xf000000' : Virtual address of stack limit.
cluster0.cpu4.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster0.cpu4.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster0.cpu4.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster0.cpu4.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster0.cpu4.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster0.cpu4.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster0.cpu4.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster0.cpu4.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster0.cpu4.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster0.cpu4.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster0.cpu4.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu4.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu5.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster0.cpu5.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster0.cpu5.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster0.cpu5.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster0.cpu5.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster0.cpu5.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster0.cpu5.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster0.cpu5.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster0.cpu5.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster0.cpu5.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster0.cpu5.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster0.cpu5.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster0.cpu5.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster0.cpu5.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster0.cpu5.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster0.cpu5.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu5.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu5.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster0.cpu5.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster0.cpu5.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster0.cpu5.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu5.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu5.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu5.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu5.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster0.cpu5.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster0.cpu5.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster0.cpu5.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster0.cpu5.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster0.cpu5.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster0.cpu5.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster0.cpu5.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster0.cpu5.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster0.cpu5.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster0.cpu5.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster0.cpu5.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster0.cpu5.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster0.cpu5.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster0.cpu5.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster0.cpu5.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster0.cpu5.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster0.cpu5.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster0.cpu5.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster0.cpu5.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster0.cpu5.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster0.cpu5.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster0.cpu5.semihosting-enable=1                    # (bool  , init-time) default = '1'      : Enable semihosting SVC/HLT traps.
cluster0.cpu5.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster0.cpu5.semihosting-heap_limit=251658240        # (int   , init-time) default = '0xf000000' : Virtual address of top of heap.
cluster0.cpu5.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster0.cpu5.semihosting-stack_base=268435456        # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cluster0.cpu5.semihosting-stack_limit=251658240       # (int   , init-time) default = '0xf000000' : Virtual address of stack limit.
cluster0.cpu5.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster0.cpu5.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster0.cpu5.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster0.cpu5.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster0.cpu5.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster0.cpu5.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster0.cpu5.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster0.cpu5.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster0.cpu5.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster0.cpu5.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster0.cpu5.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu5.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu6.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster0.cpu6.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster0.cpu6.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster0.cpu6.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster0.cpu6.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster0.cpu6.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster0.cpu6.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster0.cpu6.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster0.cpu6.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster0.cpu6.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster0.cpu6.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster0.cpu6.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster0.cpu6.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster0.cpu6.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster0.cpu6.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster0.cpu6.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu6.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu6.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster0.cpu6.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster0.cpu6.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster0.cpu6.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu6.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu6.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu6.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu6.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster0.cpu6.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster0.cpu6.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster0.cpu6.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster0.cpu6.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster0.cpu6.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster0.cpu6.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster0.cpu6.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster0.cpu6.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster0.cpu6.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster0.cpu6.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster0.cpu6.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster0.cpu6.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster0.cpu6.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster0.cpu6.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster0.cpu6.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster0.cpu6.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster0.cpu6.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster0.cpu6.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster0.cpu6.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster0.cpu6.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster0.cpu6.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster0.cpu6.semihosting-enable=1                    # (bool  , init-time) default = '1'      : Enable semihosting SVC/HLT traps.
cluster0.cpu6.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster0.cpu6.semihosting-heap_limit=251658240        # (int   , init-time) default = '0xf000000' : Virtual address of top of heap.
cluster0.cpu6.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster0.cpu6.semihosting-stack_base=268435456        # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cluster0.cpu6.semihosting-stack_limit=251658240       # (int   , init-time) default = '0xf000000' : Virtual address of stack limit.
cluster0.cpu6.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster0.cpu6.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster0.cpu6.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster0.cpu6.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster0.cpu6.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster0.cpu6.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster0.cpu6.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster0.cpu6.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster0.cpu6.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster0.cpu6.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster0.cpu6.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu6.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu7.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster0.cpu7.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster0.cpu7.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster0.cpu7.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster0.cpu7.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster0.cpu7.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster0.cpu7.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster0.cpu7.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster0.cpu7.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster0.cpu7.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster0.cpu7.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster0.cpu7.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster0.cpu7.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster0.cpu7.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster0.cpu7.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster0.cpu7.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu7.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster0.cpu7.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster0.cpu7.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster0.cpu7.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster0.cpu7.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu7.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu7.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu7.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.cpu7.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster0.cpu7.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster0.cpu7.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster0.cpu7.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster0.cpu7.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster0.cpu7.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster0.cpu7.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster0.cpu7.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster0.cpu7.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster0.cpu7.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster0.cpu7.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster0.cpu7.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster0.cpu7.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster0.cpu7.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster0.cpu7.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster0.cpu7.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster0.cpu7.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster0.cpu7.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster0.cpu7.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster0.cpu7.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster0.cpu7.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster0.cpu7.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster0.cpu7.semihosting-enable=1                    # (bool  , init-time) default = '1'      : Enable semihosting SVC/HLT traps.
cluster0.cpu7.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster0.cpu7.semihosting-heap_limit=251658240        # (int   , init-time) default = '0xf000000' : Virtual address of top of heap.
cluster0.cpu7.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster0.cpu7.semihosting-stack_base=268435456        # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cluster0.cpu7.semihosting-stack_limit=251658240       # (int   , init-time) default = '0xf000000' : Virtual address of stack limit.
cluster0.cpu7.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster0.cpu7.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster0.cpu7.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster0.cpu7.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster0.cpu7.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster0.cpu7.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster0.cpu7.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster0.cpu7.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster0.cpu7.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster0.cpu7.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster0.cpu7.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpu7.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster0.cpuselr_el3_sync_immediate=1                 # (bool  , init-time) default = '1'      : Adjust when the patching selection register synchronises - either immediately (true - default), or awaiting for barrier event
cluster0.cpy_mops_option=0                            # (int   , init-time) default = '0x0'    : Set option for Armv8.8 CPY(FEAT_MOPS). 0, use default(i.e. use value configured through has_mops_option). 1, implemented using Option A. 2, implemented using Option B
cluster0.cpyf_mops_option=0                           # (int   , init-time) default = '0x0'    : Set option for Armv8.8 CPYF(FEAT_MOPS). 0, use default(i.e. use value configured through has_mops_option). 1, implemented using Option A. 2, implemented using Option B
cluster0.dbg-bcr-reserved-behavior=1                  # (int   , init-time) default = '0x1'    : This is the behavior of the reserved values of the BT field in DBGBCRPossible values are:  - 0 = Disabled.
                                                      #                                        :   - 1 = BT[2] is ignored.
                                                      #                                        : 
cluster0.dbg_rom_dap_addr=0                           # (int   , init-time) default = '0x0'    : Debug ROM dap base address.
cluster0.dbgitr_buffer_size=0                         # (int   , init-time) default = '0x0'    : Number of instructions which can be buffered before EDSCR.ITE is cleared
cluster0.dbgxvr_ress_is_stateful=0                    # (bool  , init-time) default = '0'      : Whether DBGWVR/DBGBVR.RESS returns last written value. if set to false, RESS returns sign extended value
cluster0.dc_fault_unaligned_s1_device_s2_fwb=0        # (bool  , init-time) default = '0'      : Whether takes an Alignment Fault caused by the memory type on a DC {ZVA,GZVA,GVA} if the stage 1 memory type is any Device memory type
cluster0.dcache-hit_latency=0                         # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when dcache-state_modelled=true.
cluster0.dcache-maintenance_latency=0                 # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when dcache-state_modelled=true.
cluster0.dcache-miss_latency=0                        # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when dcache-state_modelled=true.
cluster0.dcache-prefetch_enabled=0                    # (bool  , init-time) default = '0'      : Enable simulation of data cache prefetching.  This is only used when dcache-state_modelled=true
cluster0.dcache-read_access_latency=0                 # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for read accesses given in ticks per access (of size dcache-read_bus_width_in_bytes).  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if dcache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when dcache-state_modelled=true.
cluster0.dcache-read_bus_width_in_bytes=8             # (int   , init-time) default = '0x8'    : L1 D-Cache read bus width in bytes used to calculate per-access timing annotations
cluster0.dcache-read_latency=0                        # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for read accesses given in ticks per byte accessed.dcache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when dcache-state_modelled=true.
cluster0.dcache-size=32768                            # (int   , init-time) default = '0x8000' : L1 D-Cache size in bytes.
cluster0.dcache-snoop_data_transfer_latency=0         # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for received snoop accesses that perform a data transfer given in ticks per byte accessed. This is only used when dcache-state_modelled=true.
cluster0.dcache-ways=2                                # (int   , init-time) default = '0x2'    : L1 D-Cache number of ways (sets are implicit from size).
cluster0.dcache-write_access_latency=0                # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for write accesses given in ticks per access (of size dcache-write_bus_width_in_bytes). If this parameter is non-zero, per-access latencies will be used instead of per-byte even if dcache-write_latency is set. This is only used when dcache-state_modelled=true.
cluster0.dcache-write_bus_width_in_bytes=8            # (int   , init-time) default = '0x8'    : L1 D-Cache write bus width in bytes used to calculate per-access timing annotations
cluster0.dcache-write_latency=0                       # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for write accesses given in ticks per byte accessed. dcache-write_access_latency must be set to 0 for per-byte latencies to be applied. This is only used when dcache-state_modelled=true.
cluster0.dcimva_requires_s2_write_permissions=0       # (bool  , init-time) default = '0'      : Data-cache invalidate by MVA operations require stage 2 write permission (virtualised AArch32 guest).
cluster0.dczva_reports_lowest_addr_on_tag_check_fail=0  # (bool  , init-time) default = '0'      : Whether DC ZVA reports lowest address in FAR on tag check fail
cluster0.dczva_wp_far_behaviour=0                     # (int   , init-time) default = '0x0'    : Set option for address stored in FAR/EDWARD after watchpoints hit by DC ZVA.
                                                      #                                        :  0 - FAR recorded matches lowest watchpointed address accessed by the instruction
                                                      #                                        :  1 - FAR recorded matches lowest address accessed by the instruction within same translation granule as watchpointed address
                                                      #                                        :  2 - FAR recorded matches highest address accessed by the instruction within same translation granule as watchpointed address
cluster0.debug_auth_signals_sampled_at_reset=0        # (bool  , init-time) default = '0'      : Debug authentication signals can be configured as either sampled at reset only or at any time for External Root Debug.
cluster0.debug_components_dap_address=                # (string, init-time) default = ''       : Debug components ROM,ED,CTI,PMU,TRACE and TRBU base address for each core on debug bus. The "rom" field in the "cores" array are only allowed when 'debug_rom_is_flat' is false. JSON schema for the parameter value is: {"format":"all_addrs_are_absolute_wrt_debugbus","cores": [{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0}]}
cluster0.debug_components_mmap_address=               # (string, init-time) default = ''       : Debug components ROM,ED,CTI,PMU,TRACE and TRBU base address for each core on system bus. The "rom" field in the "cores" array are only allowed when 'debug_rom_is_flat' is false. JSON schema for the parameter value is: {"format":"all_addrs_are_absolute_wrt_systembus","cores": [{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0}]}
cluster0.debug_entry_is_context_sync=0                # (bool  , init-time) default = '0'      : If true, Entry in debug state is Context sync. Exiting debug state is a context synchronising operation, but entering is not. However some cpu implementation can consider also the Entry in Debug state as a CSE
cluster0.debug_rom_is_class_9=0                       # (bool  , init-time) default = '0'      : If true, present a debug ROM table as a class 9 device.  Otherwise, use a class 1 ROM table.
cluster0.debug_rom_is_flat=0                          # (bool  , init-time) default = '0'      : If true, present a debug ROM table recommended by ARMv8 Debug Architecture.  Otherwise, use nested ROM tables.
cluster0.delay_serror=0                               # (int   , init-time) default = '0x0'    : Add a propagation delay of serror signal into the core
cluster0.delayed_dbgreg_between_secure_views=1        # (int   , init-time) default = '0x1'    : If delayed_dbgreg is enabled, whether the secure and nonsecure external views require explicit synchronization.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.delayed_pmureg_between_secure_views=1        # (int   , init-time) default = '0x1'    : If delayed_pmureg is enabled, whether the secure and nonsecure external views require explicit synchronization.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.dic-spi_count=64                             # (int   , init-time) default = '0x40'   : Number of shared peripheral interrupts implemented
cluster0.disable_sve_plugin=0                         # (bool  , init-time) default = '0'      : If true, SVE will not be implemented in this processor even if the plugin is loaded (FEAT_SVE).
cluster0.disable_unknown_update_event_on_reset=0      # (bool  , init-time) default = '0'      : Disables SYSREG_UPDATE event notification on reset for the registers whose bitfields are all reserved or resets to architecturally unknown value
cluster0.ecv_support_level=0                          # (int   , init-time) default = '0x0'    : Implement Enhanced Counter Virtualization feature from ARMv8.6. 0, Not supported. 1, fully supported without CNTPOFF. 2, fully supported with CNTPOFF (FEAT_ECV).
cluster0.edpfr_ras_unknown_bits_read_as_0=0           # (bool  , init-time) default = '0'      : If true then UNKNOWN bits in RAS field in EDPFR are read as 0
cluster0.edxfr_reads_idreg=0                          # (bool  , init-time) default = '0'      : Whether EDDFR,EDFR1 reads corresponding bitfield value from ID_AA64DFR reg.
cluster0.el0_can_access_imp_def_functionality=0       # (bool  , init-time) default = '0'      : If not made UNDEF by imp_def_functionality_behaviour, EL0 can access IMPLEMENTATION DEFINED registers and system instructions.
cluster0.el0_el1_only_non_secure=0                    # (bool  , init-time) default = '0'      : Secure/non-secure state if EL2 and EL3 are not implemented.  0, secure.  1, non-secure.
cluster0.el3_trap_priority_when_secure_debug_disabled=0  # (bool  , init-time) default = '0'      : Undef when secure debug is disabled (EDSCR.SDD == 1) && boolean IMPLEMENTATION_DEFINED 'EL3 trap priority when SDD == 1'
cluster0.enable_address_contig_check=0                # (bool  , init-time) default = '0'      : Check the input address range for the table entries that have the contiguous hint bit set.
cluster0.enable_debug_auth_signals_config=15          # (int   , init-time) default = '0xf'    : Debug Authentication Signals DBGEN, SPIDEN (and if RME is enabled RLPIDEN and RTPIDEN)are configurable (default) or not configurable, (hardwired to 1). This parameter is theInteger representation of a bitmap to enable configuration of these signals, with:
                                                      #                                        :   - BIT[0] = DBGEN
                                                      #                                        :   - BIT[1] = SPIDEN
                                                      #                                        :   - BIT[2] = RLPIDEN
                                                      #                                        :   - BIT[3] = RTPIDEN
                                                      #                                        : 
cluster0.enable_tlb_contig_check=0                    # (bool  , init-time) default = '0'      : Perform extra pagetable walks to check translation table entries that have the contiguous hint bit set.
cluster0.enhanced_pac2_level=0                        # (int   , init-time) default = '0x0'    : Implements Enhanced PAC2 from ARMv8.6 (FEAT_PAuth2). This feature is mandatory for ARMv8.6 but can be cherrypicked to a ARMv8.3(or greater) implementation. 0: No EnhancedPAC2, 1: EnhancedPAC2 Only (FEAT_PAuth2), 2: EnhancedPAC2 with FPAC (FEAT_FPAC), 3: EnhancedPAC2 with FPACCombined (FEAT_FPACCOMBINE).
cluster0.error_record_feature_register=               # (string, init-time) default = ''       : RAS feature register values. An array of JSON objects. The JSON schema for the array is: [{"ED":0x0,"IMPDEF_3_2":0x0,"UI":0x0,"FI":0x0,"UE":0x0,"CFI":0x0,"CEC":0x0,"RP":0x0,"DUI":0x0,"CEO":0x0,"CI":0x0,"TS":0x0,"INJ":0x0,"FRX":0x0,"UC":0x0,"UEU":0x0,"UER":0x0,"UEO":0x0,"DE":0x0,"CE":0x0,"Visibility":"Core"},other_feature_register_values]. Where ED,UI,FI,CE and UE have valid values between 0x0 - 0x3. CFI and DUI have valid values 0x0, 0x2 and 0x3. CEC has valid values 0x0,0x2 or 0x4. RP,CEO,INJ,FRX,UC,UEU,UER,UEO,DE has valid values 0x0 or 0x1. CI and TS has valid values of 0x0, 0x1 and 0x2. Visibility has valid values "Core" or "Cluster"
cluster0.error_record_feature_register_json_file=     # (string, init-time) default = ''       : File path to the RAS feature register values as JSON. The file uses the same format as the error_record_feature_register parameter value
cluster0.esr_write_update_res0=0                      # (bool  , init-time) default = '0'      : If true, and RASv2 is enabled, then ESR_ELx.WU field is RES0 for errors on both loads and stores (FEAT_RASv2).
cluster0.ete.ASYNC_PACKETS_WHEN_VIEWINST_OFF=0        # (bool  , init-time) default = '0'      : Generate the non-periodic alignment synchronisation packet generation when trace unit is operative
cluster0.ete.ATBTRIG=1                                # (bool  , init-time) default = '1'      : ATB trigger support
cluster0.ete.CCITMIN=4                                # (int   , init-time) default = '0x4'    : Minimum cycle count value
cluster0.ete.CCSIZE=12                                # (int   , init-time) default = '0xc'    : Cycle counter size
cluster0.ete.CLAIMTAGS=8                              # (int   , init-time) default = '0x8'    : Number of claim tags
cluster0.ete.COMMOPT=1                                # (bool  , init-time) default = '1'      : Commit mode
cluster0.ete.COMMTRANS=0                              # (bool  , init-time) default = '0'      : Commit transaction mode
cluster0.ete.DEBUG=2                                  # (int   , init-time) default = '0x2'    : DEBUG
cluster0.ete.DESIGNER=65                              # (int   , init-time) default = '0x41'   : DESIGNER value
cluster0.ete.ETE_REVISION=0                           # (int   , init-time) default = '0x0'    : ETE revision: 0=ETEv1.0, 1=ETEv1.1, 2=ETEv1.2, 3=ETEv1.3
cluster0.ete.EXCEPTION_WITH_CONTEXT=1                 # (bool  , init-time) default = '1'      : Whether EXCEPTION_WITH_CONTEXT packet is supported
cluster0.ete.EXPLICITLY_COMMIT_P0_ELEMS=0             # (bool  , init-time) default = '0'      : Whether to unilaterally explicitly emit a commit after a P0 packet
cluster0.ete.IMPDEFEXCEPPERCENTAGE=0                  # (int   , init-time) default = '0x0'    : Percentage of IMPDEF exceptions inserted in instruction blocks
cluster0.ete.IMPRECISE_FILTERING=0                    # (int   , init-time) default = '0x0'    : Number of instruction blocks traced on a transition in the filtering
cluster0.ete.LPOVERRIDE=1                             # (bool  , init-time) default = '1'      : Low power override
cluster0.ete.MAXSPEC=0                                # (int   , init-time) default = '0x0'    : Maximum speculation depth
cluster0.ete.MAX_INST_PER_Q=1                         # (int   , init-time) default = '0x1'    : Max limit for the number of instructions implied by a Q element
cluster0.ete.NOOVERFLOW=0                             # (bool  , init-time) default = '0'      : No overflow
cluster0.ete.NUMACPAIRS=4                             # (int   , init-time) default = '0x4'    : Number of instruction address comparators pairs
cluster0.ete.NUMCIDC=1                                # (int   , init-time) default = '0x1'    : Number of context ID comparators
cluster0.ete.NUMCNTR=2                                # (int   , init-time) default = '0x2'    : Number of counters
cluster0.ete.NUMEXTINSEL=4                            # (int   , init-time) default = '0x4'    : Number of external input selectors
cluster0.ete.NUMPC=0                                  # (int   , init-time) default = '0x0'    : Number of PE comparators
cluster0.ete.NUMSEQSTATE=4                            # (int   , init-time) default = '0x4'    : Number of sequencer states
cluster0.ete.NUMSSCC=1                                # (int   , init-time) default = '0x1'    : Number of single shot comparators
cluster0.ete.NUMVMIDC=1                               # (int   , init-time) default = '0x1'    : Number of virtual ID comparators
cluster0.ete.NumberOfETEEvents=2                      # (int   , init-time) default = '0x2'    : Number of trace events
cluster0.ete.NumberOfRSPairs=8                        # (int   , init-time) default = '0x8'    : Number of resource selectors
cluster0.ete.PIDR_CMOD=0                              # (int   , init-time) default = '0x0'    : TRCPIDR CMOD value
cluster0.ete.PIDR_DESIGNER=0                          # (int   , init-time) default = '0x0'    : TRCPIDR DESIGNER value
cluster0.ete.PIDR_PART=0                              # (int   , init-time) default = '0x0'    : TRCPIDR PART number value
cluster0.ete.PIDR_REVAND=0                            # (int   , init-time) default = '0x0'    : TRCPIDR REVAND value
cluster0.ete.PIDR_REVISION=0                          # (int   , init-time) default = '0x0'    : TRCPIDR REVISION value
cluster0.ete.QFILT=0                                  # (bool  , init-time) default = '0'      : Q filtering
cluster0.ete.QSUP=0                                   # (int   , init-time) default = '0x0'    : Q support
cluster0.ete.Q_CADENCE=1                              # (int   , init-time) default = '0x1'    : Number of instruction blocks traced between two Q elements
cluster0.ete.REG_ACCESS_ONLY_MODE=0                   # (bool  , init-time) default = '0'      : If enabled all traces are disabled. Plugin only allows register acceses
cluster0.ete.RES0_STATEFUL=0                          # (bool  , init-time) default = '0'      : Whether RES0 bits are stateful or RAZ/WI
cluster0.ete.RETSTACK=3                               # (int   , init-time) default = '0x3'    : Return stack depth
cluster0.ete.REVISION=0                               # (int   , init-time) default = '0x0'    : TRCIDR1 revision value
cluster0.ete.SIM_OVERFLOW_GRANULARITY=100             # (int   , init-time) default = '0x64'   : Number of instruction blocks in each granule, for simulated overflow
cluster0.ete.SIM_OVERFLOW_PERCENTAGE=0                # (int   , init-time) default = '0x0'    : Percentage of instruction blocks lost in each granule, for simulated overflow
cluster0.ete.SOURCE_ADDRESS=0                         # (bool  , init-time) default = '0'      : Allow generation of source address elements
cluster0.ete.STALLCTRL=1                              # (bool  , init-time) default = '1'      : Stall control
cluster0.ete.SYSSTALL=1                               # (bool  , init-time) default = '1'      : System stall
cluster0.ete.TRACEIDSIZE=7                            # (int   , init-time) default = '0x7'    : Trace ID size
cluster0.ete.TRACE_OUTPUT=                            # (string, init-time) default = ''       : File to which to write trace byte stream
cluster0.ete.TRACE_OUTPUT_ENABLE=0                    # (bool  , init-time) default = '0'      : ETE Trace output enable : 1=enable, 0=disable
cluster0.ete.TRCRSRTA_FORCED_EXCEP=0                  # (bool  , init-time) default = '0'      : TRCRSR.TA value for a forcibly traced exception
cluster0.ete.TSMARK=0                                 # (bool  , init-time) default = '0'      : Whether timestamp markers are supported
cluster0.ete.TSSIZE=8                                 # (int   , init-time) default = '0x8'    : Timestamp size
cluster0.ete.WFXMODE=1                                # (bool  , init-time) default = '1'      : WFX mode
cluster0.exception_catch_before_software_step=1       # (bool  , init-time) default = '1'      : Exception catch priority for the exception trapping form of exception catch (Armv8.2 or later, or exception_catch_type=0). If true, the exception catch debug event has higher prority than software step and halting step.
cluster0.exception_catch_type=0                       # (int   , init-time) default = '0x0'    : Type of exception catch (ARMv8.0 - ARMv8.1 only). 0, exception trapping. 1, non-exception trapping, higher priority than step. 2, non-exception trapping, lower priority than step.
cluster0.exclusive_monitor_clear_on_atomic_from_same_master=1  # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared by a atomic by the same master to the monitored address.
cluster0.exclusive_monitor_clear_on_store_from_same_master=1  # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared by a store by the same master to the monitored address.
cluster0.exclusive_monitor_clear_on_strex_address_mismatch=1  # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared when a strex fails because the address does not match.
cluster0.exclusive_monitor_clear_on_strex_success=1   # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared when a strex succeeds.
cluster0.exercise_stxr_fail=0                         # (bool  , init-time) default = '0'      : Reject a pseudo-random majority of exclusive store instructions
cluster0.ext_abort_device_GRE_prefetch_ras_index=-1   # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_device_GRE_prefetch_ras_type=-1    # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_device_GRE_read_is_critical=0      # (bool  , init-time) default = '0'      : Critical reporting of device-GRE read external aborts.
cluster0.ext_abort_device_GRE_read_is_sync=2          # (int   , init-time) default = '0x2'    : Synchronous reporting of device-GRE read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_read_is_sync.
cluster0.ext_abort_device_GRE_read_ras_index=-1       # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_read_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_device_GRE_read_ras_type=-1        # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_device_GRE_write_is_critical=0     # (bool  , init-time) default = '0'      : Critical reporting of device-GRE write external aborts
cluster0.ext_abort_device_GRE_write_is_sync=2         # (int   , init-time) default = '0x2'    : Synchronous reporting of device-GRE write external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_write_is_sync.
cluster0.ext_abort_device_GRE_write_ras_index=-1      # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_write_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_device_GRE_write_ras_type=-1       # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_write_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_device_nGRE_prefetch_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_device_nGRE_prefetch_ras_type=-1   # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_device_nGRE_read_is_critical=0     # (bool  , init-time) default = '0'      : Critical reporting of device-nGRE read external aborts.
cluster0.ext_abort_device_nGRE_read_is_sync=2         # (int   , init-time) default = '0x2'    : Synchronous reporting of device-nGRE read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_read_is_sync.
cluster0.ext_abort_device_nGRE_read_ras_index=-1      # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_read_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_device_nGRE_read_ras_type=-1       # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_device_nGRE_write_is_critical=0    # (bool  , init-time) default = '0'      : Critical reporting of device-nGRE write external aborts
cluster0.ext_abort_device_nGRE_write_is_sync=2        # (int   , init-time) default = '0x2'    : Synchronous reporting of device-nGRE write external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_write_is_sync.
cluster0.ext_abort_device_nGRE_write_ras_index=-1     # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_write_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_device_nGRE_write_ras_type=-1      # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_write_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_device_prefetch_ras_index=-1       # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_device_prefetch_ras_type=-1        # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_device_read_acquire_is_sync=0      # (bool  , init-time) default = '0'      : Synchronous reporting of device read with acquire external aborts
cluster0.ext_abort_device_read_is_critical=0          # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRE read external aborts
cluster0.ext_abort_device_read_is_sync=1              # (bool  , init-time) default = '1'      : Synchronous reporting of device-nGnRE read external aborts
cluster0.ext_abort_device_read_ras_index=0            # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_device_read_ras_type=0             # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_device_write_is_critical=0         # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRE write external aborts
cluster0.ext_abort_device_write_is_sync=0             # (bool  , init-time) default = '0'      : Synchronous reporting of device-nGnRE write external aborts
cluster0.ext_abort_device_write_ras_index=0           # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_device_write_ras_type=0            # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_fill_data=-144680349987897859      # (int   , init-time) default = '0xfdfdfdfcfcfdfdfd' : Returned data, if external aborts are asynchronous
cluster0.ext_abort_normal_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-back cacheable-read external aborts
cluster0.ext_abort_normal_cacheable_read_is_sync=1    # (bool  , init-time) default = '1'      : Synchronous reporting of normal write-back cacheable-read external aborts
cluster0.ext_abort_normal_cacheable_read_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_normal_cacheable_read_ras_type=0   # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_normal_cacheable_write_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-back cacheable write external aborts
cluster0.ext_abort_normal_cacheable_write_is_sync=0   # (bool  , init-time) default = '0'      : Synchronous reporting of normal write-back cacheable write external aborts
cluster0.ext_abort_normal_cacheable_write_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_normal_cacheable_write_ras_type=0  # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_normal_noncacheable_prefetch_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_normal_noncacheable_prefetch_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_normal_noncacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal noncacheable-read external aborts
cluster0.ext_abort_normal_noncacheable_read_is_sync=1  # (bool  , init-time) default = '1'      : Synchronous reporting of normal noncacheable-read external aborts
cluster0.ext_abort_normal_noncacheable_read_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_normal_noncacheable_read_ras_type=0  # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_normal_noncacheable_write_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal noncacheable write external aborts
cluster0.ext_abort_normal_noncacheable_write_is_sync=0  # (bool  , init-time) default = '0'      : Synchronous reporting of normal noncacheable write external aborts
cluster0.ext_abort_normal_noncacheable_write_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_normal_noncacheable_write_ras_type=0  # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_normal_wt_cacheable_prefetch_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_normal_wt_cacheable_prefetch_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_normal_wt_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-through cacheable-read external aborts
cluster0.ext_abort_normal_wt_cacheable_read_is_sync=2  # (int   , init-time) default = '0x2'    : Synchronous reporting of normal write-through read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_normal_cacheable_read_is_sync.
cluster0.ext_abort_normal_wt_cacheable_read_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_read_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_normal_wt_cacheable_read_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_normal_wt_cacheable_write_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-through write external aborts
cluster0.ext_abort_normal_wt_cacheable_write_is_sync=2  # (int   , init-time) default = '0x2'    : Synchronous reporting of normal write-through write external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_normal_cacheable_write_is_sync.
cluster0.ext_abort_normal_wt_cacheable_write_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_write_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_normal_wt_cacheable_write_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_write_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_prefetch_device_GRE_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-GRE instruction fetches
cluster0.ext_abort_prefetch_device_GRE_read_is_sync=2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device-GRE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster0.ext_abort_prefetch_device_nGRE_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-nGRE instruction fetches
cluster0.ext_abort_prefetch_device_nGRE_read_is_sync=2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device-nGRE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster0.ext_abort_prefetch_device_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-nGnRE instruction fetches
cluster0.ext_abort_prefetch_device_read_is_sync=2     # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device-nGnRE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster0.ext_abort_prefetch_is_critical=0             # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by normal writeback cacheable instruction fetches
cluster0.ext_abort_prefetch_is_sync=1                 # (bool  , init-time) default = '1'      : Behaviour of external aborts generated by normal writeback cacheable instruction fetches.  0, asynchronous abort.  1, synchronous abort.
cluster0.ext_abort_prefetch_noncacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by normal noncacheable instruction fetches
cluster0.ext_abort_prefetch_noncacheable_read_is_sync=2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by normal noncacheable instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster0.ext_abort_prefetch_ras_index=0               # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_prefetch_ras_type=0                # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_prefetch_so_read_is_critical=0     # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-nGnRnE instruction fetches
cluster0.ext_abort_prefetch_so_read_is_sync=2         # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device=nGnRnE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster0.ext_abort_prefetch_wt_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by normal writethrough cacheable instruction fetches
cluster0.ext_abort_prefetch_wt_cacheable_read_is_sync=2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by normal writethrough cacheable instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster0.ext_abort_so_prefetch_ras_index=-1           # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_so_prefetch_ras_type=-1            # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_so_read_is_critical=0              # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRnE read external aborts
cluster0.ext_abort_so_read_is_sync=1                  # (bool  , init-time) default = '1'      : Synchronous reporting of device-nGnRnE read external aborts
cluster0.ext_abort_so_read_ras_index=0                # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_so_read_ras_type=0                 # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_so_write_is_critical=0             # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRnE write external aborts
cluster0.ext_abort_so_write_is_sync=1                 # (bool  , init-time) default = '1'      : Synchronous reporting of device-nGnRnE write external aborts
cluster0.ext_abort_so_write_ras_index=0               # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_so_write_ras_type=0                # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_ttw_cacheable_read_is_critical=0   # (bool  , init-time) default = '0'      : Critical reporting of TTW cacheable read external aborts
cluster0.ext_abort_ttw_cacheable_read_is_sync=1       # (bool  , init-time) default = '1'      : Synchronous reporting of TTW cacheable read external aborts
cluster0.ext_abort_ttw_cacheable_read_ras_index=0     # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_ttw_cacheable_read_ras_type=0      # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_ttw_noncacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of TTW noncacheable read external aborts
cluster0.ext_abort_ttw_noncacheable_read_is_sync=1    # (bool  , init-time) default = '1'      : Synchronous reporting of TTW noncacheable read external aborts
cluster0.ext_abort_ttw_noncacheable_read_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_ttw_noncacheable_read_ras_type=0   # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.ext_abort_ttw_wt_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of TTW write-through cacheable read external aborts
cluster0.ext_abort_ttw_wt_cacheable_read_is_sync=2    # (int   , init-time) default = '0x2'    : Synchronous reporting of TTW write-through cacheable read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_ttw_cacheable_read_is_sync.
cluster0.ext_abort_ttw_wt_cacheable_read_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_ttw_cacheable_read_ras_index, Valid indices in range [0, number_of_error_records).
cluster0.ext_abort_ttw_wt_cacheable_read_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_ttw_cacheable_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster0.external_oslar_access_disabled_by_authentication=0  # (bool  , init-time) default = '0'      : If true, external accesses to OSLAR, when external debugging is not enabled, will generate an error (FEAT_Debugv8p2).
cluster0.fault_on_misprogrammed_gpt_contig_region=0   # (bool  , init-time) default = '0'      : Whether GPF faults occur when GPT contiguous entries are misprogrammed.
cluster0.fault_on_nT_bit_set=1                        # (bool  , init-time) default = '1'      : Whether block translation table entries with the nT bit set should always fault. Only applies when changing_block_size_without_bbm_support_level is 1 or higher.
cluster0.fault_unalign_to_unsupported_access=8        # (int   , init-time) default = '0x8'    : If has_unaligned_single_copy_atomicity is true, whether unaligned A64 atomic, exclusive and acquire/release instructions to non iWB-oWB or the access crossing a 16-byte boundary generate fault. Bits 0,1,2,3 should be set accordingly to enable the fault behaviour. bit 0: atomic access should fault, bit 1: exclusive access should fault, bit 2: acquire/release should fault, bit 3: the access crossing a 16-byte boundary should fault
cluster0.fault_unaligned_s1_device_s2_fwb=0           # (bool  , init-time) default = '0'      : Whether unaligned access with stage1 Device memory and final memory attribute forced to normal by FWB can generate alignment fault
cluster0.force_align_pc=0                             # (bool  , init-time) default = '0'      : UNPREDICTABLE branch to non-word-aligned address in ARM state is forced to be aligned
cluster0.force_deterministic_irg_tag_generation=0     # (bool  , init-time) default = '0'      : Force the random tag generated by the IRG instruction when GCR_EL1.RRND=1 to equal RGSR_EL1.SEED[3:0] rather than a non-deterministic value
cluster0.force_mte_tag_access_razwi_and_ignore_tag_checks=0  # (bool  , init-time) default = '0'      : Force MTE tag accesses to RAZ/WI and also ignore tag checks irrespective of whether memory is tagged or not. This parameter doesn't affect non-load/store tag generation instructions like ADDG/GMI/IRG/SUBG. Please note that setting this parameter to true will also disable MTE tag access and tag check related traces
cluster0.force_wnr_read_unsupported_exclusive_or_atomic=0  # (bool  , init-time) default = '0'      : Whether ESR_ELx.WnR is forced to 0 for unsupported atomic and exclusives
cluster0.fpcr_short_vector_raz=0                      # (bool  , init-time) default = '0'      : FPSCR and FPCR fields LEN and STRIDE are hardwired to 0
cluster0.fsr_ext_bit_update_kind=3                    # (int   , init-time) default = '0x3'    : Set/Clear DFSR/IFSR EA bit on Synchronous/Async External Aborts. 0: Never Set, 1: Set on Synchronous Ext Aborts 2: Set on Asynchronous Ext Aborts 3: Set on both Sync and Async Ext Aborts. 
cluster0.gic.GICC-offset=0                            # (int   , init-time) default = '0x0'    : Offset from PERIPHBASE for GICC registers.
cluster0.gic.GICD-offset=262144                       # (int   , init-time) default = '0x40000' : Offset from PERIPHBASE for GICD registers. Will be ignored when GICv3 CPU interface is enabled, as distributor is then external to the cluster.
cluster0.gic.GICH-offset=65536                        # (int   , init-time) default = '0x10000' : Offset from PERIPHBASE for GICH registers.
cluster0.gic.GICH-other-CPU-offset=262144             # (int   , init-time) default = '0x40000' : Offset from PERIPHBASE for GICH registers for accessing other CPUs in the cluster. Set to 0 to disable.
cluster0.gic.GICV-alias=0                             # (int   , init-time) default = '0x0'    : Offset from PERIPHBASE for alias of GICV registers. When gicv2-only, if zero no alias will be created; if gicv2-only=0, the param is deprecated, when zero or unset an alias is created in the place mandated by the architecture (GICV-base+0xF000)
cluster0.gic.GICV-offset=192512                       # (int   , init-time) default = '0x2f000' : Offset from PERIPHBASE for GICV registers.
cluster0.gic.PERIPH-size=262144                       # (int   , init-time) default = '0x40000' : Size of registers based at PERIPHBASE that are considered to be owned by the GIC.  Any accesses in the range PERIPHBASE to PERIPHBASE+gic.PERIPH-size-1 that do not match GIC registers will be treated as RAZ/WI.
cluster0.gicv3.A3-affinity-supported=0                # (bool  , init-time) default = '0'      : Whether a non-zero value for affinity at level 3 is supported.
cluster0.gicv3.BPR-min=2                              # (int   , init-time) default = '0x2'    : The minimum value for the GICC_BPR register (non-secure version will be 1 + this value).
cluster0.gicv3.EOI-check-CPUID=0                      # (bool  , init-time) default = '0'      : Check CPU ID specified for accesses to EOI registers (rather than just ending highest priority active interrupt).
cluster0.gicv3.EOI-check-ID=0                         # (bool  , init-time) default = '0'      : Check Interrupt ID specified for accesses to EOI registers (rather than just ending highest priority active interrupt).
cluster0.gicv3.EOI-deactivate-any-interrupt=0         # (bool  , init-time) default = '0'      : Allow an EOI to deactivate interrupts that aren't the highest priority active interrupt (EOI-ignore-out-of-order must be false otherwise this is ignored).
cluster0.gicv3.EOI-ignore-out-of-order=1              # (bool  , init-time) default = '1'      : Ignore EOI writes that cannot end the highest priority active interrupt.
cluster0.gicv3.FIQEn-RAO=0                            # (bool  , init-time) default = '0'      : GICC_CTLR.FIQEn is read as one, write insensitive
cluster0.gicv3.IIDR_base=1083                         # (int   , init-time) default = '0x43b'  : The base value for calculating the GICC_IIDR register value.
cluster0.gicv3.LR-count=16                            # (int   , init-time) default = '0x10'   : The number of implemented list registers.
cluster0.gicv3.PMHE-RAO-WI=0                          # (bool  , init-time) default = '0'      : ICC_CTLR_EL*.PHME is read as one, write insensitive
cluster0.gicv3.PMHE-RAZ-WI=0                          # (bool  , init-time) default = '0'      : ICC_CTLR_EL*.PHME is read as zero, write insensitive
cluster0.gicv3.PMHE-release-set-packet=0              # (bool  , init-time) default = '0'      : if PHME is enabled, whether a SET packet is released by CPU Intf in Upstream Ack window.
cluster0.gicv3.SRE-EL2-enable-RAO=0                   # (bool  , init-time) default = '0'      : When ICC_SRE_EL2.SRE is RAO/WI, makes ICC_SRE_EL2.Enable RAO/WI
cluster0.gicv3.SRE-EL3-enable-RAO=0                   # (bool  , init-time) default = '0'      : When ICC_SRE_EL3.SRE is RAO/WI, makes ICC_SRE_EL3.Enable RAO/WI
cluster0.gicv3.SRE-EL3-set-once=0                     # (bool  , init-time) default = '0'      : Restrict SRE EL3 to be set only once
cluster0.gicv3.SRE-enable-action-on-mmap=0            # (int   , init-time) default = '0x0'    : Allowed values are: 0-SRE one allows mmap access. 1-SRE one disables mmap access. 2-SRE one makes mmap access RAZ-WI.
cluster0.gicv3.STATUSR-implemented=1                  # (bool  , init-time) default = '1'      : If GICv3 CPU interface is being used, this determines whether the STATUS registers are implemented
cluster0.gicv3.VBPR-min=2                             # (int   , init-time) default = '0x2'    : The minimum value for the GICV_BPR register (non-secure version will be 1 + this value).
cluster0.gicv3.VFIQEn-RAO=0                           # (bool  , init-time) default = '0'      : ICH_VMCR_EL2.VFIQEn is read as one, write insensitive
cluster0.gicv3.cpuintf-mmap-access-level=0            # (int   , init-time) default = '0x0'    : Allowed values are: 0-mmap access is supported for GICC,GICH,GICV registers. 1-mmap access is supported only for GICV registers. 2-mmap access is not supported.
cluster0.gicv3.dir-trap-support=1                     # (bool  , init-time) default = '1'      : The cpu supports separate trapping of ICC_DIR_EL1 to EL2
cluster0.gicv3.el3_trap_priority_when_secure_debug_disabled=0  # (bool  , init-time) default = '0'      : Undef to access priorities group register when secure debug is disabled
cluster0.gicv3.extended-interrupt-range-support=0     # (bool  , init-time) default = '0'      : Device has support for extended SPI/PPI ID ranges
cluster0.gicv3.idle-is-ff=1                           # (bool  , init-time) default = '1'      : For GICC/GICV RPR, when idle, return FF when true, minimum supported priority otherwise
cluster0.gicv3.ignore-DIR-write-when-EOImode-not-set=1  # (bool  , init-time) default = '1'      : Ignore UNPREDICTABLE access to GICC_DIR register.
cluster0.gicv3.interrupt-bypass-support=1             # (bool  , init-time) default = '1'      : Interrupt bypass support, set to false for devices not supporting interrupt bypass
cluster0.gicv3.local-SEIs=0                           # (bool  , init-time) default = '0'      : Generate SEI to signal internal issues
cluster0.gicv3.local-VSEIs=0                          # (bool  , init-time) default = '0'      : Generate VSEI to signal internal issues
cluster0.gicv3.physical-ID-bits=16                    # (int   , init-time) default = '0x10'   : Number of physical ID bits implemented.
cluster0.gicv3.priority-bits=5                        # (int   , init-time) default = '0x5'    : Number of priority bits implemented.
cluster0.gicv3.send-PMHE-command-only-when-priority-changes=0  # (bool  , init-time) default = '0'      : Send PMHE upstream command to distributor only when write to ICC_PMR_EL1 changes the priority
cluster0.gicv3.sgi-range-selector-support=0           # (bool  , init-time) default = '0'      : Device has support for the Range Selector feature for SGI
cluster0.gicv3.suppress-virtual-enables-comms=1       # (bool  , init-time) default = '1'      : In GICv3 only mode, prevents the GIC CPUIF from communicating UpstreamWrite/VirtualEnables to the IRI
cluster0.gicv3.virtual-ID-bits=16                     # (int   , init-time) default = '0x10'   : Number of virtual ID bits implemented.
cluster0.gicv3.virtual-lpi-support=1                  # (bool  , init-time) default = '1'      : When GICv3 is supported, indicates a cut down CPUIF interface with no support of VLPI (GICv3 only) when false
cluster0.gicv3.virtual-priority-bits=5                # (int   , init-time) default = '0x5'    : Number of virtual priority bits implemented.
cluster0.gicv3.without-DS-support=0                   # (bool  , init-time) default = '0'      : GICv3 CPU interfaces do not support disabling security in the distributor (GICD_CTLR.DS=1)
cluster0.gicv4.mask-virtual-interrupt=0               # (bool  , init-time) default = '0'      : If true, virtual interrupts can be masked from being reported to virtual CPU interface by setting ICH_HCR_EL2.DVIM 1. No control otherwise.
cluster0.global_debug_rom.ROMDEVID=0                  # (int   , init-time) default = '0x0'    : Value of Debug Rom Device Identification Register
cluster0.global_debug_rom.ROMPIDR=17180635136         # (int   , init-time) default = '0x4000bb000' : Value of Debug Rom Peripheral Identification Register
cluster0.global_debug_rom.ROMPRIDR0=1                 # (int   , init-time) default = '0x1'    : Value of Debug ROM Power RequestID Register
cluster0.gpccr_el3_gpcp_behaviour=2                   # (int   , init-time) default = '0x2'    : Used to control impdef behaviour when GPCP=1 (0->Faults are always generated and reported, 1->Faults are not generated and reported), 2->Faults are generated and reported only for Arm recommended cases
cluster0.gpt_tlb_size=0                               # (int   , init-time) default = '0x0'    : Number of separate GPT TLB entries.
cluster0.gpt_walkcache_size=0                         # (int   , init-time) default = '0x0'    : Number of GPT walk cache entries.
cluster0.hardware_translation_table_update_implemented=1  # (int   , init-time) default = '0x1'    : Implement hardware translation table updates from ARMv8.1 (FEAT_HAFDBS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.1 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_128_bit_atomic_instructions=0            # (int   , init-time) default = '0x0'    : Implement 128-bit Atomic Instructions (FEAT_LSE128)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_128_bit_tt_descriptors=0                 # (int   , init-time) default = '0x0'    : Implement 128-bit Translation Table Descriptors (FEAT_D128)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_16bit_asids=1                            # (bool  , init-time) default = '1'      : Enable 16-bit ASIDs.
cluster0.has_16bit_vmids=1                            # (int   , init-time) default = '0x1'    : Implement support for 16-bit VMIDs from ARMv8.1 (FEAT_VMID16).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.1 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_16k_granule=0                            # (bool  , init-time) default = '0'      : Implement the 16k LPAE translation granule.
cluster0.has_4k_granule=1                             # (bool  , init-time) default = '1'      : Implement the 4k LPAE translation granule.
cluster0.has_52bit_address_with_16k=0                 # (int   , init-time) default = '0x0'    : Implements Armv8.7 52-bit IPA/PA support for 16k (FEAT_LPA2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_52bit_address_with_4k=0                  # (int   , init-time) default = '0x0'    : Implements Armv8.7 52-bit IPA/PA support for 4k (FEAT_LPA2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_56_bit_va=0                              # (int   , init-time) default = '0x0'    : 56-bit Physical Address, identified as (FEAT_LVA3)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_64bit_pmu_ext_access=0                   # (int   , init-time) default = '0x0'    : Implement 64-bit pmu external interface access
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_64k_granule=1                            # (bool  , init-time) default = '1'      : Implement the 64k LPAE translation granule.
cluster0.has_aarch32_dbgdidr_etc=1                    # (bool  , init-time) default = '1'      : DBGDIDR, DBGDRAR, DBGDSAR exist even if EL1 doesn't implement AArch32
cluster0.has_aarch32_hpd=0                            # (bool  , init-time) default = '0'      : If true then hierarchical permission disable is supported in AArch32 (FEAT_AA32HPD)
cluster0.has_aarch64=1                                # (bool  , init-time) default = '1'      : All implemented exception levels can run in AArch64
cluster0.has_actlr2=0                                 # (bool  , init-time) default = '0'      : If true ACLTR2 exists and ACTLR2(NS) is aliased to ACTLR_EL1[63:32]
cluster0.has_address_breakpoint_linking=0             # (int   , init-time) default = '0x0'    : Implement Address Breakpoint Linking Extension (FEAT_ABLE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_amu=0                                    # (int   , init-time) default = '0x0'    : Implement activity monitor functionality from ARMv8.4 (FEAT_AMUv1).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_amu_ext64=0                              # (int   , init-time) default = '0x0'    : Implement 64-bit external interface to the Activity Monitors (FEAT_AMU_EXT64).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_arm_v8-1=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.1 Extension.
cluster0.has_arm_v8-2=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.2 Extension.
cluster0.has_arm_v8-3=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.3 Extension.
cluster0.has_arm_v8-4=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.4 Extension.
cluster0.has_arm_v8-5=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.5 Extension.
cluster0.has_arm_v8-6=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.6 Extension.
cluster0.has_arm_v8-7=0                               # (bool  , init-time) default = '0'      : Implement the Armv8.7 Extension.
cluster0.has_arm_v8-8=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.8 Extension.
cluster0.has_arm_v8-9=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.9 Extension. This feature is incomplete and under development.
cluster0.has_arm_v9-0=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.0 Extension.
cluster0.has_arm_v9-1=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.1 Extension.
cluster0.has_arm_v9-2=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.2 Extension.
cluster0.has_arm_v9-3=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.3 Extension.
cluster0.has_arm_v9-4=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.4 Extension.
cluster0.has_at_with_pan=1                            # (int   , init-time) default = '0x1'    : Implement new AT instructions with PAN support (FEAT_PAN2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_attribute_index_enhancement=0            # (int   , init-time) default = '0x0'    : Memory Attribute Index Enhancement (FEAT_AIE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_axflag_xaflag=1                          # (int   , init-time) default = '0x1'    : Implement flag manipulation instructions (AXFlag, XAFlag) from ARMv8.5 (FEAT_FlagM2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_axflag_xaflag_frint=1                    # (int   , init-time) default = '0x1'    : Implement flag manipulation instructions (AXFlag, XAFlag) and floating-point rounding to int instructions (FRINT[32|64][X|Z]) from ARMv8.5. If this parameter is enabled, it also enables both has_axflag_xaflag and has_frint. If support for only one of the features is needed, please use the individual parameters and do not enable this one (FEAT_FlagM2, FEAT_FRINTTS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_bc=1                                     # (int   , init-time) default = '0x1'    : Implement Armv8.8 Hinted Conditional Branch (FEAT_HBC)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_branch_target_exception=0                # (int   , init-time) default = '0x0'    : Implement Branch target identification mechanism from ARMv8.5 (FEAT_BTI).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_brbe=0                                   # (bool  , init-time) default = '0'      : If true, implements branch record buffer extension (FEAT_BRBE).
cluster0.has_brbe_v1p1=0                              # (bool  , init-time) default = '0'      : If true, implements FEAT_BRBEv1p1.
cluster0.has_ccidx=0                                  # (bool  , init-time) default = '0'      : Implement the ARMv8.3 CCSIDR Extension. Extending the ccsidr number of sets.
cluster0.has_cfinv_rmif_setf=1                        # (int   , init-time) default = '0x1'    : Implement flag manipulation (CFINV, RMIF, SETF8, SETF16) instructions from ARMv8.4 (FEAT_FlagM).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_clear_bhb=1                              # (int   , init-time) default = '0x1'    : Implement Clear Branch History information instruction (FEAT_CLRBHB).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_clear_other_speculation_by_context=1     # (int   , init-time) default = '0x1'    : Implement execution and data prediction invalidation from Armv8.9 (FEAT_SPECRES2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_cmo_wr_control=1                         # (int   , init-time) default = '0x1'    : Whether stage1/2 CMO write perm control is supported (FEAT_CMOW)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_coherent_icache=0                        # (bool  , init-time) default = '0'      : Whether icache invalidation to the point of unification is required for instruction to data coherence. true - Invalidate operations not required
cluster0.has_common_not_private_translations=1        # (int   , init-time) default = '0x1'    : Implement the TTBRn_ELx.CnP (Common not Private) controls from ARMv8.2 (FEAT_TTCNP).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_complex_number=1                         # (int   , init-time) default = '0x1'    : Implement ARMv8.3 complex number support, Multiply Accumulate and Add instructions (FEAT_FCMA).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_const_pac=0                              # (int   , init-time) default = '0x0'    : Feature for singular selection of PAC field (FEAT_CONSTPACFIELD).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_cssc=1                                   # (int   , init-time) default = '0x1'    : Support for common short sequence compression instructions (FEAT_CSSC)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_cvadp_support=0                          # (int   , init-time) default = '0x0'    : Implement instruction to support cache clean by deep persistence (DC CVADP) from ARMv8.5, can be selected for core implemented on any arch version starting ARMv8.2 (FEAT_DPB, FEAT_DPB2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_data_alignment_flag=0                    # (int   , init-time) default = '0x0'    : Implement non-optimal misalignment flag for PMU/SPE from ARMv8.5
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_debug_rom=1                              # (bool  , init-time) default = '1'      : If true, a debug ROM will be generated describing the cluster's debug components.
cluster0.has_delayed_ctireg=0                         # (bool  , init-time) default = '0'      : Delay the functional effect of CTI register writes until ISB or implicit barrier.
cluster0.has_delayed_dbgreg=0                         # (bool  , init-time) default = '0'      : Delay the functional effect of external debug register writes until ISB or implicit barrier.
cluster0.has_delayed_mdscr_el1=0                      # (bool  , init-time) default = '0'      : Delay the functional effect of MDSCR_EL1 register writes until ISB or implicit barrier.
cluster0.has_delayed_oslar_el1=0                      # (bool  , init-time) default = '0'      : Delay the functional effect of OSLAR_EL1 register writes until ISB or implicit barrier.
cluster0.has_delayed_pmureg=0                         # (bool  , init-time) default = '0'      : Delay the functional effect of PMU register writes until ISB or implicit barrier.
cluster0.has_delayed_sysreg=0                         # (bool  , init-time) default = '0'      : Delay the functional effect of system register writes until ISB or implicit barrier.
cluster0.has_delayed_wfe_trap=0                       # (int   , init-time) default = '0x0'    : Implements Configurable Delayed WFE trapping from ARMv8.6 (FEAT_TWED).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_dgh=1                                    # (int   , init-time) default = '0x1'    : Implements Data Gathering Hint instruction from ARMv8.6 (FEAT_DGH).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_dot_product=1                            # (int   , init-time) default = '0x1'    : Implement the dot product (UDOT, SDOT) instructions from ARMv8.4 (FEAT_DotProd).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_e0pd=1                                   # (int   , init-time) default = '0x1'    : Implement ARMv8.5 feature to prevent unprivileged access to one half of the memory (FEAT_E0PD).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ebf16=0                                  # (int   , init-time) default = '0x0'    : Support for Extended BFloat16 Behaviours (FEAT_EBF16)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ecbhb=1                                  # (int   , init-time) default = '0x1'    : Implement Exploitative Control using Branch History information between exception levels (FEAT_ECBHB).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_edacr=1                                  # (bool  , init-time) default = '1'      : Implement EDACR register
cluster0.has_el2=1                                    # (bool  , init-time) default = '1'      : Implements EL2
cluster0.has_el3=1                                    # (bool  , init-time) default = '1'      : Implements EL3
cluster0.has_enhanced_pac=0                           # (bool  , init-time) default = '0'      : If pointer authentication is enabled then implement enhanced PAC.
cluster0.has_enhanced_pan=1                           # (int   , init-time) default = '0x1'    : Implements Armv8.7 Enhanced PAN feature (FEAT_PAN3)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ete=0                                    # (bool  , init-time) default = '0'      : If true, implements the Embedded Trace Extension (FEAT_ETE). This option is discarded if ete plugin is explicitly loaded (--plugin or -P)
cluster0.has_ets=0                                    # (bool  , init-time) default = '0'      : Whether Enhanced Translation Synchronization is supported (FEAT_ETS).
cluster0.has_exception_trapping_form_of_vector_catch=1  # (bool  , init-time) default = '1'      : Implement the exception trapping form of vector catch debug event.
cluster0.has_extended_recp_estimate=0                 # (int   , init-time) default = '0x0'    : Implements increased precision of reciprocal instructions (FEAT_RPRES).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_external_rndr=0                          # (int   , init-time) default = '0x0'    : Implement external random number generator module. When enabling this with has_rndr enabled, the external random number generator will be used instead of internal random number generator
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_far_not_valid=0                          # (bool  , init-time) default = '0'      : Implements FnV bit in ESR_ELx and xFSR, FAR not valid for synchronous external aborts.
cluster0.has_far_not_valid_dfsc=0                     # (bool  , init-time) default = '0'      : Implements FnV bit in ESR_ELx, FAR not valid for synchronous external aborts for Data Abort.
cluster0.has_far_not_valid_ifsc=0                     # (bool  , init-time) default = '0'      : Implements FnV bit in ESR_ELx and xFSR, FAR not valid for synchronous external aborts for Instruction Abort.
cluster0.has_fgt=1                                    # (int   , init-time) default = '0x1'    : Implements Fine-grained Virtualization Traps extension from ARMv8.6 (FEAT_FGT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_fgt2=1                                   # (int   , init-time) default = '0x1'    : Implement additional FGT traps introduced in ARMv8.9 (FEAT_FGT2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_fixed_function_instr_counter=0           # (int   , init-time) default = '0x0'    : Implement fixed-function instruction counter (FEAT_PMUv3_ICNTR)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_fp16=1                                   # (int   , init-time) default = '0x1'    : Implement the half-precision floating-point data processing instructions from ARMv8.2 (FEAT_FP16).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_fp16_fmlal=1                             # (int   , init-time) default = '0x1'    : Implement the New Floating Point Multiplication Variant (FP16 FMLAL, FMLSL) instructions from ARMv8.4. Only supported if has_fp16=0x1 (FEAT_FHM).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_frint=1                                  # (int   , init-time) default = '0x1'    : Implement floating-point rounding to int instructions (FRINT[32|64][X|Z]) from ARMv8.5 (FEAT_FRINTTS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_gcs=0                                    # (int   , init-time) default = '0x0'    : Implement Guarded Control Stack Extension from ARMv9.4 (FEAT_GCS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_generic_authentication=1                 # (int   , init-time) default = '0x1'    : Implement ARMv8.3 generic authentication.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_guest_translation_granule=1              # (int   , init-time) default = '0x1'    : Implement mechanism for guest translation granule identification from ARMv8.5, ID values determined by stage1 granule configuration parameters (FEAT_GTG).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_haft=0                                   # (int   , init-time) default = '0x0'    : Implement Hardware managed Access Flag for Table Descriptors (FEAT_HAFT)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_hardware_translation_table_update=2      # (int   , init-time) default = '0x2'    : Type of hardware translation table supported (when enabled by hardware_translation_table_update_implemented).  0, not implemented. 1, access bit updates implemented. 2, access bit updates and dirty bit mechanism implemented (FEAT_HAFDBS).
cluster0.has_hcrx_el2=1                               # (int   , init-time) default = '0x1'    : Implements new HCRX_EL2 id register from Armv8.7 (FEAT_HCX).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_hpmn0=0                                  # (int   , init-time) default = '0x0'    : Allow hypervisor to set MDCR_EL2.HPMN to 0 (FEAT_HPMN0)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_id_reg_read=1                            # (int   , init-time) default = '0x1'    : Implement read access to the ID registers  (ESR_ELx.EC=0x18) (FEAT_IDST)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_iesb=1                                   # (int   , init-time) default = '0x1'    : Implement support for implicit error sync event from ARMv8.2 (FEAT_IESB).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_itd=1                                    # (bool  , init-time) default = '1'      : Implement the optional IT disable feature.
cluster0.has_ite=0                                    # (int   , init-time) default = '0x0'    : Implement Instrumentation Trace Extension from ARMv9.4 (FEAT_ITE).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_jscvt=1                                  # (int   , init-time) default = '0x1'    : Implement ARMv8.3 javascript Floating-point to Integer conversion instruction (FEAT_JSCVT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_large_system_ext=0                       # (bool  , init-time) default = '0'      : Implement the ARMv8 Large System Extensions (FEAT_LSE).
cluster0.has_large_va=0                               # (int   , init-time) default = '0x0'    : Implement support for the extended 52-bit virtual addresses from ARMv8.2 (FEAT_LVA).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ldapur_stlur=1                           # (int   , init-time) default = '0x1'    : Implement support for LDAPR and STLR instructions with immediate offsets from ARMv8.4 (FEAT_LRCPC2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ldm_stm_ordering_control=0               # (int   , init-time) default = '0x0'    : Implement the SCTLR_ELx.LSMAOE (Load/Store Multiple Atomicity and Ordering Enable) and SCTLR_ELx,nTLSMD (no Trap Load/Store Multiple to Device) controls from ARMv8.2 (FEAT_LSMAOC).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_lrcpc=0                                  # (bool  , init-time) default = '0'      : If true then it support the RCpc feature from ARMv8.3 (FEAT_LRCPC).
cluster0.has_lrcpc3=0                                 # (int   , init-time) default = '0x0'    : Implement Release Consistency processor consistent (RCpc) feature from Armv8.9 (FEAT_LRCPC3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_mops_option=0                            # (int   , init-time) default = '0x0'    : Implement Armv8.8 standard instructions for memory operations (FEAT_MOPS). 0, not implemented (unsupported if Armv8.8 is enabled). 1, implemented using Option A. 2, implemented using Option B
cluster0.has_mpam=0                                   # (int   , init-time) default = '0x0'    : Implement ARMv8.4 MPAM Registers and associated functionality (FEAT_MPAM).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_mpmm=0                                   # (bool  , init-time) default = '0'      : Implement max-power mitigation mechanism (MPMM)
cluster0.has_mt_pmu_disable_feature=0                 # (int   , init-time) default = '0x0'    : Implements Multi-threading PMU disable extension from ARMv8.6 (FEAT_MTPMU). 0: FEAT_MTPMU is disabled, 1: FEAT_MTPMU is enabled if ARMv8.6 is implemented, 2: FEAT_MTPMU is cherry-picked, 0xF: The feature is disabled and is represented by value 0xF in ID_AA64DFR0_EL1.MTPMU.
cluster0.has_mte_async_faults=1                       # (bool  , init-time) default = '1'      : Whether MTE asynchronous faults are supported (FEAT_MTE_ASYNC)
cluster0.has_mte_ctrl_bits_stateful=0                 # (bool  , init-time) default = '0'      : if memory_tagging_support_level == 1, Whether mte specific control bits in system registers are stateful
cluster0.has_mte_perm=0                               # (bool  , init-time) default = '0'      : Implement tag access permission (FEAT_MTE_PERM)
cluster0.has_nested_virtualization=1                  # (int   , init-time) default = '0x1'    : Implement ARMv8.3 nested virtualization (FEAT_NV).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_nmi=1                                    # (int   , init-time) default = '0x1'    : Implement AARCH64 Non-Maskable Interrupts (FEAT_NMI)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_no_os_double_lock=0                      # (int   , init-time) default = '0x0'    : Do not implement the OS double-lock (FEAT_DoubleLock).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_non_context_synchronizing_exception_controls=1  # (int   , init-time) default = '0x1'    : Implement cosmetic controls for whether exception entry and exit are context synchronizing events (SCTLR_ELx.{EIS,EOS}) from ARMv8.5 (FEAT_ExS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_par_bit10_razwi=0                        # (bool  , init-time) default = '0'      : Whether PAR_EL1[10] is RAZ/WI
cluster0.has_partial_delayed_mdscr_el1=0              # (bool  , init-time) default = '0'      : has_delayed_oslar_el1 only apply to some bits of MDSCR_EL1 (MDE, KDE, TDCC, SS).
cluster0.has_pc_sample_based_profiling=1              # (bool  , init-time) default = '1'      : If true, pc sample-based profiling is enabled (FEAT_PCSRv8, FEAT_PCSRv8p2).
cluster0.has_pc_sample_profiling_enable=0             # (bool  , init-time) default = '0'      : Whether PC Sample profiling enable is implemented (FEAT_PCSRv8p9)
cluster0.has_per_cluster_debug_auth_ports=0           # (bool  , init-time) default = '0'      : If true then the debug authentication ports i.e. spniden, niden, rpliden, rtpiden, dbgen, spiden are available per cluster
cluster0.has_permission_indirection_s1=0              # (int   , init-time) default = '0x0'    : Implement the Permission Indirection Extension at stage 1 (FEAT_S1PIE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_permission_indirection_s2=0              # (int   , init-time) default = '0x0'    : Implement the Permission Indirection Extension at stage 2 (FEAT_S2PIE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_permission_overlay_s1=0                  # (int   , init-time) default = '0x0'    : Implement the Permission Overlay Extension at stage 1 (FEAT_S1POE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_permission_overlay_s2=0                  # (int   , init-time) default = '0x0'    : Implement the Permission Overlay Extension at stage 2 (FEAT_S2POE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_pmss=0                                   # (int   , init-time) default = '0x0'    : Implement PMU Snapshot Extension from Armv8.9 (FEAT_PMUv3_SS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_pmu=1                                    # (int   , init-time) default = '0x1'    : Implement the optional Performance Monitors Extension (FEAT_PMUv3). 0, Not Implemented. 1, Implemented. 2, PMU is IMPLEMENTATION_DEFINED, PMU version would be set to 0xF and would behave as if no PMU is implemented
cluster0.has_pmu_edge_detection=0                     # (int   , init-time) default = '0x0'    : Implement PMU Event edge detection (FEAT_PMUv3_EDGE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_pointer_authentication=1                 # (int   , init-time) default = '0x1'    : Implement ARMv8.3 pointer authentication (FEAT_PAuth).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_prediction_invalidation_instructions=1   # (int   , init-time) default = '0x1'    : Implement execution and data prediction invalidation from ARMv8.5 (FEAT_SPECRES).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_pstate_dit=1                             # (int   , init-time) default = '0x1'    : Implement timing insensitivity of data processing instructions from ARMv8.4 (FEAT_DIT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_pstate_pan=1                             # (int   , init-time) default = '0x1'    : Implement the PSTATE.PAN (Privileged Access Never) control from ARMv8.1 (FEAT_PAN)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.1 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_pstate_uao=1                             # (int   , init-time) default = '0x1'    : Implement the PSTATE.UAO (User Access Override) control from ARMv8.2 (FEAT_UAO).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_qarma3_pac=0                             # (bool  , init-time) default = '0'      : Supports QARMA3 pointer authentication algorithm (FEAT_PACQARMA3)
cluster0.has_ras=0                                    # (int   , init-time) default = '0x0'    : Implements the ARMv8 RAS Extension. 0 = NO_RAS, 1 = MINIMAL_RAS, 2 = FULL_RAS (FEAT_RAS)
cluster0.has_ras_aderr=0                              # (int   , init-time) default = '0x0'    : Implement RAS Asynchronous Device Read Error from Armv8.9 (FEAT_ADERR).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ras_anerr=0                              # (int   , init-time) default = '0x0'    : Implement RAS Asynchronous Normal Read Error from Armv8.9 (FEAT_ANERR).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ras_armv84_extension=1                   # (int   , init-time) default = '0x1'    : Implement ARMv8.4 RAS Extension (FEAT_RASv1p1).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ras_armv89_double_fault=0                # (int   , init-time) default = '0x0'    : Implement RAS Double Fault Extension from Armv8.9 (FEAT_DoubleFault2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ras_armv89_extension=0                   # (int   , init-time) default = '0x0'    : Implement RAS extension from Armv8.9 (FEAT_RASv2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ras_critical_error=0                     # (int   , init-time) default = '0x0'    : [DEPRECATED: Set CI field on first register in error_record_feature_register JSON instead] ARMv8.4 AArch64 RAS Critical Error is implemented or not. 0 - Feature Not Supported, 1 - Feature always enabled, 2 - Feature is controllable.
cluster0.has_ras_double_fault=1                       # (int   , init-time) default = '0x1'    : Implement ARMv8.4 RAS Double Fault Extension (FEAT_DoubleFault).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ras_fault_injection=0                    # (int   , init-time) default = '0x0'    : [DEPRECATED: Set INJ field on first register in error_record_feature_register JSON instead] Implement ARMv8.4 Standard Fault Injection mechanism.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ras_pfar=0                               # (int   , init-time) default = '0x0'    : Implement RAS Physical Fault Address Registers from Armv8.9 (FEAT_PFAR).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ras_rpz=0                                # (int   , init-time) default = '0x0'    : Implement RAS Remove Poison and Zero from Armv8.9 (FEAT_RPZ).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_ras_timestamp=0                          # (int   , init-time) default = '0x0'    : [DEPRECATED: Set TS field on first register in error_record_feature_register JSON instead] ARMv8.4 AArch64 RAS Timestamp register is implemented or not. 0 - No Timestamp is recorded, 1 - Generic Timer timestamp is recorded, 2 - IMP DEF timestamp is recorded.
cluster0.has_restriction_on_speculative_data_loaded=1  # (int   , init-time) default = '0x1'    : Implements the ARMv8.5 security feature (Restrictions on the effects of speculation) (FEAT_CSV3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_rme=0                                    # (bool  , init-time) default = '0'      : If true, implements full realm management extension (FEAT_RME). Note: This parameter is deprecated and will be removed in future releases, please use rme_support_level parameter.
cluster0.has_rndr=0                                   # (int   , init-time) default = '0x0'    : Implement random number instructions to read from RNDR and RNDRSS random number registers from ARMv8.5 (FEAT_RNG).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_rndr_trap=0                              # (int   , init-time) default = '0x0'    : Implement trapping for RNDR and RNDRSS random number registers from ARMv8.8. (FEAT_RNG_TRAP)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_rounding_doubling_multiply_add_subtract=1  # (int   , init-time) default = '0x1'    : Implement the rounding doubling multiply add and subtract instructions from ARMv8.1 (FEAT_RDM).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.1 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_rprfm=0                                  # (bool  , init-time) default = '0'      : Support for RPRFM hint instruction (FEAT_RPRFM)
cluster0.has_sctlr2=0                                 # (int   , init-time) default = '0x0'    : Implement SCTLR2_ELx registers (FEAT_SCTLR2)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_sebep=0                                  # (int   , init-time) default = '0x0'    : Implement Synchronous-Exception-Based Event Profiling from ARMv9.4 (FEAT_SEBEP).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_secure_el2=1                             # (int   , init-time) default = '0x1'    : Implement support for Secure EL2 (FEAT_SEL2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_self_hosted_trace_extension=1            # (int   , init-time) default = '0x1'    : Implement support for the Self-hosted Trace Extensions from ARMv8.4 (FEAT_TRF).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_slc_hint=0                               # (int   , init-time) default = '0x0'    : Implement System Cache Location Hint (FEAT_SLCHINT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_small_page_table=1                       # (int   , init-time) default = '0x1'    : Implement small page table support which increases the maximum value of TxSZ field from ARMv8.4 (FEAT_TTST). Note: will be unimplemented only if both has_small_page_table=0x0 and has_secure_el2=0x0.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_software_lock=1                          # (bool  , init-time) default = '1'      : Implement software lock in memory-mapped CTI, PMU, and external debug interfaces
cluster0.has_spe_fds=1                                # (int   , init-time) default = '0x1'    : Implement SPE filter by data source from ARMv8.9 (FEAT_SPE_FDS)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_speculation_barrier_inst=1               # (int   , init-time) default = '0x1'    : Implement speculation barrier instruction (SB) from ARMv8.5 (FEAT_SB).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_speculative_sei=0                        # (bool  , init-time) default = '0'      : If true, the PE can generate SError interrupt exceptions from speculative reads of memory, including speculative instruction fetches
cluster0.has_spmu=0                                   # (int   , init-time) default = '0x0'    : Implement System PMU Extension from Armv8.9 (FEAT_SPMU).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_stage2_ap_speculative_update=0           # (bool  , init-time) default = '0'      : If true, stage1 TTW can speculatively update stage2 AP bit
cluster0.has_stage2_fwb=1                             # (int   , init-time) default = '0x1'    : Implement HCR_EL2.FWB, stage 2 control of memory types and cacheability (FEAT_S2FWB)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_stage2_xnx=1                             # (int   , init-time) default = '0x1'    : Implement the extended XN[1:0] stage 2 control from ARMv8.2 (FEAT_XNX).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_stage2_xnx_in_aarch32=1                  # (bool  , init-time) default = '1'      : Implement the extended XN[1:0] stage 2 control from ARMv8.2 for Aarch32 (FEAT_XNX).
cluster0.has_statistical_profiling=1                  # (bool  , init-time) default = '1'      : Whether Statistical Based Profiling is implemented (FEAT_SPE).
cluster0.has_supersections=1                          # (bool  , init-time) default = '1'      : Whether VMSAv8-32 supersection to support more than 32-bit PA using short descriptor is implemented.
cluster0.has_synchronous_load_atomics=1               # (bool  , init-time) default = '1'      : Report asynchronous abort due to unsupported load atomics as synchronous (Cacheable)
cluster0.has_synchronous_load_atomics_noncacheable=1  # (bool  , init-time) default = '1'      : Report asynchronous abort due to unsupported load atomics as synchronous (Non-Cacheable)
cluster0.has_synchronous_store_atomics=0              # (bool  , init-time) default = '0'      : Report asynchronous abort due to unsupported store atomics as synchronous (Cacheable)
cluster0.has_synchronous_store_atomics_noncacheable=0  # (bool  , init-time) default = '0'      : Report asynchronous abort due to unsupported store atomics as synchronous (Non-Cacheable)
cluster0.has_sysinstr128=0                            # (int   , init-time) default = '0x0'    : Support for System Instructions that can take 128-bit inputs (FEAT_SYSINSTR128)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_sysreg128=0                              # (int   , init-time) default = '0x0'    : Support for 128-bit System Registers (FEAT_SYSREG128)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_tcr2=0                                   # (int   , init-time) default = '0x0'    : Implement TCR2_ELx registers (FEAT_TCR2)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_tidcp1=1                                 # (int   , init-time) default = '0x1'    : Implement Armv8.8 EL0 use of implementation defined functionality (FEAT_TIDCP1)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_tlb_conflict_abort=0                     # (bool  , init-time) default = '0'      : Detected inconsistent TLB content generate aborts.
cluster0.has_tlb_pa_caching=0                         # (bool  , init-time) default = '0'      : Whether intermediate caching of translation table walks might include NonCoherent caches of previous valid walks. 0, NonCoherent caches might be included. 1, No NonCoherent caches included (FEAT_nTLBPA)
cluster0.has_tlbi_range=1                             # (int   , init-time) default = '0x1'    : Implement support for TLB Range Maintenance instructions (TLBI RVAE1, etc) from ARMv8.4 (FEAT_TLBIRANGE).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_tlbi_to_outer_shareable=1                # (int   , init-time) default = '0x1'    : Implement support for TLB Maintenance instructions that extend to the Outer Shareable domain (TLBI VAE1OS, etc) from ARMv8.4 (FEAT_TLBIOS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_tlbi_ttl=1                               # (int   , init-time) default = '0x1'    : Implement support for the TTL level hint in by-address TLB Maintenance instructions from ARMv8.4 (FEAT_TTL).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_tme=0                                    # (bool  , init-time) default = '0'      : If true, implements TME, the Transactional Memory Extension (FEAT_TME).
cluster0.has_translation_hardening=0                  # (int   , init-time) default = '0x0'    : Implement the Translation Hardening Extension (FEAT_THE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_trbe=0                                   # (bool  , init-time) default = '0'      : If true, implements the Trace Buffer Extension (FEAT_TRBE).
cluster0.has_trbe_ext=0                               # (int   , init-time) default = '0x0'    : Implements the Trace Buffer external mode extension (FEAT_TRBE_EXT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_unaligned_single_copy_atomicity=1        # (int   , init-time) default = '0x1'    : Implement support for SCTLR_ELx.nAA from ARMv8.4, and A64 atomic, exclusive and acquire/release instructions accessing unaligned bytes inside a 16byte window will not generate alignment fault (FEAT_LSE2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_unsupported_exclusive_fault=1            # (bool  , init-time) default = '1'      : Report unsupported exclusive access with Unsupported Exclusive fault status (otherwise use external abort)
cluster0.has_v8_4_debug_extension=1                   # (int   , init-time) default = '0x1'    : Implement ARMv8.4 debug extensions (FEAT_Debugv8p4)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_4_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.4 (FEAT_PMUv3p4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_5_debug_over_power_down=0             # (int   , init-time) default = '0x0'    : Implement ARMv8.5 Debug over powerdown (FEAT_DoPD).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_5_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.5 (FEAT_PMUv3p5).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_5_spe_extension=1                     # (int   , init-time) default = '0x1'    : Implement SPE extension from ARMv8.5 (FEAT_SPEv1p1).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_6_pmu_events=1                        # (int   , init-time) default = '0x1'    : Implements PMU events from ARMv8.6
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_7_fp_enhancements=1                   # (int   , init-time) default = '0x1'    : Implements the Floating Point enhancements from Armv8.7 (introduces FPCR.FIZ/AH/NEP, etc. (FEAT_AFP).)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_7_pmu_events=1                        # (int   , init-time) default = '0x1'    : Implement PMU events from ARMv8.7.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_7_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.7 (FEAT_PMUv3p7).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_7_spe_extension=1                     # (int   , init-time) default = '0x1'    : Implement SPE extension from ARMv8.7 (FEAT_SPEv1p2)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_7_spe_previous_branch_target=1        # (bool  , init-time) default = '1'      : Where FEAT_SPEv1p2 is implemented, whether the optional branch target feature is implemented
cluster0.has_v8_8_debug_extension=1                   # (int   , init-time) default = '0x1'    : Implement ARMv8.8 debug extensions (FEAT_Debugv8p8)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_8_pmu_events=1                        # (int   , init-time) default = '0x1'    : Implement PMU events from ARMv8.8 (FEAT_PMUv3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_8_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.8 (FEAT_PMUv3p8).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_8_spe_extension=1                     # (int   , init-time) default = '0x1'    : Implement SPE extension from ARMv8.8 (FEAT_SPEv1p3)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_9_debug_extension=1                   # (int   , init-time) default = '0x1'    : Implement ARMv8.9 debug extensions (FEAT_Debugv8p9)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_9_pc_sample_based_profiling=1         # (int   , init-time) default = '0x1'    : Implement PC Sample-based Profiling from ARMv8.9 (FEAT_PCSRv8p9)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_9_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.9 (FEAT_PMUv3p9).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_v8_9_spe_extension=1                     # (int   , init-time) default = '0x1'    : Implement SPE extension from ARMv8.9 (FEAT_SPEv1p4)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_vncr_el2=1                               # (int   , init-time) default = '0x1'    : Implement support for nested virtualization enhancements from ARMv8.4 (FEAT_NV2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_wfet_and_wfit=1                          # (int   , init-time) default = '0x1'    : Implements WFE and WFI with Timeout from Armv8.7 (FEAT_WFxT)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.has_writebuffer=0                            # (bool  , init-time) default = '0'      : Implement write accesses buffering before L1 cache. May affect ext_abort behaviour.
cluster0.has_xs=1                                     # (int   , init-time) default = '0x1'    : Implements Armv8.7 XS, TLBInXS, DSBnXS instruction (FEAT_XS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.hcptr_tta_behaviour=2                        # (int   , init-time) default = '0x2'    : Behaviour of HCPTR.TTA when there is no CP14 ETM interface. 0, RAZ/WI. 1, RAO/WI. 2, stateful.
cluster0.hcr_el2_miocnce_is_rw=0                      # (bool  , init-time) default = '0'      : If true, HCR_EL2.MIOCNCE is treated as R/W instead of RAZ/WI
cluster0.hcr_swio_res1=0                              # (bool  , init-time) default = '0'      : Whether HCR.SWIO and/or HCR_EL2.SWIO are RES1.
cluster0.hsr_uncond_cc=0                              # (bool  , init-time) default = '0'      : Condition codes reported in HSR as AL if it passes
cluster0.hvbar_reset_is_rvbar=0                       # (bool  , init-time) default = '0'      : If true then the reset value of HVBAR is RVBAR, if false the reset value is UNKNOWN.
cluster0.icache-hit_latency=0                         # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when icache-state_modelled=true.
cluster0.icache-log2linelen=0                         # (int   , init-time) default = '0x0'    : If nonzero, Log2 of the instruction cache line length in bytes (valid values in range 4-8).  Otherwise the value of cache-log2linelen is used.
cluster0.icache-maintenance_latency=0                 # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when icache-state_modelled=true.
cluster0.icache-miss_latency=0                        # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when icache-state_modelled=true.
cluster0.icache-nprefetch=1                           # (int   , init-time) default = '0x1'    : Number of next sequential instruction cache lines to prefetch. This is only used when icache-prefetch_enabled=true.
cluster0.icache-prefetch_enabled=0                    # (bool  , init-time) default = '0'      : Enable simulation of instruction cache prefetching. This is only used when icache-state_modelled=true.
cluster0.icache-prefetch_level=0                      # (int   , init-time) default = '0x0'    : 0 based cache level at which instructions are pre-fetched. This is only used when icache-prefetch_enabled=true.
cluster0.icache-read_access_latency=0                 # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for read accesses given in ticks per access (of size icache-read_bus_width_in_bytes).  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if icache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when icache-state_modelled=true.
cluster0.icache-read_bus_width_in_bytes=8             # (int   , init-time) default = '0x8'    : L1 I-Cache read bus width in bytes used to calculate per-access timing annotations
cluster0.icache-read_latency=0                        # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for read accesses given in ticks per byte accessed.icache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when icache-state_modelled=true.
cluster0.icache-size=32768                            # (int   , init-time) default = '0x8000' : L1 I-Cache size in bytes.
cluster0.icache-ways=2                                # (int   , init-time) default = '0x2'    : L1 I-Cache number of ways (sets are implicit from size).
cluster0.ignore_DBGPRCR_CWRR=0                        # (bool  , init-time) default = '0'      : Ignore writes to the deprecated DBGPRCR.CWRR bit.
cluster0.ignore_access_flag_update_by_at_ops=0        # (bool  , init-time) default = '0'      : If true, AT operations do not update access flag
cluster0.ignore_large_address_top_bits_in_page_walk=0  # (bool  , init-time) default = '0'      : Whether page table bits [15:12] are ignored if PA_SIZE < 52 and output address is configured < 52 with large page
cluster0.ignore_tag_check_dcc_load_store_in_ma_mode_when_tco_is_disabled=0  # (bool  , init-time) default = '0'      : Constrained unpredictable behavior for reads/writes to external debug interface DTR regs in memory access mode when PSTATE.TCO is 0. If true, tag check is ignored else, tag check is performed if required.
cluster0.ignore_traps_to_dcc_regs_in_debug=0          # (bool  , init-time) default = '0'      : Whether traps get ignored for the following registers in debug state:
                                                      #                                        : * AArch64: MDCCSR_EL0, OSDTREX_EL1, OSDTRTX_EL1, MDCCINT_EL1.
                                                      #                                        : * AArch32: DBGDSCRint, DBGDIDR, DBGDSAR, DBGDRAR,
                                                      #                                        : DBGDTRRXext, DBGDTRTXext, DBGDCCINT.
cluster0.imp_def_functionality_behaviour=0            # (int   , init-time) default = '0x0'    : Behaviour of IMPLEMENTATION DEFINED registers and system instructions.  0, UNDEF.  1, RAZ/WI.
cluster0.impdef_regs_and_unpred_from_implementation=  # (string, init-time) default = ''       : Configure implementation defined registers and unpredictable behaviour to match the specified implementation. Requires a license for the selected implementation model.User has to provide the default values for the published or configurable parameters through commandline arguments. Use ARM_Cortex-A<num> or ARM_<codename> for licensed pre-release cores.
cluster0.independent_cache_control_traps=0            # (int   , init-time) default = '0x0'    : Implement Independent Cache Control traps from ARMv8.5. 0, NO_SUPPORT. 1, SUPPORTED_BUT_NOT_FOR_TLB_MAINTENANCE_INSTRUCTIONS. 2, FULL_SUPPORT. (FEAT_EVT)
cluster0.insert_iesb_before_exception=0               # (bool  , init-time) default = '0'      : If true then inserts an IESB before taking with Exception otherwise has no effect and IESB is taken after PState is changed due to the Exception.
cluster0.instruction_tlb_size=0                       # (int   , init-time) default = '0x0'    : Number of stage1+2 itlb entries (or 0 for unified ITLB+DTLB)
cluster0.is_first_pcsr_sample_ignored=0               # (bool  , init-time) default = '0'      : If true, First read of PMPCSR register after reset returns 0xFFFFFFFF
cluster0.is_mt_res0=0                                 # (bool  , init-time) default = '0'      : If ARMv8.6 is not implemented, and PMUv3 is implemented, this parameter controls whether PMEVTYPER<n>.MT bit is RES0 or RW. For other implementations, this parameter has no effect
cluster0.is_tagged_nsh_treated_as_tagged=1            # (bool  , init-time) default = '1'      : Whether a tagged NonShared memory attribute is treated as tagged or not
cluster0.is_uniprocessor=0                            # (bool  , init-time) default = '0'      : Value for the U bit in MPIDR. true disables L1 cache coherency protocols
cluster0.isb_is_branch=0                              # (bool  , init-time) default = '0'      : If true, ISB is traced as an immediate branch. This allows to count ISB as a branch in debug extensions (e.g. PMU)
cluster0.ish_is_osh=0                                 # (bool  , init-time) default = '0'      : Whether Innershareable is same as OuterShareable
cluster0.itd_conditional_instructions_are_32bit=0     # (bool  , init-time) default = '0'      : When SCTLR_ELx.ITD=1, an IT instruction plus a T16 instruction are considered a single 32bit conditional instruction.
cluster0.jidr_is_undef_at_el0=0                       # (bool  , init-time) default = '0'      : If true, JIDR register access is UNDEF at EL0
cluster0.jmcr_is_undef_at_el0=0                       # (bool  , init-time) default = '0'      : If true, JMCR register access is UNDEF at EL0
cluster0.joscr_is_undef_at_el0=0                      # (bool  , init-time) default = '0'      : If true, JOSCR register access is UNDEF at EL0
cluster0.l2cache-hit_latency=0                        # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when dcache-state_modelled=true.
cluster0.l2cache-maintenance_latency=0                # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when dcache-state_modelled=true.
cluster0.l2cache-miss_latency=0                       # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when dcache-state_modelled=true.
cluster0.l2cache-read_access_latency=0                # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for read accesses given in ticks per access.  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l2cache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when dcache-state_modelled=true.
cluster0.l2cache-read_bus_width_in_bytes=8            # (int   , init-time) default = '0x8'    : L2 Cache read bus width in bytes used to calculate per-access timing annotations
cluster0.l2cache-read_latency=0                       # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for read accesses given in ticks per byte accessed.l2cache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when dcache-state_modelled=true.
cluster0.l2cache-size=524288                          # (int   , init-time) default = '0x80000' : L2 Cache size in bytes.
cluster0.l2cache-snoop_data_transfer_latency=0        # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for received snoop accesses that perform a data transfer given in ticks per byte accessed. This is only used when dcache-state_modelled=true.
cluster0.l2cache-snoop_issue_latency=0                # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for snoop accesses issued by this cache in total ticks. This is only used when dcache-state_modelled=true.
cluster0.l2cache-ways=16                              # (int   , init-time) default = '0x10'   : L2 Cache number of ways (sets are implicit from size).
cluster0.l2cache-write_access_latency=0               # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for write accesses given in ticks per access. If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l2cache-write_latency is set. This is only used when dcache-state_modelled=true.
cluster0.l2cache-write_bus_width_in_bytes=8           # (int   , init-time) default = '0x8'    : L2 Cache write bus width in bytes used to calculate per-access timing annotations
cluster0.l2cache-write_latency=0                      # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for write accesses given in ticks per byte accessed. l2cache-write_access_latency must be set to 0 for per-byte latencies to be applied. This is only used when dcache-state_modelled=true.
cluster0.l3cache-has_mpam=0                           # (bool  , init-time) default = '0'      : L3 Cache has MPAM support
cluster0.l3cache-hit_latency=0                        # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when dcache-state_modelled=true.
cluster0.l3cache-maintenance_latency=0                # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when dcache-state_modelled=true.
cluster0.l3cache-miss_latency=0                       # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when dcache-state_modelled=true.
cluster0.l3cache-mpamf.bwa_width_ns=16                # (int   , init-time) default = '0x10'   : L3 Cache width of MPAM bandwidth allocation fields for non-secure accesses.
cluster0.l3cache-mpamf.bwa_width_s=16                 # (int   , init-time) default = '0x10'   : L3 Cache width of MPAM bandwidth allocation fields for secure accesses.
cluster0.l3cache-mpamf.cmax_width_ns=0                # (int   , init-time) default = '0x0'    : L3 Cache number of fractional bits in MPAM cache capacity partition control for non-secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cluster0.l3cache-mpamf.cmax_width_s=0                 # (int   , init-time) default = '0x0'    : L3 Cache number of fractional bits in MPAM cache capacity partition control for secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cluster0.l3cache-mpamf.cpbm_width_ns=0                # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for non-secure accesses. If 0, the feature is not implemented, and all ways are available.
cluster0.l3cache-mpamf.cpbm_width_rl=0                # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for realm accesses. If 0, the feature is not implemented, and all ways are available.
cluster0.l3cache-mpamf.cpbm_width_rt=0                # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for root accesses. If 0, the feature is not implemented, and all ways are available.
cluster0.l3cache-mpamf.cpbm_width_s=0                 # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for secure accesses. If 0, the feature is not implemented, and all ways are available.
cluster0.l3cache-mpamf.csu_num_mon_ns=0               # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for non-secure accesses.
cluster0.l3cache-mpamf.csu_num_mon_rl=0               # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for realm accesses.
cluster0.l3cache-mpamf.csu_num_mon_rt=0               # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for root accesses.
cluster0.l3cache-mpamf.csu_num_mon_s=0                # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for secure accesses.
cluster0.l3cache-mpamf.has_esr=0                      # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_ESR, MPAMF_ECR, and MPAM error handling implemented.
cluster0.l3cache-mpamf.has_extd_esr=0                 # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_ESR is 64-bits.
cluster0.l3cache-mpamf.has_impl_idr=0                 # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_IMPL_IDR is present.
cluster0.l3cache-mpamf.has_mbwu_long_counter=0        # (bool  , init-time) default = '0'      : L3 Cache has long MBWU counter and capture registers.
cluster0.l3cache-mpamf.has_mpamfidr_ext=0             # (bool  , init-time) default = '0'      : MPAMF_IDR.EXT support
cluster0.l3cache-mpamf.has_partid_nrw=0               # (bool  , init-time) default = '0'      : Narrowing part ID register is present. This is global rather than per-instance.
cluster0.l3cache-mpamf.has_priority_partioning=0      # (bool  , init-time) default = '0'      : The selected resource has priority partitioning described in MPAMF_PRI_IDR.
cluster0.l3cache-mpamf.has_prod_id=0                  # (int   , init-time) default = '0x0'    : L3 Cache MPAMF_IIDR product ID supported.
cluster0.l3cache-mpamf.has_prod_rev=0                 # (int   , init-time) default = '0x0'    : L3 Cache MPAMF_IIDR product REVISION supported.
cluster0.l3cache-mpamf.has_prod_var=0                 # (int   , init-time) default = '0x0'    : L3 Cache MPAMF_IIDR product VARIENT supported.
cluster0.l3cache-mpamf.has_prop_ns=0                  # (bool  , init-time) default = '0'      : Enable memory bandwidth proportional stride control for non-secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cluster0.l3cache-mpamf.has_prop_s=0                   # (bool  , init-time) default = '0'      : Enable memory bandwidth proportional stride control for secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cluster0.l3cache-mpamf.has_ris=0                      # (bool  , init-time) default = '0'      : L3 Cache has resource instance selection support.
cluster0.l3cache-mpamf.max_partid_ns=65535            # (int   , init-time) default = '0xffff' : L3 Cache Maximum value of non-secure PARTID supported.
cluster0.l3cache-mpamf.max_partid_rl=65535            # (int   , init-time) default = '0xffff' : L3 Cache Maximum value of realm PARTID supported for RME implementations.
cluster0.l3cache-mpamf.max_partid_rt=65535            # (int   , init-time) default = '0xffff' : L3 Cache Maximum value of root PARTID supported for RME implementations.
cluster0.l3cache-mpamf.max_partid_s=65535             # (int   , init-time) default = '0xffff' : L3 Cache Maximum value of secure PARTID supported.
cluster0.l3cache-mpamf.max_pmg_ns=255                 # (int   , init-time) default = '0xff'   : L3 Cache Maximum value of non-secure PMG supported.
cluster0.l3cache-mpamf.max_pmg_rl=255                 # (int   , init-time) default = '0xff'   : L3 Cache Maximum value of realm PMG supported for RME implementations.
cluster0.l3cache-mpamf.max_pmg_rt=255                 # (int   , init-time) default = '0xff'   : L3 Cache Maximum value of root PMG supported for RME implementations.
cluster0.l3cache-mpamf.max_pmg_s=255                  # (int   , init-time) default = '0xff'   : L3 Cache Maximum value of secure PMG supported.
cluster0.l3cache-mpamf.mbwu_long_counter_width=0      # (int   , init-time) default = '0x0'    : L3 Cache long MBWU counter width. 0: 63 bits, 1: 44 bits.
cluster0.l3cache-mpamf.no_impl_msmon=0                # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_IMPL_IDR does not describe resource monitors.
cluster0.l3cache-mpamf.no_impl_part=0                 # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_IMPL_IDR does not describe resource partitioning controls.
cluster0.l3cache-mpamf.ris_max=0                      # (int   , init-time) default = '0x0'    : L3 Cache's largest resource instance selector value defined.
cluster0.l3cache-mpamf_base=0                         # (int   , init-time) default = '0x0'    : L3 Cache memory mapped MPAM registers base address
cluster0.l3cache-read_access_latency=0                # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for read accesses given in ticks per access (of size l3cache-read_bus_width_in_bytes).  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l3cache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when dcache-state_modelled=true.
cluster0.l3cache-read_bus_width_in_bytes=8            # (int   , init-time) default = '0x8'    : L3 Cache read bus width in bytes used to calculate per-access timing annotations
cluster0.l3cache-read_latency=0                       # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for read accesses given in ticks per byte accessed.l3cache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when dcache-state_modelled=true.
cluster0.l3cache-size=0                               # (int   , init-time) default = '0x0'    : L3 Cache size in bytes.
cluster0.l3cache-snoop_data_transfer_latency=0        # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for received snoop accesses that perform a data transfer given in ticks per byte accessed. This is only used when dcache-state_modelled=true.
cluster0.l3cache-snoop_issue_latency=0                # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for snoop accesses issued by this cache in total ticks. This is only used when dcache-state_modelled=true.
cluster0.l3cache-ways=16                              # (int   , init-time) default = '0x10'   : L3 Cache number of ways (sets are implicit from size).
cluster0.l3cache-write_access_latency=0               # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for write accesses given in ticks per access (of size l3cache-write_bus_width_in_bytes). If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l3cache-write_latency is set. This is only used when dcache-state_modelled=true.
cluster0.l3cache-write_bus_width_in_bytes=8           # (int   , init-time) default = '0x8'    : L3 Cache write bus width in bytes used to calculate per-access timing annotations
cluster0.l3cache-write_latency=0                      # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for write accesses given in ticks per byte accessed. l3cache-write_access_latency must be set to 0 for per-byte latencies to be applied. This is only used when dcache-state_modelled=true.
cluster0.legacy_combining_exc_catch_trace=1           # (bool  , init-time) default = '1'      : Whether exception catch is traced as part of exception entry/exit in same cycle
cluster0.log2_trace_buffer_alignment=0                # (int   , init-time) default = '0x0'    : Log2 of trace buffer alignment constraint for output buffer (0->1B ... 11->2Kib)
cluster0.max_32bit_el=3                               # (int   , init-time) default = '0x3'    : Maximum exception level supporting AArch32 modes. -1: No Support for A32 at any EL, x:[0:3] - All the levels below supplied ELx supports A32
cluster0.mdselr_le_16_bps_wps_behaviour=0             # (int   , init-time) default = '0x0'    : Behaviour of MDSELR_EL1 and related traps/enables if fewer than 16 watchpoints and fewer than 16 breakpoints are implemented: 0 - MDSELR_EL1 is stateful 1 - MDSELR_EL1, EBWE, FGTS are RAZ/WI, traps and enables do not apply
cluster0.mec_support_level=0                          # (int   , init-time) default = '0x0'    : 0 -> Memory Encryption Contexts not implemented,  1 -> LEGACY_TZ_EN mode i.e. MEC register fields are stateful but only supports secure/non-secure states, 2 -> Memory Encryption Contexts fully implemented (FEAT_MEC).
cluster0.memory.acp.AxCACHE_mask=0                    # (int   , init-time) default = '0x0'    : Used with memory.acp.AxCACHE_pattern to define which memory types the ACP port accepts. All transactions which do not satisfy (AxCACHE & mask) == pattern will abort.
cluster0.memory.acp.AxCACHE_pattern=0                 # (int   , init-time) default = '0x0'    : Used with memory.acp.AxCACHE_mask to define which memory types the ACP port accepts. All transactions which do not satisfy (AxCACHE & mask) == pattern will abort.
cluster0.memory.l2_cache.is_inner_cacheable=1         # (bool  , init-time) default = '1'      : L2 cache obeys inner cacheable attributes (rather than outer cacheable attributes)
cluster0.memory.l2_cache.is_inner_shareable=1         # (bool  , init-time) default = '1'      : L2 cache obeys inner shareable attributes (rather than outer shareable attributes)
cluster0.memory_tagging_support_level=0               # (int   , init-time) default = '0x0'    : Specify the memory tagging extension support level: 0, not implemented. 1, instructions and registers only are implemented (FEAT_MTE). 2, implemented (FEAT_MTE2). 3, implemented with asymmetric handling of exceptions. 4, implemented (FEAT_MTE4).
cluster0.mixed_endian=1                               # (int   , init-time) default = '0x1'    : Implement support for mixed endianness. 0, not supported. 1, supported at all exception levels. 2, supported at EL0 only.
cluster0.mops_cpy_block_size=64                       # (int   , init-time) default = '0x40'   : Block size used for memcpy memory accesses
cluster0.mops_cpy_default_dir=0                       # (int   , init-time) default = '0x0'    : Default direction for non-overlapping memcpy operations: 0, forwards. 1, backwards
cluster0.mops_cpy_handle_async_exceptions=0           # (bool  , init-time) default = '0'      : Handle any pending async exceptions after copying a block of data, instad of waiting until instruction end.
cluster0.mops_cpy_post_size=10                        # (int   , init-time) default = '0xa'    : Percentage of data copied in memcpy 'E' instructions
cluster0.mops_cpy_pre_size=10                         # (int   , init-time) default = '0xa'    : Percentage of data copied in memcpy 'P' instructions
cluster0.mops_cpy_single_access=0                     # (bool  , init-time) default = '0'      : Execute memcpy as a single read and single write access
cluster0.mops_cpy_write_abort_before_read=0           # (bool  , init-time) default = '0'      : Report the data aborts and watchpoint of the write accesses, before those of the read accesses
cluster0.mops_cpy_zero_size_can_fault=1               # (bool  , init-time) default = '1'      : Fault because of mismatched implementation option when the operation is of size 0.
cluster0.mops_exec_order_can_fault=0                  # (bool  , init-time) default = '0'      : Enable exception on the Main/Epilogue instruction when executed after a mismatched Prologue/Main in a CPY/SET sequence, or after another random instruction
cluster0.mops_mmu_abort_far_aligned=0                 # (bool  , init-time) default = '0'      : If true, in case of an MMU abort on a MOPS instruction, report FAR aligned to current translation granule.
cluster0.mops_set_block_size=64                       # (int   , init-time) default = '0x40'   : Block size used for memset memory accesses
cluster0.mops_set_handle_async_exceptions=0           # (bool  , init-time) default = '0'      : Handle any pending async exceptions after setting a block of data, instad of waiting until instruction end.
cluster0.mops_set_post_size=10                        # (int   , init-time) default = '0xa'    : Percentage of data copied in memset 'E' instructions
cluster0.mops_set_pre_size=10                         # (int   , init-time) default = '0xa'    : Percentage of data copied in memset 'P' instructions
cluster0.mops_set_single_access=0                     # (bool  , init-time) default = '0'      : Execute memset as a single read and single write access
cluster0.mops_set_zero_size_can_fault=1               # (bool  , init-time) default = '1'      : Fault because of mismatched implementation option when the operation is of size 0.
cluster0.mops_setg_unaligned_does_mismatch_fault=0    # (bool  , init-time) default = '0'      : If true, in case of unaligned SETGM / SETGE, raise a mismatched memset exception because of impdef reasons, instead of alignment fault
cluster0.mops_wp_far_behaviour=0                      # (int   , init-time) default = '0x0'    : Set option for address stored in FAR/EDWARD after watchpoints hit by MOPS instructions
                                                      #                                        :  0 - FAR recorded matches lowest watchpointed address accessed by the instruction
                                                      #                                        :  1 - FAR recorded matches lowest address accessed by the instruction within same translation granule as watchpointed address
                                                      #                                        :  2 - FAR recorded matches highest watchpointed address accessed by the instruction that triggered the watchpoint
cluster0.mpam_force_ns_rao=0                          # (bool  , init-time) default = '0'      : Whether MPAM3_EL3.FORCE_NS bit is RAO/WI.
cluster0.mpam_frac=0                                  # (int   , init-time) default = '0x0'    : MPAM fractional revision number in ID_AA64PFR1_EL1.MPAM_frac field
cluster0.mpam_has_altsp=0                             # (bool  , init-time) default = '0'      : MPAM Whether MPAMIDR_EL1.HAS_ALTSP bit is set or clear
cluster0.mpam_has_hcr=0                               # (bool  , init-time) default = '0'      : MPAM Whether MPAMIDR_EL1 HAS_HCR bit is set or clear
cluster0.mpam_max_partid=65535                        # (int   , init-time) default = '0xffff' : MPAM Maximum PARTID Supported
cluster0.mpam_max_pmg=255                             # (int   , init-time) default = '0xff'   : MPAM Maximum PMG Supported
cluster0.mpam_max_vpmr=0                              # (int   , init-time) default = '0x0'    : MPAM Maximum VPMR Supported
cluster0.mpamidr_has_force_ns=0                       # (int   , init-time) default = '0x0'    : Whether MPAMIDR_EL1.HAS_FORCE_NS bit is set or clear.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.mpamidr_has_sdeflt=0                         # (int   , init-time) default = '0x0'    : Whether MPAMIDR_EL1.HAS_SDEFLT bit is set or clear.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.mpamidr_has_tidr=0                           # (int   , init-time) default = '0x0'    : Whether MPAMIDR_EL1.HAS_TIDR bit is set or clear
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.mpidr_layout=1                               # (int   , init-time) default = '0x1'    : Layout of MPIDR. 0 AFF0 is CPUID, 1 AFF1 is CPUID
cluster0.mpmm_config=                                 # (string, init-time) default = ''       : MPMMTUNE register value. The JSON schema is : 
                                                      #                                        : {
                                                      #                                        : "DT_THR":0,
                                                      #                                        : "MPMM_G2_TP":2,
                                                      #                                        : "MPMM_G2_ATHR":100,
                                                      #                                        : "MPMM_G1_TP":2,
                                                      #                                        : "MPMM_G1_ATHR":75,
                                                      #                                        : "MPMM_G0_TP":2,
                                                      #                                        : "MPMM_G0_ATHR":50
                                                      #                                        : }
                                                      #                                        : . The value given for threshold value is just an indication, not specific to any core. This parameter is used only when has_mpmm is set.
cluster0.mte_report_which_failed_address=first        # (string, init-time) default = 'first'  : Set to "first" or "last". Applicable only for MTE synchronous check. If "first" then report first failed address. If "last" then report the first address of last failed MTE granule or first address of transfer if it doesn't cross a granule boundary.
cluster0.mte_tminline=0                               # (int   , init-time) default = '0x0'    : Value of CTR_EL0.TminLine for reading purpose only. A value configured using this does not indicate the presence of separate tag cache. 0, TminLine evaluated from smallest data cache line.
cluster0.mvbar_reset_is_rvbar=1                       # (bool  , init-time) default = '1'      : If true then the reset value of MVBAR is RVBAR, if false the reset value is UNKNOWN.
cluster0.non_secure_vgic_alias_when_ns_only=0         # (int   , init-time) default = '0x0'    : If ! has_el3 and only non-secure side exists, then the normal position of the VGIC is a secure alias.  If this parameter is non-zero then in addition a non-secure alias of the VGIC will be placed at this position (aligned to 32 KB).
cluster0.num_loregion_descriptors=0                   # (int   , init-time) default = '0x0'    : Number of Limited Ordering Region descriptors implemented (if ARM v8.1 extensions are implemented) (FEAT_LOR).
cluster0.num_loregions=0                              # (int   , init-time) default = '0x0'    : Number of Limited Ordering Regions implemented excluding background region (if ARM v8.1 extensions are implemented) (FEAT_LOR).
cluster0.number_of_error_records=0                    # (int   , init-time) default = '0x0'    : Cores Number of Error records supported for RAS
cluster0.optimal_alignment_size=1                     # (int   , init-time) default = '0x1'    : Alignment boundary which does not incur additional performance penalty from ARMv8.5.
                                                      #                                        :   - 1, architectural misalignment is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
                                                      #                                        :   - 2, access crossing 4 byte boundary is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
                                                      #                                        :   - 3, access crossing 8 byte boundary is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
                                                      #                                        : 	...
                                                      #                                        :   - 12, access crossing 4 Kbyte boundary is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
                                                      #                                        : 
cluster0.output_attributes=ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS  # (string, init-time) default = 'ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS' : User-defined transform to be applied to bus attributes like MasterID, ExtendedID or UserFlags. Currently, only works for MPAM Attributes encoding into bus attributes.
cluster0.page_based_hardware_attributes=0             # (int   , init-time) default = '0x0'    : Implement the page based hardware attributes from ARMv8.2.  This parameter indicates which page table bits are available for hardware, where bits[3:0] correspond to PTE[62:59] and to TCR_ELx.HWUnyy (FEAT_HPDS2).
cluster0.par_ns_set_unknown_bit=1                     # (bool  , init-time) default = '1'      : Whether NS bit of PAR is set/clear when executing AT to perform non-secure regime translation. When true, NS is set to 1 else 0.
cluster0.pfar_is_valid=1                              # (bool  , init-time) default = '1'      : IMPLEMENTATION DEFINED choice to configure ESR_ELx.PFV: whether PFAR_ELx is valid or UNKNOWN when ESR_ELx.PFV is not forced to be 0.
cluster0.pfr1_csv2_frac=0                             # (int   , init-time) default = '0x0'    : Fractional revision number ID_AA64PFR1_EL1.CSV2_frac when ID_AA64PFR0_EL1.CSV==1 for CSV2 extension (FEAT_CSV2_1p1, FEAT_CSV2_1p2)
cluster0.pmb_idr_external_abort=0                     # (int   , init-time) default = '0x0'    : Describes how the PE manages External aborts on writes made by the Statistical Profiling Extension to the Profiling Buffer. 0, External abort is reported to SPE, From Armv8.8 and Armv9.3, the value 0 is not permitted. 1, External abort is ignored. 2, The External abort generates an SError and the error is not reported to SPE.
cluster0.pmb_idr_flag_updates=1                       # (bool  , init-time) default = '1'      : Defines whether the address translation performed by the Profiling Buffer manages the Access Flag and dirty state
cluster0.pmcr_disable_events_export=1                 # (bool  , init-time) default = '1'      : If true, export for PMU events is disabled. This configures PMCFGR.EX field.
cluster0.pmmir_el1_bus_slots=0                        # (int   , init-time) default = '0x0'    : Largest value by which BUS_ACCESS can increment over BUS_CYCLES cycles. From v8.7 PMU extension
cluster0.pmmir_el1_bus_width=0                        # (int   , init-time) default = '0x0'    : Width, in bytes, of accesses counted by BUS_ACCESS. From v8.7 PMU extension
cluster0.pms_idr_max_size=6                           # (int   , init-time) default = '0x6'    : Defines largest size for a single SPE record (rounded up to a power of 2)
cluster0.pmu-num_counters=8                           # (int   , init-time) default = '0x8'    : Number of PMU counters implemented
cluster0.pmu_async_exception_delay=0                  # (int   , init-time) default = '0x0'    : Configure PMU asynchronous exception delay in CPU cycles (FEAT_SEBEP)
cluster0.pmu_cycle_counter_counts_actual_cycles=0     # (bool  , init-time) default = '0'      : If true and Timing annotation is enabled, PMU cycle counter counts actual cycles, otherwise counts instructions executed
cluster0.pmu_has_chain_event=1                        # (bool  , init-time) default = '1'      : PMU (if present) implements event number 0x1e, CHAIN.
cluster0.pmu_precise_events=                          # (string, init-time) default = ''       : "Configure v9.4 Precise PMU events. {"pmu_events":["SW_INCR","PC_WRITE_RETIRED","BR_RETIRED","BR_IND_RETIRED","BR_RETURN_RETIRED","BR_RETURN_ANY_RETIRED","BR_IND_TAKEN_RETIRED","LD_RETIRED","ST_RETIRED","UNALIGNED_LD_ST","INST_RETIRED","EXCEP_TAKEN","EXCEP_RETURN","CHAIN"]}"
cluster0.pmu_threshold_bit_width=0                    # (int   , init-time) default = '0x0'    : Implement FEAT_PMUv3_TH and if so the width of PMEVTYPER<n>_ELO.TH in bits. 0, not implemented. 1-12 number of bits in PMEVTYPER<n>_EL0.TH.
cluster0.poison_range_end_addr=0                      # (int   , init-time) default = '0x0'    : End PA of poisoned range.
cluster0.poison_range_start_addr=0                    # (int   , init-time) default = '0x0'    : Start PA of poisoned range.
cluster0.pseudo_fault_generation_feature_register=    # (string, init-time) default = ''       : ARMv8.4 Standard Pseudo-fault generation feature register values. JSON schema for the parameter value is: [{"OF":false,"UC":false,"UEU":false,"UER":false,"UEO":false,"DE":false,"CE":0x0,"CI":false,"ER":false,"PN":false,"AV":false,"MV":false,"SYN":false,"R":false,"NA":false},other_psuedo-fault_generating_features_register_values]. Where OF, UC, UEU, UER, UEO, DE, CI, ER, PN, AV, MV, SYN, and R have valid false(NOT_SUPPORTED) and true(FEATURE_CONTROLLABLE), where CE can have 0(NOT_SUPPORTED), 1(NONSPECIFIC_CE_SUPPORTED) and 3(TRANSIENT_OR_PERSISTENT_CE_SUPPORTED) and NA can have false(component fakes detection on next access) or true(component fakes detection spontaneously). Effective only when ERXFR's INJ field allows it or has_ras_fault_injection is true.
cluster0.pstate_ssbs_reset=0                          # (bool  , init-time) default = '0'      : Reset value of pstate.ssbs
cluster0.pstate_ssbs_type=0                           # (int   , init-time) default = '0x0'    : Implement speculative store bypass safe feature from ARMv8.5. 0, Not supported. 1, Supported without MSR/MRS access to SSBS (FEAT_SSBS). 2, fully supported (FEAT_SSBS2).
cluster0.ptw_latency=0                                # (int   , run-time ) default = '0x0'    : Page table walker latency for TA (Timing Annotation), expressed in simulation ticks
cluster0.randomize_unknowns_at_reset=0                # (bool  , init-time) default = '0'      : Will fill in unknown bits in registers at reset with random value using register_reset_data as seed, it overrides scramble_unknowns_at_reset
cluster0.ras_errselr_undef_if_no_error_records=0      # (bool  , init-time) default = '0'      : If true, ERRSELR_EL1 will be undefined if ERRIDR_EL1 indicates that zero error records are implemented.
cluster0.ras_extra_configurations=                    # (string, init-time) default = ''       : Miscellaneous configurations for error records. An array of JSON objects. Note for ERXCTRL_EL1 register it only allows to define the mask and reset value for the IMPDEF fields, ie bits [63:32] and bit 1. E.g. [{"Index": 0, "ERXMISC0_mask": 0x0, "ERXMISC0_reset": 0x0, "ERXMISC1_mask": 0x0, "ERXMISC1_reset": 0x0, "ERXCTRL_EL1_mask": 0x0, "ERXCTRL_EL1_reset": 0x0}, {"Index": 1, "ERXMISC0_mask": 0x0, "ERXMISC0_reset": 0x0, "ERXSTATUS_IERR_mask": 0x300}]
cluster0.ras_frac=0                                   # (int   , init-time) default = '0x0'    : 0, No additional feature implemented. 1, Additional ERXMISC*, ERXPFG* registers and FaultInjection trap from RAS v1.1. implemented
cluster0.ras_pfg_clock_mhz=24                         # (int   , init-time) default = '0x18'   : RAS Pseudo-Fault generation clock rate in MHz
cluster0.register_reset_data=0                        # (int   , init-time) default = '0x0'    : Data used to fill register bits when they become UNKNOWN at reset.
cluster0.register_reset_data_hi=0                     # (int   , init-time) default = '0x0'    : Data used to fill the upper-half of 128-bit registers when the bits become UNKNOWN at reset.
cluster0.report_iside_cmo_ifsr=1                      # (bool  , init-time) default = '1'      : fault info for an iside cache maintenance operation is reported in the IFSR
cluster0.reserved_HMC_SSC_PAC_treated_disabled=0      # (bool  , init-time) default = '0'      : When DBG[B|W]CR.{HMC,SSC,PAC} bits configuration is reserved, this parameter controls whether breakpoints/watchpoints are treated as Disabled or not
cluster0.restore_fpsr_on_trapped_fp_exception=0       # (bool  , init-time) default = '0'      : If true, FPSR is restored to the value of the FPSR immediately before the instruction that generated the trapped floating-point exception.
cluster0.restriction_on_speculative_execution=0       # (int   , init-time) default = '0x0'    : Implements the ARMv8.5 security feature (Restrictions on the effects of speculation), ID_AA64PFR0_EL1.CSV2: 0: No disclosure whether branch targets trained in one context can affect speculative execution in a different context, 1: Branch targets trained in one context cannot affect speculative execution in a different hardware described context (SCXTNUM_ELx not supported), 2: Branch targets trained in one context cannot affect speculative execution in a different hardware described context (SCXTNUM_ELx supported) (FEAT_CSV2, FEAT_CSV2_2)., 3: FEAT_CSV2_3 is supported
cluster0.restriction_on_speculative_execution_aarch32=0  # (int   , init-time) default = '0x0'    : Implements the ARMv8.5 security feature (Restrictions on the effects of speculation), ID_PFR0.CSV2: 0: No disclosure whether branch targets trained in one context can affect speculative execution in a different context, 1: Branch targets trained in one context cannot affect speculative execution in a different hardware described context, 2: Branch targets trained in one context cannot affect speculative execution in a different hardware described context or at a different address in the same hardware described context (FEAT_CSV2, FEAT_CSV2_2).
cluster0.revision_number=0                            # (int   , init-time) default = '0x0'    : Cosmetic change to Variant field in MIDR/MIDR_EL1. Corresponds to the revision number X in rXpY.
cluster0.rgsr_res0_stateful=0                         # (bool  , init-time) default = '0'      : Whether RGSR read of RES0 bits return last written value
cluster0.rme_default_mecid_nonsecure=0                # (int   , init-time) default = '0x0'    : Default MECID value for NON-SECURE PAS
cluster0.rme_default_mecid_realm=0                    # (int   , init-time) default = '0x0'    : Default MECID value for REALM PAS
cluster0.rme_default_mecid_root=0                     # (int   , init-time) default = '0x0'    : Default MECID value for ROOT PAS
cluster0.rme_default_mecid_secure=0                   # (int   , init-time) default = '0x0'    : Default MECID value for SECURE PAS
cluster0.rme_level0_gpt_size=0                        # (int   , init-time) default = '0x0'    : The range of address space protected by each entry in the level 0 GPT (0->1GB 1->16GB, 2->64GB, 3->512GB
cluster0.rme_mecid_width=1                            # (int   , init-time) default = '0x1'    : Width of MECID in bits
cluster0.rme_support_level=0                          # (int   , init-time) default = '0x0'    : 0 -> Realm management extension not implemented,  1 -> LEGACY_TZ_EN mode i.e. RME register fields are stateful but only supports secure/non-secure states, 2 -> Realm management extension fully implemented (FEAT_RME).
cluster0.rmr_always_implemented=0                     # (bool  , init-time) default = '0'      : Always implement RMR_ELx, RMR, or HRMR at the highest implemented exception level, even if that exception level cannot use both AArch32 and AArch64.
cluster0.rndr_rndrrs_seed=0                           # (int   , init-time) default = '0x0'    : Initial seed for random engine used in RNDR register
cluster0.scheduler_mode=0                             # (int   , init-time) default = '0x0'    : Control the interleaving of instructions in this processor.  0, default long quantum. 1, low latency mode, short quantum and signal checking. 2, lock-breaking mode, long quantum with additional context switches near load-exclusive instructions. WARNING: This parameter is intended for validation purposes and may result in unwanted behaviour if altered!
cluster0.scr_nET_writeable=0                          # (bool  , init-time) default = '0'      : Whether SCR.nET is writeable. Writing to it is purely cosmetic (nET behavior not implemented)
cluster0.scramble_unknowns_at_reset=1                 # (bool  , init-time) default = '1'      : Will fill in unknown bits in registers at reset with register_reset_data
cluster0.set_mops_option=0                            # (int   , init-time) default = '0x0'    : Set option for Armv8.8 SET(FEAT_MOPS). 0, use default(i.e. use value configured through has_mops_option). 1, implemented using Option A. 2, implemented using Option B
cluster0.set_rasv10_for_armv84_and_higher=0           # (bool  , init-time) default = '0'      : ARMv8.4 mandates RAS System Architecture v1.1, but when there are no error records and FEAT_DoubleFault is not implemented then there is no functional difference between the RAS System Architecture v1.0 (that is, the RAS extension as in pre-ARMv8.4 implementations) and the RAS System Architecture v1.1 (also known as FEAT_RASv1p1).  This flag if true will set the RAS ID to declare RAS v1.0 rather than RAS v1.1 for ARMv8.4 and higher implementations.  If this is set and the core does not conform to the restrictions then this parameter is ignored.
cluster0.setg_mops_option=0                           # (int   , init-time) default = '0x0'    : Set option for Armv8.8 SETG(FEAT_MOPS). 0, use default(i.e. use value configured through has_mops_option). 1, implemented using Option A. 2, implemented using Option B
cluster0.skip_trace_on_write_to_oseccr_el1_when_oslock_is_unlocked=0  # (bool  , init-time) default = '0'      : If OSLSR_EL1.OSLK == 0, then OSECCR_EL1 returns an unknown value on reads and ignores writes. When true, also skips the traces on writes to OSECCR_EL1 when OSLSR_EL1.OSLK == 0.
cluster0.spe_counter_size=1                           # (int   , init-time) default = '0x1'    : Size of counter packet payload in Statistical Profiling Extension
                                                      #                                        :    - 1, Counter packet payloads are 12-bit saturating counters
                                                      #                                        :    - 2, Counter packet payloads are 16-bit saturating counters
cluster0.spsr_el3_is_mapped_to_spsr_mon=1             # (bool  , init-time) default = '1'      : Whether SPSR_EL3 is mapped to AArch32 register SPSR_mon
cluster0.spsr_m4_res0=0                               # (bool  , init-time) default = '0'      : Whether SPSR_ELx.M[4] bit should be RES0 for AARCH64 only implementations
cluster0.stage12_tlb_size=128                         # (int   , init-time) default = '0x80'   : Number of stage1+2 tlb entries.
cluster0.stage1_tlb_size=0                            # (int   , init-time) default = '0x0'    : Number of stage1 only tlb entries.
cluster0.stage1_walkcache_size=0                      # (int   , init-time) default = '0x0'    : Number of stage1 only walk cache entries.
cluster0.stage2_tlb_size=0                            # (int   , init-time) default = '0x0'    : Number of stage2 only tlb entries.
cluster0.stage2_walkcache_size=0                      # (int   , init-time) default = '0x0'    : Number of stage2 only walk cache entries.
cluster0.statistical_profiling_buffer_alignment=1     # (int   , init-time) default = '0x1'    : Statistical profiling alignment constraint for sample buffer
cluster0.statistical_profiling_random_interval_is_separate=0  # (bool  , init-time) default = '0'      : Statistical profiling random interval gets added to the main timer interval(false) or (true) runs as separate timer
cluster0.statistical_profiling_recommended_min_sampling=256  # (int   , init-time) default = '0x100'  : Statistical profiling recommended minimum sampling interval
cluster0.strex_fail_can_hit_watchpoint=0              # (bool  , init-time) default = '0'      : If true, a strex fail can hit watchpoint
cluster0.supports_multi_threading=1                   # (bool  , init-time) default = '1'      : Sets the MPIDR.MT bit. Setting this to true hints the the cluster is multi-threading compatible
cluster0.swp_with_xzr_is_st_atomic=1                  # (bool  , init-time) default = '1'      : If true, swp with dest as xzr is treated as store atomic
cluster0.sync_ext_abort_is_sync_serror=0              # (bool  , init-time) default = '0'      : Treat synchronous external aborts as synchronous SErrors (RASv8.9).  0, synchronous external abort.  1, synchronous serror.
cluster0.system_pmu_id=0                              # (int   , init-time) default = '0x0'    : When FEAT_SPMU is implemented, indicates the largest value s to select a System PMU <s>
cluster0.take_ccfail_tsc_trap=0                       # (bool  , init-time) default = '0'      : When take_ccfail_undef=1 this parameter controls whether or not an SMC instruction that is trapped by HCR_EL2.TSC but fails its condition code check generates a trap to EL2.
cluster0.take_ccfail_undef=1                          # (bool  , init-time) default = '1'      : UNDEF exception is taken even if condition code check fails
cluster0.tcr_ps_reserved_value_size=0                 # (int   , init-time) default = '0x0'    : Physical size treated when TCR.(I)PS is programmed with a reserved value. 0, 48 bits. 1, 52 bits. The parameter value is treated 0 if LPA is not supported.
cluster0.tcr_txsz_undersize_should_fault=1            # (bool  , init-time) default = '1'      : If large VA is not supported, Whether undersized TxSZ value should generate translation fault
cluster0.tdosa_traps_osdlr_if_no_os_double_lock=1     # (bool  , init-time) default = '1'      : MDCR_EL*.TDOSA enables trap on OSDLR_EL1 and DBGOSDLR when OS double-lock is not implemented.
cluster0.tidcp_traps_el0_undef_imp_def=1              # (bool  , init-time) default = '1'      : TIDCP has priority over UNDEF for accesses to IMPLEMENTATION DEFINED functionality from EL0
cluster0.tlb_latency=0                                # (int   , run-time ) default = '0x0'    : TLB latency for TA (Timing Annotation), expressed in simulation ticks
cluster0.tlbi_invalid_xt_behave_as_undef=0            # (bool  , init-time) default = '0'      : If true, TLBI instructions that don't take Xt as an argument behave as UNDEFINED if Xt != 0b11111
cluster0.tme_disable-read-write-set-optimizations=0   # (bool  , init-time) default = '0'      : If true, disables the read/write set related optimizations of the model.
cluster0.tme_imp-failures-can-retry=0                 # (bool  , init-time) default = '0'      : If true, IMP=1 failures introduced by the parameters:
                                                      #                                        : 	tme_wfe-fails-transactions
                                                      #                                        : 	tme_tcommit-fails-transactions
                                                      #                                        : 	tme_wakeup-from-wfe-always-fails-transactions
                                                      #                                        : will also report RTRY=1.
cluster0.tme_implementation-type=0                    # (int   , init-time) default = '0x0'    : Implementation type for TME.
                                                      #                                        : 
                                                      #                                        : The following options are available:
                                                      #                                        : 	0x0: Always fail starting transactions with the IMP cause.
                                                      #                                        : 	0x1: Fail on forbidden operations (e.g. some system register accesses) and at model's convenience.
                                                      #                                        : 	0x2: As 0x1 but also enable inter PE memory conflict checking.
                                                      #                                        : 
cluster0.tme_random-memory-access-fail-chance=0       # (int   , init-time) default = '0x0'    : If >0, add a pseudorandom chance for every memory access (loads, stores, TCOMMIT) inside a transaction to cause the transaction to fail with IMP.
cluster0.tme_read-set-size=0                          # (int   , init-time) default = '0x0'    : Size of the transactional read set in bytes, rounded up to the nearest integer number of transaction granules. 0 == unlimited
cluster0.tme_support-only-guaranteed-mem-attr=0       # (bool  , init-time) default = '0'      : If true, a transactional access to memory with a type not architecturally guaranteed to be supported will cause a transaction failure with IMP=1
cluster0.tme_tcommit-fails-transactions=0             # (bool  , init-time) default = '0'      : If true, executing TCOMMIT inside a transaction will cause it to fail with IMP=1
cluster0.tme_wakeup-from-wfe-always-fails-transactions=0  # (bool  , init-time) default = '0'      : If true, waking up from a WFE will always fail the transaction, even if not required
cluster0.tme_wfe-fails-transactions=0                 # (bool  , init-time) default = '0'      : If true, executing WFE inside a transaction will cause it to fail with IMP=1
cluster0.tme_write-set-size=0                         # (int   , init-time) default = '0x0'    : Size of the transactional write set in bytes, rounded up to the nearest integer number of transaction granules. 0 == unlimited
cluster0.trace_full_simd_reg_with_nep=0               # (bool  , init-time) default = '0'      : Whether full simd register is traced even if partial update is done when FPCR.NEP=1
cluster0.trace_has_sysreg_access=1                    # (bool  , init-time) default = '1'      : ETM trace registers support access via system registers
cluster0.trace_icc_registers_as_icv_when_redirected=0  # (bool  , init-time) default = '0'      : If true, update trace with ICV, instead of ICC when ICV registers are accessed depending on the core state.
cluster0.trace_physical_registers_when_host_virtualisation_enabled=0  # (int   , init-time) default = '0x0'    : When host virtualisation is enabled, trace sysreg accesses to physical register accessed (0=disabled, 1=Trace only ELR/SPSR_EL1 as ELR/SPSR_EL2, 2=Trace all redirected registers as physical registers
cluster0.trap_dc_cmo_to_pou_if_nop=1                  # (bool  , init-time) default = '1'      : Whether traps to DC CMO operations to PoU are ignored if the same is treated as NOP.
cluster0.trap_ic_cmo_to_pou_if_nop=1                  # (bool  , init-time) default = '1'      : Whether traps to IC CMO operations to PoU are ignored if the same is treated as NOP.
cluster0.trap_reserved_group3_id_regs=0               # (bool  , init-time) default = '0'      : Whether setting HCR_EL2.TID3 traps reserved group3 id registers.
cluster0.trbe_cmod=0                                  # (int   , init-time) default = '0x0'    : TRBE Customer Modified.
cluster0.trbe_des=0                                   # (int   , init-time) default = '0x0'    : Designer, JEP106 identification code.
cluster0.trbe_external_abort_handling=0               # (int   , init-time) default = '0x0'    : Describes how the PE manages External aborts on writes made by the Trace Buffer Unit to the trace buffer. (0->External abort is reported to TRBE. From Armv9.3, the value 0 is not permitted and will be 1 if Armv9.3 is implemented. 1-> External abort is ignored. 2->The External abort generates an SError and the error is not reported to TRBE.)
cluster0.trbe_has_hardware_translation_table_update=1  # (bool  , init-time) default = '1'      : If true, address translation performed by the Trace Buffer Extension manages the Access Flag and dirty state
cluster0.trbe_implemented_version=1                   # (int   , init-time) default = '0x1'    : Trace Buffer Extension implemented version, 1: FEAT_TRBE implemented (Armv9.0).
cluster0.trbe_mpam=0                                  # (int   , init-time) default = '0x0'    : TRBE MPAM support.
cluster0.trbe_part=0                                  # (int   , init-time) default = '0x0'    : Part number.
cluster0.trbe_partid_max=0                            # (int   , init-time) default = '0x0'    : Largest permitted TRBDEVID1.PARTID value.
cluster0.trbe_pmg_max=0                               # (int   , init-time) default = '0x0'    : Largest permitted TRBDEVID1.PMG value.
cluster0.trbe_revand=0                                # (int   , init-time) default = '0x0'    : TRBE component minor revision.
cluster0.trbe_revision=0                              # (int   , init-time) default = '0x0'    : TRBE architecture revision.
cluster0.treat-dcache-cmos-to-poc-as-nop=0            # (int   , init-time) default = '0x0'    : Whether dcache maintenance operations to the point of coherency are required for instruction to data coherence. 0 - Clean/Invalidate ops required, 1 - Clean/Invalidate ops not required and cannot generate faults, 2 - Clean/Invalidate ops not required but can generate faults
cluster0.treat-dcache-cmos-to-pou-as-nop=0            # (int   , init-time) default = '0x0'    : Whether dcache invalidation to the point of unification is required for instruction to data coherence. 0 - Invalidate ops required, 1 - Invalidate ops not required and cannot generate faults, 2 - Invalidate ops not required but can generate faults
cluster0.treat-dcache-invalidate-as-clean-invalidate=0  # (bool  , init-time) default = '0'      : Treat data cache invalidate operations as clean and invalidate.
cluster0.treat-icache-cmos-to-pou-as-nop=0            # (int   , init-time) default = '0x0'    : If has_coherent_icache is true, whether instruction cache invalidation operations to PoU which are treated as NOP can generate fault. 0 - cannot generate faults, 1 - can generate faults
cluster0.treat_PAC_as_NOP=0                           # (bool  , init-time) default = '0'      : Non-architecture parameter. Treat Pointer Authentication as NOP. When the parameter is true behavour of FEAT_PAuth instructions changes as following PAC* and AUT* and XPAC* instructions are NOP. Brach, load, return with authentication instructions do not check and change signature bits and ignore FEAT_PAuth traps.
cluster0.treat_forced_normal_as_device_for_excl_atomics=0  # (bool  , init-time) default = '0'      : Whether exclusive/atomic access is supported in same manner as access to device if stage1 is Device memory and final memory attribute forced to normal by FWB
cluster0.treat_pld_as_nop=0                           # (bool  , init-time) default = '0'      : If true, treat PLD as NOP.
cluster0.treat_pli_as_nop=0                           # (bool  , init-time) default = '0'      : If true, treat PLI as NOP.
cluster0.treat_wfi_wfe_as_nop=0                       # (bool  , init-time) default = '0'      : If true, never go into wait state for WFI or WFE instructions.
cluster0.truncate_pc_on_illegal_exception_return_to_aarch32=1  # (bool  , init-time) default = '1'      : On Illegal ERET to AArch32, truncate PC to 32-bits
cluster0.undef_ccsidr2_access_for_unimplemented_aarch32=0  # (bool  , init-time) default = '0'      : Whether access to CCSIDR2 is undef if AArch32 is implemented or not at EL1
cluster0.unification-level=1                          # (int   , init-time) default = '0x1'    : Level of Unification Inner Shareable for the cache hierarchy
cluster0.unification-uniprocessor-level=1             # (int   , init-time) default = '0x1'    : Level of Unification Uniprocessor for the cache hierarchy
cluster0.unpred_brb_iall_invalid_xt_behave_as_undef=0  # (bool  , init-time) default = '0'      : If true, BRB IALL instruction will behave as UNDEFINED if Xt != 0b11111
cluster0.unpred_edscr_ns_set_unknown_bit=0            # (bool  , init-time) default = '0'      : Unknown(x) bit in NS field in EDSCR can be configure to 0 or 1.
cluster0.unpred_edscr_rw_unknown_bits_read_as_1=0     # (bool  , init-time) default = '0'      : Unknown(x) bits in RW field in EDSCR are read as 1 instead of 0.
cluster0.unpred_extdbg_unknown_bits=0                 # (int   , init-time) default = '0x0'    : Data used to fill only in UNKNOWN bit-fields of external debug registers e.g., EDPFR and EDDFR.
cluster0.unpred_load_single_reg_overlap_with_wb=0     # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviours for single load with writeback(might impact certain load pair instructions) 0 Constraint_WBSUPPRESS, 1 Constraint_UNDEF, 2 Constraint_NOP
cluster0.unpred_mrsmsr_currentlymapped_undef=0        # (bool  , init-time) default = '0'      : UNPREDICTABLE register access (accessible from current mode using different instruction) modeled as NOP when false and UNDEF when true
cluster0.unpred_mrsmsr_protfailed_undef=0             # (bool  , init-time) default = '0'      : UNPREDICTABLE register access (not accessible from current PL and security state) modeled as NOP when false and UNDEF when true
cluster0.unpred_mte_tag_read_when_ata_controls_are_zero_or_untagged_attr=0  # (bool  , init-time) default = '0'      : Constrained unpredictable for MTE tag read when ATA controls are 0 or untagged attribute. false, Read as zero. true, Permitted to generate an external abort if a read of data from the same address would generate an external abort.
cluster0.unpred_mte_tag_store_to_device_mem_as_alignment_fault=0  # (bool  , init-time) default = '0'      : Constrained unpredictable choice for MTE instructions which store tags to memory locations marked as Device. false, Storing the data, if any, to the locations. true, Generating an Alignment Fault.
cluster0.unpred_nested_virtualization_nv_behaviour=0  # (int   , init-time) default = '0x0'    : Constrained unpredictable choices for HCR_EL2.NV=0 and HCR_EL2.NV1=1 with respect to nested virtualization
                                                      #                                        :    - 0, Behave as defined in the specification as per bit values
                                                      #                                        :    - 1, Behave as if HCR_EL2.NV=1 and HCR_EL2.NV1=1 for all purpose other than reading back HCR_EL2.NV
                                                      #                                        :    - 2, Behave as if HCR_EL2.NV=0 and HCR_EL2.NV1=0 for all purpose other than reading back HCR_EL2.NV1
                                                      #                                        : 
cluster0.unpred_par_attr_returns_mair=0               # (bool  , init-time) default = '0'      : If true, PAR_EL1.ATTR represents the memory attributes as per the MAIR value instead of the ones in the descriptor.
cluster0.unpred_store_exclusive_base_overlap=0        # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviours for store exclusive when s==n. 0 Constraint_NONE, 1 Constraint_UNDEF, 2 Constraint_NOP
cluster0.unpred_store_pair_and_single_reg_overlap_with_wb=0  # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviours for pair and single store with writeback(doesn't cover store exclusive) 0 Constraint_NONE, 1 Constraint_UNDEF, 2 Constraint_NOP
cluster0.unpred_tlbi_not_in_monitor_mode=0            # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviors for AArch32 TLBI instructions executed in secure privileged mode other than Monitor mode. 0: Preferred behavior (default), 1: UNDEF, 2: NOP, 3: execute as if had been executed in Monitor mode
cluster0.unpred_tsize_aborts=0                        # (bool  , init-time) default = '0'      : Behaviour when TSize is out of range. 0, force into range. 1, translation fault, forces unpred_tsize_pamax_aborts to 1.
cluster0.unpred_tsize_pamax_aborts=0                  # (bool  , init-time) default = '0'      : Behaviour when stage 2 TSize exceeds the physical address size (or 40bits, from AArch32). 0, force into range. 1, translation fault.  Ignored if unpred_tsize_aborts is 1.
cluster0.unpred_vncr_el2_ress_mismatch=0              # (int   , init-time) default = '0x0'    : Constrained unpredictable choices when bits marked as RESS do not all have the same value for VNCR_EL2  - 0, Generating an EL2 translation regime translation abort on use of the VNCR_EL2 register
                                                      #                                        :   - 1, Reserved sign extended bits of VNCR_EL2 are same as bit[52] or bit[48] based on if large VA is supported or not, for all purposes other than reading back the register
                                                      #                                        : 
cluster0.unpred_zero_spsr_btype=1                     # (bool  , init-time) default = '1'      : Constrained unpredictable control to make SPSR_ELx.BTYPE 0 instead of PSTATE.BTYPE on synchronous exceptions other than Software Step, PC alignment fault, Instruction Abort, Breakpoint or Address Matching Vector Catch, Illegal Execution State, BRK instruction, Branch Target
cluster0.unpredictable_exclusive_abort_memtype=0      # (int   , init-time) default = '0x0'    : Cause MMU abort if exclusive access is not supported in certain memory type (0=exclusives allowed in all memory types, 1=exclusives abort in Device memory types, 2=exclusives abort in any type other than WB inner cacheable)
cluster0.unpredictable_hvc_behaviour=0                # (int   , init-time) default = '0x0'    : HVC unpredictable behaviour. 0, UNDEF. 1, NOP.
cluster0.unpredictable_smc_behaviour=0                # (int   , init-time) default = '0x0'    : SMC unpredictable behaviour. 0, UNDEF. 1, NOP.
cluster0.unpredictable_wfet_and_wfit_behaviour=1      # (int   , init-time) default = '0x1'    : WFET and WFIT unpredictable behaviour in debug state. 0, UNDEFINED. 1, NOP.
cluster0.unsupported_atomic_fault_type=0              # (int   , init-time) default = '0x0'    : Type of fault reported on unsupported atomic access. 0 = external abort if any reported by interconnect, 1 = precise unsupported atomic fault, 2 = precise external abort, 3 = imprecise external abort.
cluster0.use_Xt_as_LDG_STG_input=1                    # (bool  , init-time) default = '1'      : Use new MTE Instructions formats for LDG/ST(Z)(2)G, which use Xt as an input
cluster0.use_mte_eac_02_instructions_encoding=1       # (bool  , init-time) default = '1'      : Use new MTE Instructions encoding since MTE spec EAC 0.2 in ARMv8.5.
cluster0.use_mte_eac_08_tfsr_encoding=1               # (bool  , init-time) default = '1'      : Use new MTE TFSR_ELx encodings since MTE spec EAC 0.8 in ARMv8.5.
cluster0.use_rosetta_disass=1                         # (int   , init-time) default = '0x1'    : Use Rosetta disassembly library.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster0.use_sif_to_compute_pan=0                     # (bool  , init-time) default = '0'      : Where FEAT_PAN3 is implemented, whether SCR_EL3.SIF bit is used to determine instruction access permission for the purpose of PAN
cluster0.use_tlb_contig_hint=0                        # (bool  , init-time) default = '0'      : Translation table entries with the contiguous hint bit set generate large TLB entries.
cluster0.user_defined_rom_table_debug_power_config=   # (string, init-time) default = ''       : User defined ROM Table debug power domains for ED,CTI,PMU and TRACE, and DBGPCR configuration. The "version" field and "cores" array are mandatory. The "dbgpcr" array, if provided, must contain unique integers in the range [0, 32) describing which debug power domains have power control implemented. The "rom" and "dbgpcr" fields in objects in the "cores" array are only allowed when 'debug_rom_is_flat' is false. All power domain ID fields ("rom", "ed/pmu", "cti", "etm") must be in the range [0, 32). The "ed/pmu" field is mandatory. Example JSON for a hierarchical debug ROM layout: '{"version": 0, "dbgpcr": [0, 1], "cores":[{"dbgpcr": [1, 31], "rom": 0, "ed/pmu": 0, "cti": 31, "etm": 1}, {"ed/pmu": 0}]}'
cluster0.vpu_datapath_width=128                       # (int   , init-time) default = '0x80'   : VPU data path width
cluster0.walk_cache_latency=0                         # (int   , run-time ) default = '0x0'    : Walk cache latency for TA (Timing Annotation), expressed in simulation ticks
cluster0.warn_unpredictable_in_v7=1                   # (bool  , init-time) default = '1'      : If true, behaviour which is unpredictable in V7 yet is predictable in V8 will produce a warning
cluster0.watchpoint-log2secondary_restriction=0       # (int   , init-time) default = '0x0'    : log2 size of secondary restriction of FAR/EDWAR possible values on watchpoint hit for load/store operations.
cluster0.wfe_wakeup_delay=0                           # (int   , init-time) default = '0x0'    : Configure WFE wakeup delay in CPU cycles
cluster0.wfi_wakeup_delay=0                           # (int   , init-time) default = '0x0'    : Configure WFI wakeup delay in CPU cycles
cluster0.wnr_is_read_for_s2f_on_s1_atomic_instr_fault=0  # (bool  , init-time) default = '0'      : Whether WnR is 0 for stage2 fault on stage1 for atomic instructions
cluster0.wnr_is_read_for_s2f_on_s1_dbm_update=0       # (bool  , init-time) default = '0'      : Whether WnR is 0 for stage2 fault on stage1 descriptor dbm update
cluster0.wp_ignores_dbm_update=0                      # (bool  , init-time) default = '0'      : If true, dbm update is ignored on watchpoint hit
cluster0.wp_num_reporting=0                           # (int   , init-time) default = '0x0'    : When reporting of the watchpoint number on Watchpoint Exceptions and Debug Events is performed
                                                      #                                        :    0 - When FEAT_Debugv8p9 is implemented or otherwise required
                                                      #                                        :    1 - When FEAT_Debugv8p9 or FEAT_SME is implemented
cluster1.ADFSR-AIFSR-implemented=0                    # (bool  , init-time) default = '0'      : ADFSR and AIFSR are implemented
cluster1.AIDR=0                                       # (int   , init-time) default = '0x0'    : Value of AIDR_EL1 register.
cluster1.AMIIDR=1083                                  # (int   , init-time) default = '0x43b'  : Value of AMU Implementation Identification Register
cluster1.AMPIDR=17192169472                           # (int   , init-time) default = '0x400bbb000' : Value of AMU Peripheral Identification Register
cluster1.BPIMVA_causes_translation_lookup=0           # (bool  , init-time) default = '0'      : Do a translation when BPIMVA instruction is executed (which may cause a translation fault).
cluster1.CCSIDR-L1D_override=0                        # (int   , init-time) default = '0x0'    : If nonzero, override the value presented in CCSIDR for L1D (this is cosmetic and does not affect cache behaviour).
cluster1.CCSIDR-L1I_override=0                        # (int   , init-time) default = '0x0'    : If nonzero, override the value presented in CCSIDR for L1I (this is cosmetic and does not affect cache behaviour).
cluster1.CCSIDR-L2_override=0                         # (int   , init-time) default = '0x0'    : If nonzero, override the value presented in CCSIDR for L2 (this is cosmetic and does not affect cache behaviour).
cluster1.CCSIDR-L3_override=0                         # (int   , init-time) default = '0x0'    : If nonzero, allow L3 selection in CSSELR and present this value in CCSIDR (this is cosmetic and does not affect cache behaviour).
cluster1.CPUCFR=0                                     # (int   , init-time) default = '0x0'    : Value of CPU Configuration Register
cluster1.CTIPIDR=0                                    # (int   , init-time) default = '0x0'    : If non-zero, override the CTI Peripheral Identification Register
cluster1.CTR-L1Ip-override=0                          # (int   , init-time) default = '0x0'    : If non-zero, override the L1Ip bits in CTR/CTR_EL0 system register. This does not change the behaviour of the cache, only what is present in the CTR register.
cluster1.DBGBCR_BT_applies_RES0_before_valid_check=1  # (bool  , init-time) default = '1'      : If true, RES0 behaviour is applied to DBGBCR(_EL1).BT before checking for reserved values for this field.
cluster1.DBGPIDR=0                                    # (int   , init-time) default = '0x0'    : If non-zero, override the Debug Peripheral Identification Register
cluster1.DCRPZID_log2_block_size=4                    # (int   , init-time) default = '0x4'    : Log2 of the block size cleared by DC RPZPA instruction (as read from DCRPZID_EL1) (FEAT_RPZ).
cluster1.ERXMISC0_mask=0                              # (int   , init-time) default = '0x0'    : Write Mask for ERXMISC0 RAS Register
cluster1.GMID-log2-block-size=4                       # (int   , init-time) default = '0x4'    : Log2 of the block size accessed by STGM/LDGM/STZGM instructions
cluster1.ISV_set_to_0_for_stage2_synch_external_abort=0  # (bool  , init-time) default = '0'      : Whether ESR_EL2.ISV is set to 0 on stage 2 synchronous external aborts
cluster1.MIDR=1091555568                              # (int   , init-time) default = '0x410fd0f0' : Value of MIDR_EL1 register.
cluster1.NUM_CORES=4                                  # (int   , init-time) default = '0x4'    : Number of cores in cluster1
cluster1.PA_SIZE=40                                   # (int   , init-time) default = '0x28'   : Physical address range supported   For ARMv8.0 and ARMv8.1 this is limited to 48 bits (FEAT_LPA/FEAT_LPA3).
cluster1.PMCEID0=4294967295                           # (int   , init-time) default = '0xffffffff' :  Performance Monitor Common Event ID Reg 0 value - 64 bit
cluster1.PMCEID1=4294967295                           # (int   , init-time) default = '0xffffffff' :  Performance Monitor Common Event ID Reg 1 value - 64 bit
cluster1.PMSIDR.ArchInst=1                            # (bool  , init-time) default = '1'      : Defines whether architecture instruction sampling is implemented or not, if not only micro op sampling is implemented. Model only supports architecture instruction sampling, but allows ID register field to be configured.
cluster1.PMSIDR.LDS=0                                 # (bool  , init-time) default = '0'      : Defines whether data source for sampled load instruction is implemented or not. Model does not implement loaded data source, but allows ID register field to be configured.
cluster1.PMUPIDR=0                                    # (int   , init-time) default = '0x0'    : If non-zero, override the PMU Peripheral Identification Register
cluster1.abort_execution_from_device_memory=0         # (bool  , init-time) default = '0'      : Execution from device memory generates a prefetch abort.
cluster1.advsimd_bf16_support_level=0                 # (int   , init-time) default = '0x0'    : Implement BFloat16 operations from ARMv8.6. AArch64 Advanced SIMD and FP BFloat16 instructions are automatically enabled when has_arm_v8-6 is true.
                                                      #                                        :   - 0, Not implemented.
                                                      #                                        :   - 1, AArch64 Advanced SIMD and FP BFloat16 instructions only (FEAT_BF16).
                                                      #                                        :   - 2, AArch32 Advanced SIMD and VFP BFloat16 instructions only (FEAT_AA32BF16).
                                                      #                                        :   - 3, Both AArch64 Advanced SIMD and FP and AArch32 Advanced SIMD and VFP BFloat16 instructions.
cluster1.advsimd_i8mm_support_level=0                 # (int   , init-time) default = '0x0'    : Implement Int8 matrix multiply operations from ARMv8.6. AArch64 Advanced SIMD and FP Int8 matrix multiply instructions are automatically enabled when has_arm_v8-6 is true.
                                                      #                                        :   - 0, Not implemented.
                                                      #                                        :   - 1, AArch64 Advanced SIMD and FP Int8 matrix multiply instructions only (FEAT_I8MM).
                                                      #                                        :   - 2, AArch32 Advanced SIMD and VFP Int8 matrix multiply instructions only (FEAT_AA32I8MM).
                                                      #                                        :   - 3, Both AArch64 Advanced SIMD and FP and AArch32 Advanced SIMD and VFP Int8 matrix multiply instructions (FEAT_I8MM, FEAT_AA32I8MM).
cluster1.advsimd_overread=0                           # (bool  , init-time) default = '0'      : AdvSIMD element load operations access all bytes of a 16-byte aligned window, even in Device memory
cluster1.align_pc_on_branch_to_unaligned_pc_aarch32=0  # (bool  , init-time) default = '0'      : Force PC align for branches to an unaligned PC counter in A32 state
cluster1.align_pc_on_debug_exit_to_aarch32=0          # (bool  , init-time) default = '0'      : Exit to AARCH32 state from debug state forces pc bit0 to 0
cluster1.align_pc_on_illegal_exception_return_to_aarch32=1  # (bool  , init-time) default = '1'      : Align PC when performing an illegal exception return from AArch64 to AArch32.
cluster1.amair_reg_rw_mask=0                          # (int   , init-time) default = '0x0'    : RW mask for implementation-defined registers.
cluster1.amu_aux_type_fixed=                          # (string, init-time) default = ''       : Lists which AMU auxiliary registers that are fixed and to which event type. The JSON schema is: {fixed_aux_reg:evt_type, ...}. For example {"0":0x300} would make auxiliary register 0 fixed to event type 0x300
cluster1.amu_aux_voffset_mask=0                       # (int   , init-time) default = '0x0'    : If ARMv8.6 is implemented, each bit of the field, 0 to 15, when 1 indicates that the corresponding virtual offset register, AMEVCNTVOFF1<n>_EL2, is implemented
cluster1.amu_has_external_interface=0                 # (int   , init-time) default = '0x0'    : Implement external memory-mapped access to system register of activity monitor unit from ARMv8.4.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.amu_has_sysreg_interface=1                   # (bool  , init-time) default = '1'      : Implement system register access to activity monitor unit from ARMv8.4.
cluster1.amu_mmap_address=                            # (string, init-time) default = ''       : AMU base address for each core on system bus. 0 means the AMU is not mapped, otherwise the address must be 4KB aligned. JSON schema for the parameter value is: {"format":"all_addrs_are_absolute_wrt_systembus","cores": [{"amu":0x0},{"amu":0x0},{"amu":0x0},{"amu":0x0}]}
cluster1.amu_num_auxiliary_counters=0                 # (int   , init-time) default = '0x0'    : Number of AMU auxiliary counters implemented
cluster1.amu_reset_domain=0                           # (int   , init-time) default = '0x0'    : Reset domain for activity monitor unit. 0, COLD_RESET. 1, WARM_RESET. 2, NONE.
cluster1.amu_version=1                                # (int   , init-time) default = '0x1'    : Selects the activity monitor version implemented   - 1, AMUv1 for Armv8.4 is implemented.
                                                      #                                        :    - 2, AMUv1 for Armv8.6 is implemented (FEAT_AMUv1p1).
cluster1.apsr_read_restrict=0                         # (bool  , init-time) default = '0'      : At EL0, unknown bits of APSR are RAZ.
cluster1.arm_v8_7_accelerator_support_level=0         # (int   , init-time) default = '0x0'    : Implements Armv8.7 accelerator support instructions LD/ST64B, ST64BV, ST64BV0, etc. (FEAT_LS64, FEAT_LS64_V, FEAT_LS64_ACCDATA)
cluster1.atomic_fault_priority_s1=0                   # (int   , init-time) default = '0x0'    : This parameter describes the priority of unsupported atomic hardware update fault w.r.t alignment and permission fault at stage1. 0, BEFORE_ALIGN_MEM_FAULT. 1, AFTER_ALIGN_BEFORE_PERM_FAULT. 2, AFTER_PERM_FAULT.
cluster1.atomic_fault_priority_s2=0                   # (int   , init-time) default = '0x0'    : This parameter describes the priority of unsupported atomic hardware update fault w.r.t alignment and permission fault at stage2. 0, BEFORE_ALIGN_MEM_FAULT. 1, AFTER_ALIGN_BEFORE_PERM_FAULT. 2, AFTER_PERM_FAULT.
cluster1.atomic_fault_priority_s2_on_s1=0             # (int   , init-time) default = '0x0'    : This parameter describes the priority of unsupported atomic hardware update fault w.r.t alignment and permission fault for stage2 on stage1. 0, BEFORE_ALIGN_MEM_FAULT. 1, AFTER_ALIGN_BEFORE_PERM_FAULT. 2, AFTER_PERM_FAULT.
cluster1.auxilliary_feature_register0=0               # (int   , init-time) default = '0x0'    : Value of AFR0 ID register.
cluster1.branch-predictor-clear-policy=2              # (int   , init-time) default = '0x2'    : Set branch prediction policy as defined for MMFR1[31:28].  This does not change the behaviour of the branch predictor, only what is reported in MMFR1.BPred.
cluster1.branch-predictor-supported-ops=1             # (int   , init-time) default = '0x1'    : Set branch prediction policy as defined for MMFR3[11:8].  This does not change the behaviour of the branch predictor, only what is reported in MMFR3.BPMaint.
cluster1.brbe_log2_num_records=6                      # (int   , init-time) default = '0x6'    : Log2 of number of BRB records supported. 3 -> 8 records, ... 6 -> 64 records.
cluster1.cache-log2linelen=6                          # (int   , init-time) default = '0x6'    : Log2 of the cache line length in bytes.
cluster1.cache_maintenance_hits_watchpoints=0         # (bool  , init-time) default = '0'      : DCIMVA operations executed in AArch32 modes hit watchpoints.
cluster1.changing_block_size_without_bbm_support=0    # (int   , init-time) default = '0x0'    : Level of support for changing block size without break-before-make (FEAT_BBM).
cluster1.check_memory_attributes=1                    # (bool  , init-time) default = '1'      : Detect and report TLB use of conflicting memory attributes for views of the same physical address
cluster1.clear_IT_when_IL_set=0                       # (bool  , init-time) default = '0'      : Clear IT bits when performing a *legal* exception return to AArch32 when IL is set
cluster1.clear_IT_when_IL_set_explicitly=0            # (bool  , init-time) default = '0'      : Apart from clear_IT_when_IL_set, also clear IT bits when loading CPSR from SPSR/memory and IL == 1 in the value being loaded.
cluster1.clear_ec_in_debug_state=0                    # (bool  , init-time) default = '0'      : When ARMv8.8 debug extension is implemented, whether EDESR.EC bit is set/cleared on entering debug state due to pending exception catch caused by EDESR.EC=1.
cluster1.clear_reg_top_eret=1                         # (int   , init-time) default = '0x1'    : Behaviour of the upper 32-bits of the Xn registers when changing between AArch32 state and AArch64 state.  0, upper 32-bits preserved for all registers.  1, upper 32-bits set to 0 for all accessible registers. 2,  upper 32-bits set to 0 for a random selection of accessible registers. 3, upper-32-bits set to 0 for registers touched in AArch32
cluster1.clear_reg_top_set=1                          # (bool  , init-time) default = '1'      : Whether to clear upper 32-bits of the Xn register when corresponding AArch32 register is set via CADI/Iris.
cluster1.configure_v8_6_pmu_events_with_json=         # (string, init-time) default = ''       : Configure v8.6 PMU events. Note : This param has high priority and overrides the setting of "has_v8_6_pmu_events"(Will be deprecated in the future releases) if both the params are provided. JSON schema for the parameter value is e.g. 1. {"all":false} 2. {"pmu_events":["BR_INDNR_RETIRED","BR_IND_RETIRED","BR_RETURN_SKIP_RETIRED","BR_RETURN_ANY_RETIRED","BR_INDNR_SKIP_RETIRED","BR_INDNR_TAKEN_RETIRED","BR_IND_SKIP_RETIRED","BR_IND_TAKEN_RETIRED","BR_IMMED_SKIP_RETIRED","BR_IMMED_TAKEN_RETIRED","BR_SKIP_RETIRED"]}
cluster1.configure_v8_8_pmu_events_with_json=         # (string, init-time) default = ''       : Configure v8.8 PMU events. Note : This param has high priority and overrides the setting of "has_v8_8_pmu_events"(Will be deprecated in the future releases) if both the params are provided. JSON schema for the parameter value is e.g. 1. {"all":false} 2. {"pmu_events":["BR_HINT_COND_RETIRED","BR_COND_TAKEN_RETIRED","BR_UNCOND_RETIRED","BR_COND_RETIRED","BRNL_TAKEN_RETIRED","BRNL_IND_TAKEN_RETIRED","BRNL_INDNR_TAKEN_RETIRED","BRNL_IMMED_TAKEN_RETIRED","BL_TAKEN_RETIRED","BL_IND_TAKEN_RETIRED","BL_IMMED_TAKEN_RETIRED"]}
cluster1.cpacr_trcdis_behaviour=2                     # (int   , init-time) default = '0x2'    : Behaviour of CPACR.TRCDIS/NSACR.NSTRCDIS when there is no CP14 ETM interface. 0, RAZ/WI. 2, implemented.
cluster1.cpi_div=1                                    # (int   , run-time ) default = '0x1'    : Divider for calculating CPI (Cycles Per Instruction)
cluster1.cpi_mul=1                                    # (int   , run-time ) default = '0x1'    : Multiplier for calculating CPI (Cycles Per Instruction)
cluster1.cpu0.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster1.cpu0.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster1.cpu0.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster1.cpu0.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster1.cpu0.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster1.cpu0.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster1.cpu0.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster1.cpu0.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster1.cpu0.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster1.cpu0.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster1.cpu0.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster1.cpu0.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster1.cpu0.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster1.cpu0.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster1.cpu0.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster1.cpu0.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu0.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu0.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster1.cpu0.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster1.cpu0.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster1.cpu0.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu0.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu0.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu0.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu0.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster1.cpu0.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster1.cpu0.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster1.cpu0.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster1.cpu0.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster1.cpu0.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster1.cpu0.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster1.cpu0.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster1.cpu0.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster1.cpu0.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster1.cpu0.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster1.cpu0.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster1.cpu0.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster1.cpu0.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster1.cpu0.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster1.cpu0.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster1.cpu0.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster1.cpu0.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster1.cpu0.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster1.cpu0.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster1.cpu0.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster1.cpu0.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster1.cpu0.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster1.cpu0.semihosting-heap_limit=4278190080       # (int   , init-time) default = '0xff000000' : Virtual address of top of heap.
cluster1.cpu0.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster1.cpu0.semihosting-stack_base=4294901760       # (int   , init-time) default = '0xffff0000' : Virtual address of base of descending stack.
cluster1.cpu0.semihosting-stack_limit=4278190080      # (int   , init-time) default = '0xff000000' : Virtual address of stack limit.
cluster1.cpu0.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster1.cpu0.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster1.cpu0.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster1.cpu0.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster1.cpu0.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster1.cpu0.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster1.cpu0.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster1.cpu0.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster1.cpu0.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster1.cpu0.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster1.cpu0.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu0.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu1.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster1.cpu1.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster1.cpu1.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster1.cpu1.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster1.cpu1.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster1.cpu1.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster1.cpu1.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster1.cpu1.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster1.cpu1.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster1.cpu1.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster1.cpu1.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster1.cpu1.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster1.cpu1.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster1.cpu1.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster1.cpu1.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster1.cpu1.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu1.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu1.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster1.cpu1.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster1.cpu1.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster1.cpu1.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu1.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu1.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu1.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu1.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster1.cpu1.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster1.cpu1.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster1.cpu1.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster1.cpu1.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster1.cpu1.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster1.cpu1.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster1.cpu1.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster1.cpu1.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster1.cpu1.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster1.cpu1.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster1.cpu1.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster1.cpu1.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster1.cpu1.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster1.cpu1.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster1.cpu1.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster1.cpu1.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster1.cpu1.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster1.cpu1.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster1.cpu1.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster1.cpu1.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster1.cpu1.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster1.cpu1.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster1.cpu1.semihosting-heap_limit=4278190080       # (int   , init-time) default = '0xff000000' : Virtual address of top of heap.
cluster1.cpu1.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster1.cpu1.semihosting-stack_base=4294901760       # (int   , init-time) default = '0xffff0000' : Virtual address of base of descending stack.
cluster1.cpu1.semihosting-stack_limit=4278190080      # (int   , init-time) default = '0xff000000' : Virtual address of stack limit.
cluster1.cpu1.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster1.cpu1.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster1.cpu1.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster1.cpu1.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster1.cpu1.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster1.cpu1.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster1.cpu1.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster1.cpu1.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster1.cpu1.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster1.cpu1.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster1.cpu1.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu1.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu2.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster1.cpu2.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster1.cpu2.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster1.cpu2.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster1.cpu2.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster1.cpu2.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster1.cpu2.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster1.cpu2.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster1.cpu2.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster1.cpu2.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster1.cpu2.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster1.cpu2.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster1.cpu2.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster1.cpu2.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster1.cpu2.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster1.cpu2.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu2.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu2.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster1.cpu2.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster1.cpu2.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster1.cpu2.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu2.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu2.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu2.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu2.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster1.cpu2.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster1.cpu2.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster1.cpu2.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster1.cpu2.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster1.cpu2.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster1.cpu2.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster1.cpu2.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster1.cpu2.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster1.cpu2.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster1.cpu2.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster1.cpu2.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster1.cpu2.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster1.cpu2.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster1.cpu2.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster1.cpu2.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster1.cpu2.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster1.cpu2.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster1.cpu2.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster1.cpu2.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster1.cpu2.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster1.cpu2.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster1.cpu2.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster1.cpu2.semihosting-heap_limit=4278190080       # (int   , init-time) default = '0xff000000' : Virtual address of top of heap.
cluster1.cpu2.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster1.cpu2.semihosting-stack_base=4294901760       # (int   , init-time) default = '0xffff0000' : Virtual address of base of descending stack.
cluster1.cpu2.semihosting-stack_limit=4278190080      # (int   , init-time) default = '0xff000000' : Virtual address of stack limit.
cluster1.cpu2.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster1.cpu2.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster1.cpu2.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster1.cpu2.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster1.cpu2.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster1.cpu2.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster1.cpu2.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster1.cpu2.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster1.cpu2.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster1.cpu2.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster1.cpu2.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu2.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu3.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster1.cpu3.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster1.cpu3.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster1.cpu3.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster1.cpu3.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster1.cpu3.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster1.cpu3.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster1.cpu3.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster1.cpu3.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster1.cpu3.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster1.cpu3.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster1.cpu3.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster1.cpu3.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster1.cpu3.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster1.cpu3.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster1.cpu3.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu3.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu3.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster1.cpu3.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster1.cpu3.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster1.cpu3.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu3.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu3.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu3.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu3.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster1.cpu3.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster1.cpu3.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster1.cpu3.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster1.cpu3.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster1.cpu3.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster1.cpu3.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster1.cpu3.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster1.cpu3.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster1.cpu3.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster1.cpu3.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster1.cpu3.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster1.cpu3.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster1.cpu3.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster1.cpu3.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster1.cpu3.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster1.cpu3.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster1.cpu3.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster1.cpu3.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster1.cpu3.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster1.cpu3.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster1.cpu3.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster1.cpu3.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster1.cpu3.semihosting-heap_limit=4278190080       # (int   , init-time) default = '0xff000000' : Virtual address of top of heap.
cluster1.cpu3.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster1.cpu3.semihosting-stack_base=4294901760       # (int   , init-time) default = '0xffff0000' : Virtual address of base of descending stack.
cluster1.cpu3.semihosting-stack_limit=4278190080      # (int   , init-time) default = '0xff000000' : Virtual address of stack limit.
cluster1.cpu3.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster1.cpu3.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster1.cpu3.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster1.cpu3.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster1.cpu3.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster1.cpu3.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster1.cpu3.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster1.cpu3.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster1.cpu3.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster1.cpu3.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster1.cpu3.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu3.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu4.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster1.cpu4.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster1.cpu4.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster1.cpu4.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster1.cpu4.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster1.cpu4.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster1.cpu4.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster1.cpu4.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster1.cpu4.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster1.cpu4.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster1.cpu4.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster1.cpu4.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster1.cpu4.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster1.cpu4.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster1.cpu4.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster1.cpu4.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu4.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu4.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster1.cpu4.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster1.cpu4.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster1.cpu4.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu4.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu4.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu4.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu4.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster1.cpu4.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster1.cpu4.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster1.cpu4.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster1.cpu4.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster1.cpu4.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster1.cpu4.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster1.cpu4.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster1.cpu4.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster1.cpu4.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster1.cpu4.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster1.cpu4.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster1.cpu4.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster1.cpu4.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster1.cpu4.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster1.cpu4.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster1.cpu4.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster1.cpu4.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster1.cpu4.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster1.cpu4.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster1.cpu4.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster1.cpu4.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster1.cpu4.semihosting-enable=1                    # (bool  , init-time) default = '1'      : Enable semihosting SVC/HLT traps.
cluster1.cpu4.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster1.cpu4.semihosting-heap_limit=251658240        # (int   , init-time) default = '0xf000000' : Virtual address of top of heap.
cluster1.cpu4.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster1.cpu4.semihosting-stack_base=268435456        # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cluster1.cpu4.semihosting-stack_limit=251658240       # (int   , init-time) default = '0xf000000' : Virtual address of stack limit.
cluster1.cpu4.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster1.cpu4.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster1.cpu4.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster1.cpu4.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster1.cpu4.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster1.cpu4.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster1.cpu4.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster1.cpu4.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster1.cpu4.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster1.cpu4.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster1.cpu4.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu4.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu5.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster1.cpu5.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster1.cpu5.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster1.cpu5.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster1.cpu5.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster1.cpu5.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster1.cpu5.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster1.cpu5.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster1.cpu5.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster1.cpu5.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster1.cpu5.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster1.cpu5.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster1.cpu5.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster1.cpu5.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster1.cpu5.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster1.cpu5.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu5.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu5.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster1.cpu5.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster1.cpu5.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster1.cpu5.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu5.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu5.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu5.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu5.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster1.cpu5.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster1.cpu5.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster1.cpu5.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster1.cpu5.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster1.cpu5.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster1.cpu5.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster1.cpu5.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster1.cpu5.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster1.cpu5.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster1.cpu5.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster1.cpu5.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster1.cpu5.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster1.cpu5.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster1.cpu5.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster1.cpu5.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster1.cpu5.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster1.cpu5.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster1.cpu5.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster1.cpu5.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster1.cpu5.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster1.cpu5.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster1.cpu5.semihosting-enable=1                    # (bool  , init-time) default = '1'      : Enable semihosting SVC/HLT traps.
cluster1.cpu5.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster1.cpu5.semihosting-heap_limit=251658240        # (int   , init-time) default = '0xf000000' : Virtual address of top of heap.
cluster1.cpu5.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster1.cpu5.semihosting-stack_base=268435456        # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cluster1.cpu5.semihosting-stack_limit=251658240       # (int   , init-time) default = '0xf000000' : Virtual address of stack limit.
cluster1.cpu5.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster1.cpu5.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster1.cpu5.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster1.cpu5.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster1.cpu5.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster1.cpu5.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster1.cpu5.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster1.cpu5.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster1.cpu5.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster1.cpu5.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster1.cpu5.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu5.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu6.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster1.cpu6.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster1.cpu6.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster1.cpu6.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster1.cpu6.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster1.cpu6.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster1.cpu6.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster1.cpu6.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster1.cpu6.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster1.cpu6.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster1.cpu6.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster1.cpu6.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster1.cpu6.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster1.cpu6.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster1.cpu6.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster1.cpu6.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu6.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu6.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster1.cpu6.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster1.cpu6.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster1.cpu6.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu6.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu6.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu6.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu6.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster1.cpu6.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster1.cpu6.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster1.cpu6.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster1.cpu6.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster1.cpu6.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster1.cpu6.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster1.cpu6.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster1.cpu6.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster1.cpu6.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster1.cpu6.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster1.cpu6.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster1.cpu6.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster1.cpu6.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster1.cpu6.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster1.cpu6.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster1.cpu6.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster1.cpu6.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster1.cpu6.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster1.cpu6.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster1.cpu6.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster1.cpu6.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster1.cpu6.semihosting-enable=1                    # (bool  , init-time) default = '1'      : Enable semihosting SVC/HLT traps.
cluster1.cpu6.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster1.cpu6.semihosting-heap_limit=251658240        # (int   , init-time) default = '0xf000000' : Virtual address of top of heap.
cluster1.cpu6.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster1.cpu6.semihosting-stack_base=268435456        # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cluster1.cpu6.semihosting-stack_limit=251658240       # (int   , init-time) default = '0xf000000' : Virtual address of stack limit.
cluster1.cpu6.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster1.cpu6.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster1.cpu6.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster1.cpu6.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster1.cpu6.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster1.cpu6.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster1.cpu6.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster1.cpu6.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster1.cpu6.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster1.cpu6.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster1.cpu6.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu6.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu7.CFGEND=0                                # (bool  , init-time) default = '0'      : Endianness configuration at reset.  0, little endian. 1, big endian.
cluster1.cpu7.CONFIG64=1                              # (bool  , init-time) default = '1'      : Register width configuration at reset. 0, AArch32. 1, AArch64.
cluster1.cpu7.CP15SDISABLE=0                          # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers
cluster1.cpu7.CP15SDISABLE2=0                         # (bool  , init-time) default = '0'      : Initialize to disable access to some CP15 registers (FEAT_CP15SDISABLE2).
cluster1.cpu7.CRYPTODISABLE=0                         # (bool  , init-time) default = '0'      : Disable cryptographic features.
cluster1.cpu7.DCZID-log2-block-size=8                 # (int   , init-time) default = '0x8'    : Log2 of the block size cleared by DC ZVA instruction (as read from DCZID_EL0).
cluster1.cpu7.DCZVA_single_write=0                    # (bool  , init-time) default = '0'      : Execute the DCZVA as a single write
cluster1.cpu7.MPIDR-override=0                        # (int   , init-time) default = '0x0'    : Override of MPIDR value.  If nonzero will override the MT, cluster and CPU ID bits in MPIDR.
cluster1.cpu7.RVBAR=0                                 # (int   , init-time) default = '0x0'    : Value of RVBAR_ELx register.
cluster1.cpu7.RVBAR32=0                               # (int   , init-time) default = '0x0'    : Reset vector address in AARCH32 when VINITHI is not set and ignore_rvbar_in_aarch32 is set
cluster1.cpu7.SMPnAMP=1                               # (bool  , init-time) default = '1'      : Enable broadcast messages necessary for correct SMP operation at reset.
cluster1.cpu7.TEINIT=0                                # (bool  , init-time) default = '0'      : Instruction set state when resetting into AArch32.  0, A32. 1, T32.
cluster1.cpu7.VINITHI=0                               # (bool  , init-time) default = '0'      : Reset value of SCTLR.V.
cluster1.cpu7.aarch32_reset_from_impdef_addr=1        # (bool  , init-time) default = '1'      : If PE resets into AArch32, Whether execution starts from IMPDEF address or hi/low vector
cluster1.cpu7.ase-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has been built with NEON support
cluster1.cpu7.clock_divider=1                         # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu7.clock_multiplier=1                      # (int   , run-time ) default = '0x1'    : Clock divider ratio for asymmetric MP clocking.
cluster1.cpu7.crypto_aes=2                            # (int   , init-time) default = '0x2'    : AES instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 2, AES and PMULL instructions implemented (FEAT_AES, FEAT_PMULL).
cluster1.cpu7.crypto_sha1=1                           # (int   , init-time) default = '0x1'    : SHA-1 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA1 instructions implemented (FEAT_SHA1).
cluster1.cpu7.crypto_sha256=1                         # (int   , init-time) default = '0x1'    : SHA-256 instructions supported (requires CryptoPlugin to be loaded). 0, not implemented. 1, SHA256 instructions implemented (FEAT_SHA256).
cluster1.cpu7.crypto_sha3=0                           # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu7.crypto_sha512=0                         # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SHA-512 instructions (requires CryptoPlugin to be loaded) (FEAT_SHA512).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu7.crypto_sm3=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-3 instructions (requires CryptoPlugin to be loaded) (FEAT_SM3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu7.crypto_sm4=0                            # (int   , init-time) default = '0x0'    : Implement ARMv8.4 SM-4 instructions (requires CryptoPlugin to be loaded) (FEAT_SM4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.cpu7.cti-intack_mask=1                       # (int   , init-time) default = '0x1'    : Set bits represent that the corresponding trigger requires software acknowledge via CTIINTACK
cluster1.cpu7.cti-number_of_claim_bits=0              # (int   , init-time) default = '0x0'    : Number of implemented bits in CTICLAIMSET
cluster1.cpu7.cti-number_of_triggers=8                # (int   , init-time) default = '0x8'    : Number of cti event triggers (default: 8, valid values: {3, 8-32})
cluster1.cpu7.enable_crc32=0                          # (int   , init-time) default = '0x0'    : CRC32 instructions supported. 0, not implemented. 1, CRC32 instructions implemented (FEAT_CRC32).
cluster1.cpu7.enable_trace_special_hlt_imm16=0        # (bool  , init-time) default = '0'      : Enable usage of parameter trace_special_hlt_imm16
cluster1.cpu7.etm-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has ETM support
cluster1.cpu7.force-fpsid=0                           # (bool  , init-time) default = '0'      : Override the FPSID value
cluster1.cpu7.force-fpsid-value=0                     # (int   , init-time) default = '0x0'    : Value to override the FPSID value to
cluster1.cpu7.has_hcptr_tase=1                        # (bool  , init-time) default = '1'      : If false, HCPTR.TASE is RES0
cluster1.cpu7.max_code_cache_mb=256                   # (int   , init-time) default = '0x100'  : Maximum size of the simulation code cache (MiB). For platforms with more than 2 cores this limit will be scaled down. (e.g 1/8 for 16 or more cores)
cluster1.cpu7.min_sync_level=0                        # (int   , run-time ) default = '0x0'    : Force minimum syncLevel (0=off=default,1=syncState,2=postInsnIO,3=postInsnAll)
cluster1.cpu7.number-of-breakpoints=16                # (int   , init-time) default = '0x10'   : Number of breakpoints.
cluster1.cpu7.number-of-context-breakpoints=16        # (int   , init-time) default = '0x10'   : Number of breakpoints that are context aware.
cluster1.cpu7.number-of-watchpoints=16                # (int   , init-time) default = '0x10'   : Number of watchpoints.
cluster1.cpu7.operation_bandwidth=1                   # (int   , init-time) default = '0x1'    : Operation width for ARMv8.4 PMU extension
cluster1.cpu7.semihosting-A32_HLT=61440               # (int   , init-time) default = '0xf000' : A32 HLT number for semihosting calls.
cluster1.cpu7.semihosting-A64_HLT=61440               # (int   , init-time) default = '0xf000' : A64 HLT number for semihosting calls.
cluster1.cpu7.semihosting-ARM_SVC=1193046             # (int   , init-time) default = '0x123456' : A32 SVC number for semihosting calls.
cluster1.cpu7.semihosting-T32_HLT=60                  # (int   , init-time) default = '0x3c'   : T32 HLT number for semihosting calls.
cluster1.cpu7.semihosting-Thumb_SVC=171               # (int   , init-time) default = '0xab'   : T32 SVC number for semihosting calls.
cluster1.cpu7.semihosting-cmd_line=                   # (string, init-time) default = ''       : Command line available to semihosting calls.
cluster1.cpu7.semihosting-cwd=                        # (string, init-time) default = ''       : Base directory for semihosting file access.
cluster1.cpu7.semihosting-enable=1                    # (bool  , init-time) default = '1'      : Enable semihosting SVC/HLT traps.
cluster1.cpu7.semihosting-heap_base=0                 # (int   , init-time) default = '0x0'    : Virtual address of heap base.
cluster1.cpu7.semihosting-heap_limit=251658240        # (int   , init-time) default = '0xf000000' : Virtual address of top of heap.
cluster1.cpu7.semihosting-prefix=0                    # (bool  , init-time) default = '0'      : Prefix semihosting output with target instance name
cluster1.cpu7.semihosting-stack_base=268435456        # (int   , init-time) default = '0x10000000' : Virtual address of base of descending stack.
cluster1.cpu7.semihosting-stack_limit=251658240       # (int   , init-time) default = '0xf000000' : Virtual address of stack limit.
cluster1.cpu7.semihosting-stderr_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stderr
cluster1.cpu7.semihosting-stdin_istty=1               # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdin
cluster1.cpu7.semihosting-stdout_istty=1              # (bool  , init-time) default = '1'      : Result for semihost istty call when argument is stdout
cluster1.cpu7.semihosting-use_stderr=0                # (bool  , init-time) default = '0'      : Send stderr from the simulated process to host stderr
cluster1.cpu7.trace_special_hlt_imm16=61440           # (int   , init-time) default = '0xf000' : For this HLT number, IF enable_trace_special_hlt_imm16=true, skip performing usual HLT execution but call MTI trace if registered
cluster1.cpu7.unpredictable_WPMASKANDBAS=1            # (int   , init-time) default = '0x1'    : Constrained unpredictable handling of watchpoints when mask and BAS fields specified. 0, IGNOREMASK. 1, IGNOREBAS (default). 2, REPEATBAS8. 3, REPEATBAS.
cluster1.cpu7.vfp-enable_at_reset=0                   # (bool  , init-time) default = '0'      : Enable VFP in CPACR, CPPWR, NSACR at reset. Warning: Arm recommends going through the implementation's suggested VFP power-up sequence!
cluster1.cpu7.vfp-present=1                           # (bool  , init-time) default = '1'      : Set whether the model has VFP support
cluster1.cpu7.vfp-traps=1                             # (bool  , init-time) default = '1'      : Implement support for trapping floating-point exceptions
cluster1.cpu7.vfp-traps-show-all=0                    # (bool  , init-time) default = '0'      : Report all trapped floating-point exceptions in the syndrome when a combination occurs.
cluster1.cpu7.wfet_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFET early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpu7.wfit_early_or_delayed_timeout=0         # (int   , init-time) default = '0x0'    : WFIT early or delayed timeout beyond the threshold value of CNTVCT_EL0 in percentage.
cluster1.cpuselr_el3_sync_immediate=1                 # (bool  , init-time) default = '1'      : Adjust when the patching selection register synchronises - either immediately (true - default), or awaiting for barrier event
cluster1.cpy_mops_option=0                            # (int   , init-time) default = '0x0'    : Set option for Armv8.8 CPY(FEAT_MOPS). 0, use default(i.e. use value configured through has_mops_option). 1, implemented using Option A. 2, implemented using Option B
cluster1.cpyf_mops_option=0                           # (int   , init-time) default = '0x0'    : Set option for Armv8.8 CPYF(FEAT_MOPS). 0, use default(i.e. use value configured through has_mops_option). 1, implemented using Option A. 2, implemented using Option B
cluster1.dbg-bcr-reserved-behavior=1                  # (int   , init-time) default = '0x1'    : This is the behavior of the reserved values of the BT field in DBGBCRPossible values are:  - 0 = Disabled.
                                                      #                                        :   - 1 = BT[2] is ignored.
                                                      #                                        : 
cluster1.dbg_rom_dap_addr=0                           # (int   , init-time) default = '0x0'    : Debug ROM dap base address.
cluster1.dbgitr_buffer_size=0                         # (int   , init-time) default = '0x0'    : Number of instructions which can be buffered before EDSCR.ITE is cleared
cluster1.dbgxvr_ress_is_stateful=0                    # (bool  , init-time) default = '0'      : Whether DBGWVR/DBGBVR.RESS returns last written value. if set to false, RESS returns sign extended value
cluster1.dc_fault_unaligned_s1_device_s2_fwb=0        # (bool  , init-time) default = '0'      : Whether takes an Alignment Fault caused by the memory type on a DC {ZVA,GZVA,GVA} if the stage 1 memory type is any Device memory type
cluster1.dcache-hit_latency=0                         # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when dcache-state_modelled=true.
cluster1.dcache-maintenance_latency=0                 # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when dcache-state_modelled=true.
cluster1.dcache-miss_latency=0                        # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when dcache-state_modelled=true.
cluster1.dcache-prefetch_enabled=0                    # (bool  , init-time) default = '0'      : Enable simulation of data cache prefetching.  This is only used when dcache-state_modelled=true
cluster1.dcache-read_access_latency=0                 # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for read accesses given in ticks per access (of size dcache-read_bus_width_in_bytes).  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if dcache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when dcache-state_modelled=true.
cluster1.dcache-read_bus_width_in_bytes=8             # (int   , init-time) default = '0x8'    : L1 D-Cache read bus width in bytes used to calculate per-access timing annotations
cluster1.dcache-read_latency=0                        # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for read accesses given in ticks per byte accessed.dcache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when dcache-state_modelled=true.
cluster1.dcache-size=32768                            # (int   , init-time) default = '0x8000' : L1 D-Cache size in bytes.
cluster1.dcache-snoop_data_transfer_latency=0         # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for received snoop accesses that perform a data transfer given in ticks per byte accessed. This is only used when dcache-state_modelled=true.
cluster1.dcache-ways=2                                # (int   , init-time) default = '0x2'    : L1 D-Cache number of ways (sets are implicit from size).
cluster1.dcache-write_access_latency=0                # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for write accesses given in ticks per access (of size dcache-write_bus_width_in_bytes). If this parameter is non-zero, per-access latencies will be used instead of per-byte even if dcache-write_latency is set. This is only used when dcache-state_modelled=true.
cluster1.dcache-write_bus_width_in_bytes=8            # (int   , init-time) default = '0x8'    : L1 D-Cache write bus width in bytes used to calculate per-access timing annotations
cluster1.dcache-write_latency=0                       # (int   , run-time ) default = '0x0'    : L1 D-Cache timing annotation latency for write accesses given in ticks per byte accessed. dcache-write_access_latency must be set to 0 for per-byte latencies to be applied. This is only used when dcache-state_modelled=true.
cluster1.dcimva_requires_s2_write_permissions=0       # (bool  , init-time) default = '0'      : Data-cache invalidate by MVA operations require stage 2 write permission (virtualised AArch32 guest).
cluster1.dczva_reports_lowest_addr_on_tag_check_fail=0  # (bool  , init-time) default = '0'      : Whether DC ZVA reports lowest address in FAR on tag check fail
cluster1.dczva_wp_far_behaviour=0                     # (int   , init-time) default = '0x0'    : Set option for address stored in FAR/EDWARD after watchpoints hit by DC ZVA.
                                                      #                                        :  0 - FAR recorded matches lowest watchpointed address accessed by the instruction
                                                      #                                        :  1 - FAR recorded matches lowest address accessed by the instruction within same translation granule as watchpointed address
                                                      #                                        :  2 - FAR recorded matches highest address accessed by the instruction within same translation granule as watchpointed address
cluster1.debug_auth_signals_sampled_at_reset=0        # (bool  , init-time) default = '0'      : Debug authentication signals can be configured as either sampled at reset only or at any time for External Root Debug.
cluster1.debug_components_dap_address=                # (string, init-time) default = ''       : Debug components ROM,ED,CTI,PMU,TRACE and TRBU base address for each core on debug bus. The "rom" field in the "cores" array are only allowed when 'debug_rom_is_flat' is false. JSON schema for the parameter value is: {"format":"all_addrs_are_absolute_wrt_debugbus","cores": [{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0}]}
cluster1.debug_components_mmap_address=               # (string, init-time) default = ''       : Debug components ROM,ED,CTI,PMU,TRACE and TRBU base address for each core on system bus. The "rom" field in the "cores" array are only allowed when 'debug_rom_is_flat' is false. JSON schema for the parameter value is: {"format":"all_addrs_are_absolute_wrt_systembus","cores": [{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0},{"rom":0x0,"ed":0x0,"cti":0x0,"pmu":0x0,"etm":0x0,"trbu":0x0}]}
cluster1.debug_entry_is_context_sync=0                # (bool  , init-time) default = '0'      : If true, Entry in debug state is Context sync. Exiting debug state is a context synchronising operation, but entering is not. However some cpu implementation can consider also the Entry in Debug state as a CSE
cluster1.debug_rom_is_class_9=0                       # (bool  , init-time) default = '0'      : If true, present a debug ROM table as a class 9 device.  Otherwise, use a class 1 ROM table.
cluster1.debug_rom_is_flat=0                          # (bool  , init-time) default = '0'      : If true, present a debug ROM table recommended by ARMv8 Debug Architecture.  Otherwise, use nested ROM tables.
cluster1.delay_serror=0                               # (int   , init-time) default = '0x0'    : Add a propagation delay of serror signal into the core
cluster1.delayed_dbgreg_between_secure_views=1        # (int   , init-time) default = '0x1'    : If delayed_dbgreg is enabled, whether the secure and nonsecure external views require explicit synchronization.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.delayed_pmureg_between_secure_views=1        # (int   , init-time) default = '0x1'    : If delayed_pmureg is enabled, whether the secure and nonsecure external views require explicit synchronization.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.dic-spi_count=64                             # (int   , init-time) default = '0x40'   : Number of shared peripheral interrupts implemented
cluster1.disable_sve_plugin=0                         # (bool  , init-time) default = '0'      : If true, SVE will not be implemented in this processor even if the plugin is loaded (FEAT_SVE).
cluster1.disable_unknown_update_event_on_reset=0      # (bool  , init-time) default = '0'      : Disables SYSREG_UPDATE event notification on reset for the registers whose bitfields are all reserved or resets to architecturally unknown value
cluster1.ecv_support_level=0                          # (int   , init-time) default = '0x0'    : Implement Enhanced Counter Virtualization feature from ARMv8.6. 0, Not supported. 1, fully supported without CNTPOFF. 2, fully supported with CNTPOFF (FEAT_ECV).
cluster1.edpfr_ras_unknown_bits_read_as_0=0           # (bool  , init-time) default = '0'      : If true then UNKNOWN bits in RAS field in EDPFR are read as 0
cluster1.edxfr_reads_idreg=0                          # (bool  , init-time) default = '0'      : Whether EDDFR,EDFR1 reads corresponding bitfield value from ID_AA64DFR reg.
cluster1.el0_can_access_imp_def_functionality=0       # (bool  , init-time) default = '0'      : If not made UNDEF by imp_def_functionality_behaviour, EL0 can access IMPLEMENTATION DEFINED registers and system instructions.
cluster1.el0_el1_only_non_secure=0                    # (bool  , init-time) default = '0'      : Secure/non-secure state if EL2 and EL3 are not implemented.  0, secure.  1, non-secure.
cluster1.el3_trap_priority_when_secure_debug_disabled=0  # (bool  , init-time) default = '0'      : Undef when secure debug is disabled (EDSCR.SDD == 1) && boolean IMPLEMENTATION_DEFINED 'EL3 trap priority when SDD == 1'
cluster1.enable_address_contig_check=0                # (bool  , init-time) default = '0'      : Check the input address range for the table entries that have the contiguous hint bit set.
cluster1.enable_debug_auth_signals_config=15          # (int   , init-time) default = '0xf'    : Debug Authentication Signals DBGEN, SPIDEN (and if RME is enabled RLPIDEN and RTPIDEN)are configurable (default) or not configurable, (hardwired to 1). This parameter is theInteger representation of a bitmap to enable configuration of these signals, with:
                                                      #                                        :   - BIT[0] = DBGEN
                                                      #                                        :   - BIT[1] = SPIDEN
                                                      #                                        :   - BIT[2] = RLPIDEN
                                                      #                                        :   - BIT[3] = RTPIDEN
                                                      #                                        : 
cluster1.enable_tlb_contig_check=0                    # (bool  , init-time) default = '0'      : Perform extra pagetable walks to check translation table entries that have the contiguous hint bit set.
cluster1.enhanced_pac2_level=0                        # (int   , init-time) default = '0x0'    : Implements Enhanced PAC2 from ARMv8.6 (FEAT_PAuth2). This feature is mandatory for ARMv8.6 but can be cherrypicked to a ARMv8.3(or greater) implementation. 0: No EnhancedPAC2, 1: EnhancedPAC2 Only (FEAT_PAuth2), 2: EnhancedPAC2 with FPAC (FEAT_FPAC), 3: EnhancedPAC2 with FPACCombined (FEAT_FPACCOMBINE).
cluster1.error_record_feature_register=               # (string, init-time) default = ''       : RAS feature register values. An array of JSON objects. The JSON schema for the array is: [{"ED":0x0,"IMPDEF_3_2":0x0,"UI":0x0,"FI":0x0,"UE":0x0,"CFI":0x0,"CEC":0x0,"RP":0x0,"DUI":0x0,"CEO":0x0,"CI":0x0,"TS":0x0,"INJ":0x0,"FRX":0x0,"UC":0x0,"UEU":0x0,"UER":0x0,"UEO":0x0,"DE":0x0,"CE":0x0,"Visibility":"Core"},other_feature_register_values]. Where ED,UI,FI,CE and UE have valid values between 0x0 - 0x3. CFI and DUI have valid values 0x0, 0x2 and 0x3. CEC has valid values 0x0,0x2 or 0x4. RP,CEO,INJ,FRX,UC,UEU,UER,UEO,DE has valid values 0x0 or 0x1. CI and TS has valid values of 0x0, 0x1 and 0x2. Visibility has valid values "Core" or "Cluster"
cluster1.error_record_feature_register_json_file=     # (string, init-time) default = ''       : File path to the RAS feature register values as JSON. The file uses the same format as the error_record_feature_register parameter value
cluster1.esr_write_update_res0=0                      # (bool  , init-time) default = '0'      : If true, and RASv2 is enabled, then ESR_ELx.WU field is RES0 for errors on both loads and stores (FEAT_RASv2).
cluster1.ete.ASYNC_PACKETS_WHEN_VIEWINST_OFF=0        # (bool  , init-time) default = '0'      : Generate the non-periodic alignment synchronisation packet generation when trace unit is operative
cluster1.ete.ATBTRIG=1                                # (bool  , init-time) default = '1'      : ATB trigger support
cluster1.ete.CCITMIN=4                                # (int   , init-time) default = '0x4'    : Minimum cycle count value
cluster1.ete.CCSIZE=12                                # (int   , init-time) default = '0xc'    : Cycle counter size
cluster1.ete.CLAIMTAGS=8                              # (int   , init-time) default = '0x8'    : Number of claim tags
cluster1.ete.COMMOPT=1                                # (bool  , init-time) default = '1'      : Commit mode
cluster1.ete.COMMTRANS=0                              # (bool  , init-time) default = '0'      : Commit transaction mode
cluster1.ete.DEBUG=2                                  # (int   , init-time) default = '0x2'    : DEBUG
cluster1.ete.DESIGNER=65                              # (int   , init-time) default = '0x41'   : DESIGNER value
cluster1.ete.ETE_REVISION=0                           # (int   , init-time) default = '0x0'    : ETE revision: 0=ETEv1.0, 1=ETEv1.1, 2=ETEv1.2, 3=ETEv1.3
cluster1.ete.EXCEPTION_WITH_CONTEXT=1                 # (bool  , init-time) default = '1'      : Whether EXCEPTION_WITH_CONTEXT packet is supported
cluster1.ete.EXPLICITLY_COMMIT_P0_ELEMS=0             # (bool  , init-time) default = '0'      : Whether to unilaterally explicitly emit a commit after a P0 packet
cluster1.ete.IMPDEFEXCEPPERCENTAGE=0                  # (int   , init-time) default = '0x0'    : Percentage of IMPDEF exceptions inserted in instruction blocks
cluster1.ete.IMPRECISE_FILTERING=0                    # (int   , init-time) default = '0x0'    : Number of instruction blocks traced on a transition in the filtering
cluster1.ete.LPOVERRIDE=1                             # (bool  , init-time) default = '1'      : Low power override
cluster1.ete.MAXSPEC=0                                # (int   , init-time) default = '0x0'    : Maximum speculation depth
cluster1.ete.MAX_INST_PER_Q=1                         # (int   , init-time) default = '0x1'    : Max limit for the number of instructions implied by a Q element
cluster1.ete.NOOVERFLOW=0                             # (bool  , init-time) default = '0'      : No overflow
cluster1.ete.NUMACPAIRS=4                             # (int   , init-time) default = '0x4'    : Number of instruction address comparators pairs
cluster1.ete.NUMCIDC=1                                # (int   , init-time) default = '0x1'    : Number of context ID comparators
cluster1.ete.NUMCNTR=2                                # (int   , init-time) default = '0x2'    : Number of counters
cluster1.ete.NUMEXTINSEL=4                            # (int   , init-time) default = '0x4'    : Number of external input selectors
cluster1.ete.NUMPC=0                                  # (int   , init-time) default = '0x0'    : Number of PE comparators
cluster1.ete.NUMSEQSTATE=4                            # (int   , init-time) default = '0x4'    : Number of sequencer states
cluster1.ete.NUMSSCC=1                                # (int   , init-time) default = '0x1'    : Number of single shot comparators
cluster1.ete.NUMVMIDC=1                               # (int   , init-time) default = '0x1'    : Number of virtual ID comparators
cluster1.ete.NumberOfETEEvents=2                      # (int   , init-time) default = '0x2'    : Number of trace events
cluster1.ete.NumberOfRSPairs=8                        # (int   , init-time) default = '0x8'    : Number of resource selectors
cluster1.ete.PIDR_CMOD=0                              # (int   , init-time) default = '0x0'    : TRCPIDR CMOD value
cluster1.ete.PIDR_DESIGNER=0                          # (int   , init-time) default = '0x0'    : TRCPIDR DESIGNER value
cluster1.ete.PIDR_PART=0                              # (int   , init-time) default = '0x0'    : TRCPIDR PART number value
cluster1.ete.PIDR_REVAND=0                            # (int   , init-time) default = '0x0'    : TRCPIDR REVAND value
cluster1.ete.PIDR_REVISION=0                          # (int   , init-time) default = '0x0'    : TRCPIDR REVISION value
cluster1.ete.QFILT=0                                  # (bool  , init-time) default = '0'      : Q filtering
cluster1.ete.QSUP=0                                   # (int   , init-time) default = '0x0'    : Q support
cluster1.ete.Q_CADENCE=1                              # (int   , init-time) default = '0x1'    : Number of instruction blocks traced between two Q elements
cluster1.ete.REG_ACCESS_ONLY_MODE=0                   # (bool  , init-time) default = '0'      : If enabled all traces are disabled. Plugin only allows register acceses
cluster1.ete.RES0_STATEFUL=0                          # (bool  , init-time) default = '0'      : Whether RES0 bits are stateful or RAZ/WI
cluster1.ete.RETSTACK=3                               # (int   , init-time) default = '0x3'    : Return stack depth
cluster1.ete.REVISION=0                               # (int   , init-time) default = '0x0'    : TRCIDR1 revision value
cluster1.ete.SIM_OVERFLOW_GRANULARITY=100             # (int   , init-time) default = '0x64'   : Number of instruction blocks in each granule, for simulated overflow
cluster1.ete.SIM_OVERFLOW_PERCENTAGE=0                # (int   , init-time) default = '0x0'    : Percentage of instruction blocks lost in each granule, for simulated overflow
cluster1.ete.SOURCE_ADDRESS=0                         # (bool  , init-time) default = '0'      : Allow generation of source address elements
cluster1.ete.STALLCTRL=1                              # (bool  , init-time) default = '1'      : Stall control
cluster1.ete.SYSSTALL=1                               # (bool  , init-time) default = '1'      : System stall
cluster1.ete.TRACEIDSIZE=7                            # (int   , init-time) default = '0x7'    : Trace ID size
cluster1.ete.TRACE_OUTPUT=                            # (string, init-time) default = ''       : File to which to write trace byte stream
cluster1.ete.TRACE_OUTPUT_ENABLE=0                    # (bool  , init-time) default = '0'      : ETE Trace output enable : 1=enable, 0=disable
cluster1.ete.TRCRSRTA_FORCED_EXCEP=0                  # (bool  , init-time) default = '0'      : TRCRSR.TA value for a forcibly traced exception
cluster1.ete.TSMARK=0                                 # (bool  , init-time) default = '0'      : Whether timestamp markers are supported
cluster1.ete.TSSIZE=8                                 # (int   , init-time) default = '0x8'    : Timestamp size
cluster1.ete.WFXMODE=1                                # (bool  , init-time) default = '1'      : WFX mode
cluster1.exception_catch_before_software_step=1       # (bool  , init-time) default = '1'      : Exception catch priority for the exception trapping form of exception catch (Armv8.2 or later, or exception_catch_type=0). If true, the exception catch debug event has higher prority than software step and halting step.
cluster1.exception_catch_type=0                       # (int   , init-time) default = '0x0'    : Type of exception catch (ARMv8.0 - ARMv8.1 only). 0, exception trapping. 1, non-exception trapping, higher priority than step. 2, non-exception trapping, lower priority than step.
cluster1.exclusive_monitor_clear_on_atomic_from_same_master=1  # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared by a atomic by the same master to the monitored address.
cluster1.exclusive_monitor_clear_on_store_from_same_master=1  # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared by a store by the same master to the monitored address.
cluster1.exclusive_monitor_clear_on_strex_address_mismatch=1  # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared when a strex fails because the address does not match.
cluster1.exclusive_monitor_clear_on_strex_success=1   # (bool  , init-time) default = '1'      : Exclusive monitors in the cluster will be cleared when a strex succeeds.
cluster1.exercise_stxr_fail=0                         # (bool  , init-time) default = '0'      : Reject a pseudo-random majority of exclusive store instructions
cluster1.ext_abort_device_GRE_prefetch_ras_index=-1   # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_device_GRE_prefetch_ras_type=-1    # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_device_GRE_read_is_critical=0      # (bool  , init-time) default = '0'      : Critical reporting of device-GRE read external aborts.
cluster1.ext_abort_device_GRE_read_is_sync=2          # (int   , init-time) default = '0x2'    : Synchronous reporting of device-GRE read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_read_is_sync.
cluster1.ext_abort_device_GRE_read_ras_index=-1       # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_read_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_device_GRE_read_ras_type=-1        # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_device_GRE_write_is_critical=0     # (bool  , init-time) default = '0'      : Critical reporting of device-GRE write external aborts
cluster1.ext_abort_device_GRE_write_is_sync=2         # (int   , init-time) default = '0x2'    : Synchronous reporting of device-GRE write external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_write_is_sync.
cluster1.ext_abort_device_GRE_write_ras_index=-1      # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_write_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_device_GRE_write_ras_type=-1       # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_write_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_device_nGRE_prefetch_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_device_nGRE_prefetch_ras_type=-1   # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_device_nGRE_read_is_critical=0     # (bool  , init-time) default = '0'      : Critical reporting of device-nGRE read external aborts.
cluster1.ext_abort_device_nGRE_read_is_sync=2         # (int   , init-time) default = '0x2'    : Synchronous reporting of device-nGRE read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_read_is_sync.
cluster1.ext_abort_device_nGRE_read_ras_index=-1      # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_read_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_device_nGRE_read_ras_type=-1       # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_device_nGRE_write_is_critical=0    # (bool  , init-time) default = '0'      : Critical reporting of device-nGRE write external aborts
cluster1.ext_abort_device_nGRE_write_is_sync=2        # (int   , init-time) default = '0x2'    : Synchronous reporting of device-nGRE write external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_device_write_is_sync.
cluster1.ext_abort_device_nGRE_write_ras_index=-1     # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_device_write_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_device_nGRE_write_ras_type=-1      # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_device_write_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_device_prefetch_ras_index=-1       # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_device_prefetch_ras_type=-1        # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_device_read_acquire_is_sync=0      # (bool  , init-time) default = '0'      : Synchronous reporting of device read with acquire external aborts
cluster1.ext_abort_device_read_is_critical=0          # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRE read external aborts
cluster1.ext_abort_device_read_is_sync=1              # (bool  , init-time) default = '1'      : Synchronous reporting of device-nGnRE read external aborts
cluster1.ext_abort_device_read_ras_index=0            # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_device_read_ras_type=0             # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_device_write_is_critical=0         # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRE write external aborts
cluster1.ext_abort_device_write_is_sync=0             # (bool  , init-time) default = '0'      : Synchronous reporting of device-nGnRE write external aborts
cluster1.ext_abort_device_write_ras_index=0           # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_device_write_ras_type=0            # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_fill_data=-144680349987897859      # (int   , init-time) default = '0xfdfdfdfcfcfdfdfd' : Returned data, if external aborts are asynchronous
cluster1.ext_abort_normal_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-back cacheable-read external aborts
cluster1.ext_abort_normal_cacheable_read_is_sync=1    # (bool  , init-time) default = '1'      : Synchronous reporting of normal write-back cacheable-read external aborts
cluster1.ext_abort_normal_cacheable_read_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_normal_cacheable_read_ras_type=0   # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_normal_cacheable_write_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-back cacheable write external aborts
cluster1.ext_abort_normal_cacheable_write_is_sync=0   # (bool  , init-time) default = '0'      : Synchronous reporting of normal write-back cacheable write external aborts
cluster1.ext_abort_normal_cacheable_write_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_normal_cacheable_write_ras_type=0  # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_normal_noncacheable_prefetch_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_normal_noncacheable_prefetch_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_normal_noncacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal noncacheable-read external aborts
cluster1.ext_abort_normal_noncacheable_read_is_sync=1  # (bool  , init-time) default = '1'      : Synchronous reporting of normal noncacheable-read external aborts
cluster1.ext_abort_normal_noncacheable_read_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_normal_noncacheable_read_ras_type=0  # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_normal_noncacheable_write_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal noncacheable write external aborts
cluster1.ext_abort_normal_noncacheable_write_is_sync=0  # (bool  , init-time) default = '0'      : Synchronous reporting of normal noncacheable write external aborts
cluster1.ext_abort_normal_noncacheable_write_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_normal_noncacheable_write_ras_type=0  # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_normal_wt_cacheable_prefetch_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_normal_wt_cacheable_prefetch_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_normal_wt_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-through cacheable-read external aborts
cluster1.ext_abort_normal_wt_cacheable_read_is_sync=2  # (int   , init-time) default = '0x2'    : Synchronous reporting of normal write-through read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_normal_cacheable_read_is_sync.
cluster1.ext_abort_normal_wt_cacheable_read_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_read_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_normal_wt_cacheable_read_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_normal_wt_cacheable_write_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of normal write-through write external aborts
cluster1.ext_abort_normal_wt_cacheable_write_is_sync=2  # (int   , init-time) default = '0x2'    : Synchronous reporting of normal write-through write external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_normal_cacheable_write_is_sync.
cluster1.ext_abort_normal_wt_cacheable_write_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_write_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_normal_wt_cacheable_write_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_normal_cacheable_write_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_prefetch_device_GRE_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-GRE instruction fetches
cluster1.ext_abort_prefetch_device_GRE_read_is_sync=2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device-GRE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster1.ext_abort_prefetch_device_nGRE_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-nGRE instruction fetches
cluster1.ext_abort_prefetch_device_nGRE_read_is_sync=2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device-nGRE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster1.ext_abort_prefetch_device_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-nGnRE instruction fetches
cluster1.ext_abort_prefetch_device_read_is_sync=2     # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device-nGnRE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster1.ext_abort_prefetch_is_critical=0             # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by normal writeback cacheable instruction fetches
cluster1.ext_abort_prefetch_is_sync=1                 # (bool  , init-time) default = '1'      : Behaviour of external aborts generated by normal writeback cacheable instruction fetches.  0, asynchronous abort.  1, synchronous abort.
cluster1.ext_abort_prefetch_noncacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by normal noncacheable instruction fetches
cluster1.ext_abort_prefetch_noncacheable_read_is_sync=2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by normal noncacheable instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster1.ext_abort_prefetch_ras_index=0               # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_prefetch_ras_type=0                # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_prefetch_so_read_is_critical=0     # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by device-nGnRnE instruction fetches
cluster1.ext_abort_prefetch_so_read_is_sync=2         # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by device=nGnRnE instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster1.ext_abort_prefetch_wt_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of external aborts generated by normal writethrough cacheable instruction fetches
cluster1.ext_abort_prefetch_wt_cacheable_read_is_sync=2  # (int   , init-time) default = '0x2'    : Behaviour of external aborts generated by normal writethrough cacheable instruction fetches.  0, asynchronous abort.  1, synchronous abort. 2, same as ext_abort_prefetch_is_sync.
cluster1.ext_abort_so_prefetch_ras_index=-1           # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_so_prefetch_ras_type=-1            # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_prefetch_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_so_read_is_critical=0              # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRnE read external aborts
cluster1.ext_abort_so_read_is_sync=1                  # (bool  , init-time) default = '1'      : Synchronous reporting of device-nGnRnE read external aborts
cluster1.ext_abort_so_read_ras_index=0                # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_so_read_ras_type=0                 # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_so_write_is_critical=0             # (bool  , init-time) default = '0'      : Critical reporting of device-nGnRnE write external aborts
cluster1.ext_abort_so_write_is_sync=1                 # (bool  , init-time) default = '1'      : Synchronous reporting of device-nGnRnE write external aborts
cluster1.ext_abort_so_write_ras_index=0               # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_so_write_ras_type=0                # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_ttw_cacheable_read_is_critical=0   # (bool  , init-time) default = '0'      : Critical reporting of TTW cacheable read external aborts
cluster1.ext_abort_ttw_cacheable_read_is_sync=1       # (bool  , init-time) default = '1'      : Synchronous reporting of TTW cacheable read external aborts
cluster1.ext_abort_ttw_cacheable_read_ras_index=0     # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_ttw_cacheable_read_ras_type=0      # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_ttw_noncacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of TTW noncacheable read external aborts
cluster1.ext_abort_ttw_noncacheable_read_is_sync=1    # (bool  , init-time) default = '1'      : Synchronous reporting of TTW noncacheable read external aborts
cluster1.ext_abort_ttw_noncacheable_read_ras_index=0  # (int   , init-time) default = '0x0'    : External Aborts are reported in RAS record index specified in this param. Values: Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_ttw_noncacheable_read_ras_type=0   # (int   , init-time) default = '0x0'    : External Aborts are reported as RAS error type specified in this param. Values: 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.ext_abort_ttw_wt_cacheable_read_is_critical=0  # (bool  , init-time) default = '0'      : Critical reporting of TTW write-through cacheable read external aborts
cluster1.ext_abort_ttw_wt_cacheable_read_is_sync=2    # (int   , init-time) default = '0x2'    : Synchronous reporting of TTW write-through cacheable read external aborts. 0, asynchronous. 1, synchronous. 2, same as ext_abort_ttw_cacheable_read_is_sync.
cluster1.ext_abort_ttw_wt_cacheable_read_ras_index=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported in RAS record index specified in this param. Values: -1 = Same as ext_abort_ttw_cacheable_read_ras_index, Valid indices in range [0, number_of_error_records).
cluster1.ext_abort_ttw_wt_cacheable_read_ras_type=-1  # (int   , init-time) default = '0xffffffffffffffff' : External Aborts are reported as RAS error type specified in this param. Values: -1 = Same as ext_abort_ttw_cacheable_read_ras_type, 0 = NONE, 1 = UC, 2 = UEU, 3 = UEO , 4 = UER, 5 = CE.
cluster1.external_oslar_access_disabled_by_authentication=0  # (bool  , init-time) default = '0'      : If true, external accesses to OSLAR, when external debugging is not enabled, will generate an error (FEAT_Debugv8p2).
cluster1.fault_on_misprogrammed_gpt_contig_region=0   # (bool  , init-time) default = '0'      : Whether GPF faults occur when GPT contiguous entries are misprogrammed.
cluster1.fault_on_nT_bit_set=1                        # (bool  , init-time) default = '1'      : Whether block translation table entries with the nT bit set should always fault. Only applies when changing_block_size_without_bbm_support_level is 1 or higher.
cluster1.fault_unalign_to_unsupported_access=8        # (int   , init-time) default = '0x8'    : If has_unaligned_single_copy_atomicity is true, whether unaligned A64 atomic, exclusive and acquire/release instructions to non iWB-oWB or the access crossing a 16-byte boundary generate fault. Bits 0,1,2,3 should be set accordingly to enable the fault behaviour. bit 0: atomic access should fault, bit 1: exclusive access should fault, bit 2: acquire/release should fault, bit 3: the access crossing a 16-byte boundary should fault
cluster1.fault_unaligned_s1_device_s2_fwb=0           # (bool  , init-time) default = '0'      : Whether unaligned access with stage1 Device memory and final memory attribute forced to normal by FWB can generate alignment fault
cluster1.force_align_pc=0                             # (bool  , init-time) default = '0'      : UNPREDICTABLE branch to non-word-aligned address in ARM state is forced to be aligned
cluster1.force_deterministic_irg_tag_generation=0     # (bool  , init-time) default = '0'      : Force the random tag generated by the IRG instruction when GCR_EL1.RRND=1 to equal RGSR_EL1.SEED[3:0] rather than a non-deterministic value
cluster1.force_mte_tag_access_razwi_and_ignore_tag_checks=0  # (bool  , init-time) default = '0'      : Force MTE tag accesses to RAZ/WI and also ignore tag checks irrespective of whether memory is tagged or not. This parameter doesn't affect non-load/store tag generation instructions like ADDG/GMI/IRG/SUBG. Please note that setting this parameter to true will also disable MTE tag access and tag check related traces
cluster1.force_wnr_read_unsupported_exclusive_or_atomic=0  # (bool  , init-time) default = '0'      : Whether ESR_ELx.WnR is forced to 0 for unsupported atomic and exclusives
cluster1.fpcr_short_vector_raz=0                      # (bool  , init-time) default = '0'      : FPSCR and FPCR fields LEN and STRIDE are hardwired to 0
cluster1.fsr_ext_bit_update_kind=3                    # (int   , init-time) default = '0x3'    : Set/Clear DFSR/IFSR EA bit on Synchronous/Async External Aborts. 0: Never Set, 1: Set on Synchronous Ext Aborts 2: Set on Asynchronous Ext Aborts 3: Set on both Sync and Async Ext Aborts. 
cluster1.gic.GICC-offset=0                            # (int   , init-time) default = '0x0'    : Offset from PERIPHBASE for GICC registers.
cluster1.gic.GICD-offset=262144                       # (int   , init-time) default = '0x40000' : Offset from PERIPHBASE for GICD registers. Will be ignored when GICv3 CPU interface is enabled, as distributor is then external to the cluster.
cluster1.gic.GICH-offset=65536                        # (int   , init-time) default = '0x10000' : Offset from PERIPHBASE for GICH registers.
cluster1.gic.GICH-other-CPU-offset=262144             # (int   , init-time) default = '0x40000' : Offset from PERIPHBASE for GICH registers for accessing other CPUs in the cluster. Set to 0 to disable.
cluster1.gic.GICV-alias=0                             # (int   , init-time) default = '0x0'    : Offset from PERIPHBASE for alias of GICV registers. When gicv2-only, if zero no alias will be created; if gicv2-only=0, the param is deprecated, when zero or unset an alias is created in the place mandated by the architecture (GICV-base+0xF000)
cluster1.gic.GICV-offset=192512                       # (int   , init-time) default = '0x2f000' : Offset from PERIPHBASE for GICV registers.
cluster1.gic.PERIPH-size=262144                       # (int   , init-time) default = '0x40000' : Size of registers based at PERIPHBASE that are considered to be owned by the GIC.  Any accesses in the range PERIPHBASE to PERIPHBASE+gic.PERIPH-size-1 that do not match GIC registers will be treated as RAZ/WI.
cluster1.gicv3.A3-affinity-supported=0                # (bool  , init-time) default = '0'      : Whether a non-zero value for affinity at level 3 is supported.
cluster1.gicv3.BPR-min=2                              # (int   , init-time) default = '0x2'    : The minimum value for the GICC_BPR register (non-secure version will be 1 + this value).
cluster1.gicv3.EOI-check-CPUID=0                      # (bool  , init-time) default = '0'      : Check CPU ID specified for accesses to EOI registers (rather than just ending highest priority active interrupt).
cluster1.gicv3.EOI-check-ID=0                         # (bool  , init-time) default = '0'      : Check Interrupt ID specified for accesses to EOI registers (rather than just ending highest priority active interrupt).
cluster1.gicv3.EOI-deactivate-any-interrupt=0         # (bool  , init-time) default = '0'      : Allow an EOI to deactivate interrupts that aren't the highest priority active interrupt (EOI-ignore-out-of-order must be false otherwise this is ignored).
cluster1.gicv3.EOI-ignore-out-of-order=1              # (bool  , init-time) default = '1'      : Ignore EOI writes that cannot end the highest priority active interrupt.
cluster1.gicv3.FIQEn-RAO=0                            # (bool  , init-time) default = '0'      : GICC_CTLR.FIQEn is read as one, write insensitive
cluster1.gicv3.IIDR_base=1083                         # (int   , init-time) default = '0x43b'  : The base value for calculating the GICC_IIDR register value.
cluster1.gicv3.LR-count=16                            # (int   , init-time) default = '0x10'   : The number of implemented list registers.
cluster1.gicv3.PMHE-RAO-WI=0                          # (bool  , init-time) default = '0'      : ICC_CTLR_EL*.PHME is read as one, write insensitive
cluster1.gicv3.PMHE-RAZ-WI=0                          # (bool  , init-time) default = '0'      : ICC_CTLR_EL*.PHME is read as zero, write insensitive
cluster1.gicv3.PMHE-release-set-packet=0              # (bool  , init-time) default = '0'      : if PHME is enabled, whether a SET packet is released by CPU Intf in Upstream Ack window.
cluster1.gicv3.SRE-EL2-enable-RAO=0                   # (bool  , init-time) default = '0'      : When ICC_SRE_EL2.SRE is RAO/WI, makes ICC_SRE_EL2.Enable RAO/WI
cluster1.gicv3.SRE-EL3-enable-RAO=0                   # (bool  , init-time) default = '0'      : When ICC_SRE_EL3.SRE is RAO/WI, makes ICC_SRE_EL3.Enable RAO/WI
cluster1.gicv3.SRE-EL3-set-once=0                     # (bool  , init-time) default = '0'      : Restrict SRE EL3 to be set only once
cluster1.gicv3.SRE-enable-action-on-mmap=0            # (int   , init-time) default = '0x0'    : Allowed values are: 0-SRE one allows mmap access. 1-SRE one disables mmap access. 2-SRE one makes mmap access RAZ-WI.
cluster1.gicv3.STATUSR-implemented=1                  # (bool  , init-time) default = '1'      : If GICv3 CPU interface is being used, this determines whether the STATUS registers are implemented
cluster1.gicv3.VBPR-min=2                             # (int   , init-time) default = '0x2'    : The minimum value for the GICV_BPR register (non-secure version will be 1 + this value).
cluster1.gicv3.VFIQEn-RAO=0                           # (bool  , init-time) default = '0'      : ICH_VMCR_EL2.VFIQEn is read as one, write insensitive
cluster1.gicv3.cpuintf-mmap-access-level=0            # (int   , init-time) default = '0x0'    : Allowed values are: 0-mmap access is supported for GICC,GICH,GICV registers. 1-mmap access is supported only for GICV registers. 2-mmap access is not supported.
cluster1.gicv3.dir-trap-support=1                     # (bool  , init-time) default = '1'      : The cpu supports separate trapping of ICC_DIR_EL1 to EL2
cluster1.gicv3.el3_trap_priority_when_secure_debug_disabled=0  # (bool  , init-time) default = '0'      : Undef to access priorities group register when secure debug is disabled
cluster1.gicv3.extended-interrupt-range-support=0     # (bool  , init-time) default = '0'      : Device has support for extended SPI/PPI ID ranges
cluster1.gicv3.idle-is-ff=1                           # (bool  , init-time) default = '1'      : For GICC/GICV RPR, when idle, return FF when true, minimum supported priority otherwise
cluster1.gicv3.ignore-DIR-write-when-EOImode-not-set=1  # (bool  , init-time) default = '1'      : Ignore UNPREDICTABLE access to GICC_DIR register.
cluster1.gicv3.interrupt-bypass-support=1             # (bool  , init-time) default = '1'      : Interrupt bypass support, set to false for devices not supporting interrupt bypass
cluster1.gicv3.local-SEIs=0                           # (bool  , init-time) default = '0'      : Generate SEI to signal internal issues
cluster1.gicv3.local-VSEIs=0                          # (bool  , init-time) default = '0'      : Generate VSEI to signal internal issues
cluster1.gicv3.physical-ID-bits=16                    # (int   , init-time) default = '0x10'   : Number of physical ID bits implemented.
cluster1.gicv3.priority-bits=5                        # (int   , init-time) default = '0x5'    : Number of priority bits implemented.
cluster1.gicv3.send-PMHE-command-only-when-priority-changes=0  # (bool  , init-time) default = '0'      : Send PMHE upstream command to distributor only when write to ICC_PMR_EL1 changes the priority
cluster1.gicv3.sgi-range-selector-support=0           # (bool  , init-time) default = '0'      : Device has support for the Range Selector feature for SGI
cluster1.gicv3.suppress-virtual-enables-comms=1       # (bool  , init-time) default = '1'      : In GICv3 only mode, prevents the GIC CPUIF from communicating UpstreamWrite/VirtualEnables to the IRI
cluster1.gicv3.virtual-ID-bits=16                     # (int   , init-time) default = '0x10'   : Number of virtual ID bits implemented.
cluster1.gicv3.virtual-lpi-support=1                  # (bool  , init-time) default = '1'      : When GICv3 is supported, indicates a cut down CPUIF interface with no support of VLPI (GICv3 only) when false
cluster1.gicv3.virtual-priority-bits=5                # (int   , init-time) default = '0x5'    : Number of virtual priority bits implemented.
cluster1.gicv3.without-DS-support=0                   # (bool  , init-time) default = '0'      : GICv3 CPU interfaces do not support disabling security in the distributor (GICD_CTLR.DS=1)
cluster1.gicv4.mask-virtual-interrupt=0               # (bool  , init-time) default = '0'      : If true, virtual interrupts can be masked from being reported to virtual CPU interface by setting ICH_HCR_EL2.DVIM 1. No control otherwise.
cluster1.global_debug_rom.ROMDEVID=0                  # (int   , init-time) default = '0x0'    : Value of Debug Rom Device Identification Register
cluster1.global_debug_rom.ROMPIDR=17180635136         # (int   , init-time) default = '0x4000bb000' : Value of Debug Rom Peripheral Identification Register
cluster1.global_debug_rom.ROMPRIDR0=1                 # (int   , init-time) default = '0x1'    : Value of Debug ROM Power RequestID Register
cluster1.gpccr_el3_gpcp_behaviour=2                   # (int   , init-time) default = '0x2'    : Used to control impdef behaviour when GPCP=1 (0->Faults are always generated and reported, 1->Faults are not generated and reported), 2->Faults are generated and reported only for Arm recommended cases
cluster1.gpt_tlb_size=0                               # (int   , init-time) default = '0x0'    : Number of separate GPT TLB entries.
cluster1.gpt_walkcache_size=0                         # (int   , init-time) default = '0x0'    : Number of GPT walk cache entries.
cluster1.hardware_translation_table_update_implemented=1  # (int   , init-time) default = '0x1'    : Implement hardware translation table updates from ARMv8.1 (FEAT_HAFDBS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.1 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_128_bit_atomic_instructions=0            # (int   , init-time) default = '0x0'    : Implement 128-bit Atomic Instructions (FEAT_LSE128)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_128_bit_tt_descriptors=0                 # (int   , init-time) default = '0x0'    : Implement 128-bit Translation Table Descriptors (FEAT_D128)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_16bit_asids=1                            # (bool  , init-time) default = '1'      : Enable 16-bit ASIDs.
cluster1.has_16bit_vmids=1                            # (int   , init-time) default = '0x1'    : Implement support for 16-bit VMIDs from ARMv8.1 (FEAT_VMID16).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.1 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_16k_granule=0                            # (bool  , init-time) default = '0'      : Implement the 16k LPAE translation granule.
cluster1.has_4k_granule=1                             # (bool  , init-time) default = '1'      : Implement the 4k LPAE translation granule.
cluster1.has_52bit_address_with_16k=0                 # (int   , init-time) default = '0x0'    : Implements Armv8.7 52-bit IPA/PA support for 16k (FEAT_LPA2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_52bit_address_with_4k=0                  # (int   , init-time) default = '0x0'    : Implements Armv8.7 52-bit IPA/PA support for 4k (FEAT_LPA2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_56_bit_va=0                              # (int   , init-time) default = '0x0'    : 56-bit Physical Address, identified as (FEAT_LVA3)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_64bit_pmu_ext_access=0                   # (int   , init-time) default = '0x0'    : Implement 64-bit pmu external interface access
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_64k_granule=1                            # (bool  , init-time) default = '1'      : Implement the 64k LPAE translation granule.
cluster1.has_aarch32_dbgdidr_etc=1                    # (bool  , init-time) default = '1'      : DBGDIDR, DBGDRAR, DBGDSAR exist even if EL1 doesn't implement AArch32
cluster1.has_aarch32_hpd=0                            # (bool  , init-time) default = '0'      : If true then hierarchical permission disable is supported in AArch32 (FEAT_AA32HPD)
cluster1.has_aarch64=1                                # (bool  , init-time) default = '1'      : All implemented exception levels can run in AArch64
cluster1.has_actlr2=0                                 # (bool  , init-time) default = '0'      : If true ACLTR2 exists and ACTLR2(NS) is aliased to ACTLR_EL1[63:32]
cluster1.has_address_breakpoint_linking=0             # (int   , init-time) default = '0x0'    : Implement Address Breakpoint Linking Extension (FEAT_ABLE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_amu=0                                    # (int   , init-time) default = '0x0'    : Implement activity monitor functionality from ARMv8.4 (FEAT_AMUv1).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_amu_ext64=0                              # (int   , init-time) default = '0x0'    : Implement 64-bit external interface to the Activity Monitors (FEAT_AMU_EXT64).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_arm_v8-1=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.1 Extension.
cluster1.has_arm_v8-2=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.2 Extension.
cluster1.has_arm_v8-3=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.3 Extension.
cluster1.has_arm_v8-4=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.4 Extension.
cluster1.has_arm_v8-5=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.5 Extension.
cluster1.has_arm_v8-6=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.6 Extension.
cluster1.has_arm_v8-7=0                               # (bool  , init-time) default = '0'      : Implement the Armv8.7 Extension.
cluster1.has_arm_v8-8=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.8 Extension.
cluster1.has_arm_v8-9=0                               # (bool  , init-time) default = '0'      : Implement the ARMv8.9 Extension. This feature is incomplete and under development.
cluster1.has_arm_v9-0=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.0 Extension.
cluster1.has_arm_v9-1=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.1 Extension.
cluster1.has_arm_v9-2=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.2 Extension.
cluster1.has_arm_v9-3=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.3 Extension.
cluster1.has_arm_v9-4=0                               # (bool  , init-time) default = '0'      : Implement the ARMv9.4 Extension.
cluster1.has_at_with_pan=1                            # (int   , init-time) default = '0x1'    : Implement new AT instructions with PAN support (FEAT_PAN2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_attribute_index_enhancement=0            # (int   , init-time) default = '0x0'    : Memory Attribute Index Enhancement (FEAT_AIE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_axflag_xaflag=1                          # (int   , init-time) default = '0x1'    : Implement flag manipulation instructions (AXFlag, XAFlag) from ARMv8.5 (FEAT_FlagM2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_axflag_xaflag_frint=1                    # (int   , init-time) default = '0x1'    : Implement flag manipulation instructions (AXFlag, XAFlag) and floating-point rounding to int instructions (FRINT[32|64][X|Z]) from ARMv8.5. If this parameter is enabled, it also enables both has_axflag_xaflag and has_frint. If support for only one of the features is needed, please use the individual parameters and do not enable this one (FEAT_FlagM2, FEAT_FRINTTS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_bc=1                                     # (int   , init-time) default = '0x1'    : Implement Armv8.8 Hinted Conditional Branch (FEAT_HBC)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_branch_target_exception=0                # (int   , init-time) default = '0x0'    : Implement Branch target identification mechanism from ARMv8.5 (FEAT_BTI).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_brbe=0                                   # (bool  , init-time) default = '0'      : If true, implements branch record buffer extension (FEAT_BRBE).
cluster1.has_brbe_v1p1=0                              # (bool  , init-time) default = '0'      : If true, implements FEAT_BRBEv1p1.
cluster1.has_ccidx=0                                  # (bool  , init-time) default = '0'      : Implement the ARMv8.3 CCSIDR Extension. Extending the ccsidr number of sets.
cluster1.has_cfinv_rmif_setf=1                        # (int   , init-time) default = '0x1'    : Implement flag manipulation (CFINV, RMIF, SETF8, SETF16) instructions from ARMv8.4 (FEAT_FlagM).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_clear_bhb=1                              # (int   , init-time) default = '0x1'    : Implement Clear Branch History information instruction (FEAT_CLRBHB).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_clear_other_speculation_by_context=1     # (int   , init-time) default = '0x1'    : Implement execution and data prediction invalidation from Armv8.9 (FEAT_SPECRES2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_cmo_wr_control=1                         # (int   , init-time) default = '0x1'    : Whether stage1/2 CMO write perm control is supported (FEAT_CMOW)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_coherent_icache=0                        # (bool  , init-time) default = '0'      : Whether icache invalidation to the point of unification is required for instruction to data coherence. true - Invalidate operations not required
cluster1.has_common_not_private_translations=1        # (int   , init-time) default = '0x1'    : Implement the TTBRn_ELx.CnP (Common not Private) controls from ARMv8.2 (FEAT_TTCNP).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_complex_number=1                         # (int   , init-time) default = '0x1'    : Implement ARMv8.3 complex number support, Multiply Accumulate and Add instructions (FEAT_FCMA).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_const_pac=0                              # (int   , init-time) default = '0x0'    : Feature for singular selection of PAC field (FEAT_CONSTPACFIELD).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_cssc=1                                   # (int   , init-time) default = '0x1'    : Support for common short sequence compression instructions (FEAT_CSSC)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_cvadp_support=0                          # (int   , init-time) default = '0x0'    : Implement instruction to support cache clean by deep persistence (DC CVADP) from ARMv8.5, can be selected for core implemented on any arch version starting ARMv8.2 (FEAT_DPB, FEAT_DPB2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_data_alignment_flag=0                    # (int   , init-time) default = '0x0'    : Implement non-optimal misalignment flag for PMU/SPE from ARMv8.5
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_debug_rom=1                              # (bool  , init-time) default = '1'      : If true, a debug ROM will be generated describing the cluster's debug components.
cluster1.has_delayed_ctireg=0                         # (bool  , init-time) default = '0'      : Delay the functional effect of CTI register writes until ISB or implicit barrier.
cluster1.has_delayed_dbgreg=0                         # (bool  , init-time) default = '0'      : Delay the functional effect of external debug register writes until ISB or implicit barrier.
cluster1.has_delayed_mdscr_el1=0                      # (bool  , init-time) default = '0'      : Delay the functional effect of MDSCR_EL1 register writes until ISB or implicit barrier.
cluster1.has_delayed_oslar_el1=0                      # (bool  , init-time) default = '0'      : Delay the functional effect of OSLAR_EL1 register writes until ISB or implicit barrier.
cluster1.has_delayed_pmureg=0                         # (bool  , init-time) default = '0'      : Delay the functional effect of PMU register writes until ISB or implicit barrier.
cluster1.has_delayed_sysreg=0                         # (bool  , init-time) default = '0'      : Delay the functional effect of system register writes until ISB or implicit barrier.
cluster1.has_delayed_wfe_trap=0                       # (int   , init-time) default = '0x0'    : Implements Configurable Delayed WFE trapping from ARMv8.6 (FEAT_TWED).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_dgh=1                                    # (int   , init-time) default = '0x1'    : Implements Data Gathering Hint instruction from ARMv8.6 (FEAT_DGH).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_dot_product=1                            # (int   , init-time) default = '0x1'    : Implement the dot product (UDOT, SDOT) instructions from ARMv8.4 (FEAT_DotProd).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_e0pd=1                                   # (int   , init-time) default = '0x1'    : Implement ARMv8.5 feature to prevent unprivileged access to one half of the memory (FEAT_E0PD).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ebf16=0                                  # (int   , init-time) default = '0x0'    : Support for Extended BFloat16 Behaviours (FEAT_EBF16)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ecbhb=1                                  # (int   , init-time) default = '0x1'    : Implement Exploitative Control using Branch History information between exception levels (FEAT_ECBHB).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_edacr=1                                  # (bool  , init-time) default = '1'      : Implement EDACR register
cluster1.has_el2=1                                    # (bool  , init-time) default = '1'      : Implements EL2
cluster1.has_el3=1                                    # (bool  , init-time) default = '1'      : Implements EL3
cluster1.has_enhanced_pac=0                           # (bool  , init-time) default = '0'      : If pointer authentication is enabled then implement enhanced PAC.
cluster1.has_enhanced_pan=1                           # (int   , init-time) default = '0x1'    : Implements Armv8.7 Enhanced PAN feature (FEAT_PAN3)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ete=0                                    # (bool  , init-time) default = '0'      : If true, implements the Embedded Trace Extension (FEAT_ETE). This option is discarded if ete plugin is explicitly loaded (--plugin or -P)
cluster1.has_ets=0                                    # (bool  , init-time) default = '0'      : Whether Enhanced Translation Synchronization is supported (FEAT_ETS).
cluster1.has_exception_trapping_form_of_vector_catch=1  # (bool  , init-time) default = '1'      : Implement the exception trapping form of vector catch debug event.
cluster1.has_extended_recp_estimate=0                 # (int   , init-time) default = '0x0'    : Implements increased precision of reciprocal instructions (FEAT_RPRES).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_external_rndr=0                          # (int   , init-time) default = '0x0'    : Implement external random number generator module. When enabling this with has_rndr enabled, the external random number generator will be used instead of internal random number generator
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_far_not_valid=0                          # (bool  , init-time) default = '0'      : Implements FnV bit in ESR_ELx and xFSR, FAR not valid for synchronous external aborts.
cluster1.has_far_not_valid_dfsc=0                     # (bool  , init-time) default = '0'      : Implements FnV bit in ESR_ELx, FAR not valid for synchronous external aborts for Data Abort.
cluster1.has_far_not_valid_ifsc=0                     # (bool  , init-time) default = '0'      : Implements FnV bit in ESR_ELx and xFSR, FAR not valid for synchronous external aborts for Instruction Abort.
cluster1.has_fgt=1                                    # (int   , init-time) default = '0x1'    : Implements Fine-grained Virtualization Traps extension from ARMv8.6 (FEAT_FGT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_fgt2=1                                   # (int   , init-time) default = '0x1'    : Implement additional FGT traps introduced in ARMv8.9 (FEAT_FGT2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_fixed_function_instr_counter=0           # (int   , init-time) default = '0x0'    : Implement fixed-function instruction counter (FEAT_PMUv3_ICNTR)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_fp16=1                                   # (int   , init-time) default = '0x1'    : Implement the half-precision floating-point data processing instructions from ARMv8.2 (FEAT_FP16).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_fp16_fmlal=1                             # (int   , init-time) default = '0x1'    : Implement the New Floating Point Multiplication Variant (FP16 FMLAL, FMLSL) instructions from ARMv8.4. Only supported if has_fp16=0x1 (FEAT_FHM).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_frint=1                                  # (int   , init-time) default = '0x1'    : Implement floating-point rounding to int instructions (FRINT[32|64][X|Z]) from ARMv8.5 (FEAT_FRINTTS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_gcs=0                                    # (int   , init-time) default = '0x0'    : Implement Guarded Control Stack Extension from ARMv9.4 (FEAT_GCS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_generic_authentication=1                 # (int   , init-time) default = '0x1'    : Implement ARMv8.3 generic authentication.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_guest_translation_granule=1              # (int   , init-time) default = '0x1'    : Implement mechanism for guest translation granule identification from ARMv8.5, ID values determined by stage1 granule configuration parameters (FEAT_GTG).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_haft=0                                   # (int   , init-time) default = '0x0'    : Implement Hardware managed Access Flag for Table Descriptors (FEAT_HAFT)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_hardware_translation_table_update=2      # (int   , init-time) default = '0x2'    : Type of hardware translation table supported (when enabled by hardware_translation_table_update_implemented).  0, not implemented. 1, access bit updates implemented. 2, access bit updates and dirty bit mechanism implemented (FEAT_HAFDBS).
cluster1.has_hcrx_el2=1                               # (int   , init-time) default = '0x1'    : Implements new HCRX_EL2 id register from Armv8.7 (FEAT_HCX).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_hpmn0=0                                  # (int   , init-time) default = '0x0'    : Allow hypervisor to set MDCR_EL2.HPMN to 0 (FEAT_HPMN0)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_id_reg_read=1                            # (int   , init-time) default = '0x1'    : Implement read access to the ID registers  (ESR_ELx.EC=0x18) (FEAT_IDST)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_iesb=1                                   # (int   , init-time) default = '0x1'    : Implement support for implicit error sync event from ARMv8.2 (FEAT_IESB).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_itd=1                                    # (bool  , init-time) default = '1'      : Implement the optional IT disable feature.
cluster1.has_ite=0                                    # (int   , init-time) default = '0x0'    : Implement Instrumentation Trace Extension from ARMv9.4 (FEAT_ITE).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_jscvt=1                                  # (int   , init-time) default = '0x1'    : Implement ARMv8.3 javascript Floating-point to Integer conversion instruction (FEAT_JSCVT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_large_system_ext=0                       # (bool  , init-time) default = '0'      : Implement the ARMv8 Large System Extensions (FEAT_LSE).
cluster1.has_large_va=0                               # (int   , init-time) default = '0x0'    : Implement support for the extended 52-bit virtual addresses from ARMv8.2 (FEAT_LVA).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ldapur_stlur=1                           # (int   , init-time) default = '0x1'    : Implement support for LDAPR and STLR instructions with immediate offsets from ARMv8.4 (FEAT_LRCPC2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ldm_stm_ordering_control=0               # (int   , init-time) default = '0x0'    : Implement the SCTLR_ELx.LSMAOE (Load/Store Multiple Atomicity and Ordering Enable) and SCTLR_ELx,nTLSMD (no Trap Load/Store Multiple to Device) controls from ARMv8.2 (FEAT_LSMAOC).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_lrcpc=0                                  # (bool  , init-time) default = '0'      : If true then it support the RCpc feature from ARMv8.3 (FEAT_LRCPC).
cluster1.has_lrcpc3=0                                 # (int   , init-time) default = '0x0'    : Implement Release Consistency processor consistent (RCpc) feature from Armv8.9 (FEAT_LRCPC3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_mops_option=0                            # (int   , init-time) default = '0x0'    : Implement Armv8.8 standard instructions for memory operations (FEAT_MOPS). 0, not implemented (unsupported if Armv8.8 is enabled). 1, implemented using Option A. 2, implemented using Option B
cluster1.has_mpam=0                                   # (int   , init-time) default = '0x0'    : Implement ARMv8.4 MPAM Registers and associated functionality (FEAT_MPAM).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_mpmm=0                                   # (bool  , init-time) default = '0'      : Implement max-power mitigation mechanism (MPMM)
cluster1.has_mt_pmu_disable_feature=0                 # (int   , init-time) default = '0x0'    : Implements Multi-threading PMU disable extension from ARMv8.6 (FEAT_MTPMU). 0: FEAT_MTPMU is disabled, 1: FEAT_MTPMU is enabled if ARMv8.6 is implemented, 2: FEAT_MTPMU is cherry-picked, 0xF: The feature is disabled and is represented by value 0xF in ID_AA64DFR0_EL1.MTPMU.
cluster1.has_mte_async_faults=1                       # (bool  , init-time) default = '1'      : Whether MTE asynchronous faults are supported (FEAT_MTE_ASYNC)
cluster1.has_mte_ctrl_bits_stateful=0                 # (bool  , init-time) default = '0'      : if memory_tagging_support_level == 1, Whether mte specific control bits in system registers are stateful
cluster1.has_mte_perm=0                               # (bool  , init-time) default = '0'      : Implement tag access permission (FEAT_MTE_PERM)
cluster1.has_nested_virtualization=1                  # (int   , init-time) default = '0x1'    : Implement ARMv8.3 nested virtualization (FEAT_NV).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_nmi=1                                    # (int   , init-time) default = '0x1'    : Implement AARCH64 Non-Maskable Interrupts (FEAT_NMI)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_no_os_double_lock=0                      # (int   , init-time) default = '0x0'    : Do not implement the OS double-lock (FEAT_DoubleLock).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_non_context_synchronizing_exception_controls=1  # (int   , init-time) default = '0x1'    : Implement cosmetic controls for whether exception entry and exit are context synchronizing events (SCTLR_ELx.{EIS,EOS}) from ARMv8.5 (FEAT_ExS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_par_bit10_razwi=0                        # (bool  , init-time) default = '0'      : Whether PAR_EL1[10] is RAZ/WI
cluster1.has_partial_delayed_mdscr_el1=0              # (bool  , init-time) default = '0'      : has_delayed_oslar_el1 only apply to some bits of MDSCR_EL1 (MDE, KDE, TDCC, SS).
cluster1.has_pc_sample_based_profiling=1              # (bool  , init-time) default = '1'      : If true, pc sample-based profiling is enabled (FEAT_PCSRv8, FEAT_PCSRv8p2).
cluster1.has_pc_sample_profiling_enable=0             # (bool  , init-time) default = '0'      : Whether PC Sample profiling enable is implemented (FEAT_PCSRv8p9)
cluster1.has_per_cluster_debug_auth_ports=0           # (bool  , init-time) default = '0'      : If true then the debug authentication ports i.e. spniden, niden, rpliden, rtpiden, dbgen, spiden are available per cluster
cluster1.has_permission_indirection_s1=0              # (int   , init-time) default = '0x0'    : Implement the Permission Indirection Extension at stage 1 (FEAT_S1PIE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_permission_indirection_s2=0              # (int   , init-time) default = '0x0'    : Implement the Permission Indirection Extension at stage 2 (FEAT_S2PIE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_permission_overlay_s1=0                  # (int   , init-time) default = '0x0'    : Implement the Permission Overlay Extension at stage 1 (FEAT_S1POE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_permission_overlay_s2=0                  # (int   , init-time) default = '0x0'    : Implement the Permission Overlay Extension at stage 2 (FEAT_S2POE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_pmss=0                                   # (int   , init-time) default = '0x0'    : Implement PMU Snapshot Extension from Armv8.9 (FEAT_PMUv3_SS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_pmu=1                                    # (int   , init-time) default = '0x1'    : Implement the optional Performance Monitors Extension (FEAT_PMUv3). 0, Not Implemented. 1, Implemented. 2, PMU is IMPLEMENTATION_DEFINED, PMU version would be set to 0xF and would behave as if no PMU is implemented
cluster1.has_pmu_edge_detection=0                     # (int   , init-time) default = '0x0'    : Implement PMU Event edge detection (FEAT_PMUv3_EDGE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_pointer_authentication=1                 # (int   , init-time) default = '0x1'    : Implement ARMv8.3 pointer authentication (FEAT_PAuth).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.3 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_prediction_invalidation_instructions=1   # (int   , init-time) default = '0x1'    : Implement execution and data prediction invalidation from ARMv8.5 (FEAT_SPECRES).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_pstate_dit=1                             # (int   , init-time) default = '0x1'    : Implement timing insensitivity of data processing instructions from ARMv8.4 (FEAT_DIT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_pstate_pan=1                             # (int   , init-time) default = '0x1'    : Implement the PSTATE.PAN (Privileged Access Never) control from ARMv8.1 (FEAT_PAN)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.1 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_pstate_uao=1                             # (int   , init-time) default = '0x1'    : Implement the PSTATE.UAO (User Access Override) control from ARMv8.2 (FEAT_UAO).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_qarma3_pac=0                             # (bool  , init-time) default = '0'      : Supports QARMA3 pointer authentication algorithm (FEAT_PACQARMA3)
cluster1.has_ras=0                                    # (int   , init-time) default = '0x0'    : Implements the ARMv8 RAS Extension. 0 = NO_RAS, 1 = MINIMAL_RAS, 2 = FULL_RAS (FEAT_RAS)
cluster1.has_ras_aderr=0                              # (int   , init-time) default = '0x0'    : Implement RAS Asynchronous Device Read Error from Armv8.9 (FEAT_ADERR).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ras_anerr=0                              # (int   , init-time) default = '0x0'    : Implement RAS Asynchronous Normal Read Error from Armv8.9 (FEAT_ANERR).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ras_armv84_extension=1                   # (int   , init-time) default = '0x1'    : Implement ARMv8.4 RAS Extension (FEAT_RASv1p1).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ras_armv89_double_fault=0                # (int   , init-time) default = '0x0'    : Implement RAS Double Fault Extension from Armv8.9 (FEAT_DoubleFault2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ras_armv89_extension=0                   # (int   , init-time) default = '0x0'    : Implement RAS extension from Armv8.9 (FEAT_RASv2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ras_critical_error=0                     # (int   , init-time) default = '0x0'    : [DEPRECATED: Set CI field on first register in error_record_feature_register JSON instead] ARMv8.4 AArch64 RAS Critical Error is implemented or not. 0 - Feature Not Supported, 1 - Feature always enabled, 2 - Feature is controllable.
cluster1.has_ras_double_fault=1                       # (int   , init-time) default = '0x1'    : Implement ARMv8.4 RAS Double Fault Extension (FEAT_DoubleFault).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ras_fault_injection=0                    # (int   , init-time) default = '0x0'    : [DEPRECATED: Set INJ field on first register in error_record_feature_register JSON instead] Implement ARMv8.4 Standard Fault Injection mechanism.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ras_pfar=0                               # (int   , init-time) default = '0x0'    : Implement RAS Physical Fault Address Registers from Armv8.9 (FEAT_PFAR).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ras_rpz=0                                # (int   , init-time) default = '0x0'    : Implement RAS Remove Poison and Zero from Armv8.9 (FEAT_RPZ).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_ras_timestamp=0                          # (int   , init-time) default = '0x0'    : [DEPRECATED: Set TS field on first register in error_record_feature_register JSON instead] ARMv8.4 AArch64 RAS Timestamp register is implemented or not. 0 - No Timestamp is recorded, 1 - Generic Timer timestamp is recorded, 2 - IMP DEF timestamp is recorded.
cluster1.has_restriction_on_speculative_data_loaded=1  # (int   , init-time) default = '0x1'    : Implements the ARMv8.5 security feature (Restrictions on the effects of speculation) (FEAT_CSV3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_rme=0                                    # (bool  , init-time) default = '0'      : If true, implements full realm management extension (FEAT_RME). Note: This parameter is deprecated and will be removed in future releases, please use rme_support_level parameter.
cluster1.has_rndr=0                                   # (int   , init-time) default = '0x0'    : Implement random number instructions to read from RNDR and RNDRSS random number registers from ARMv8.5 (FEAT_RNG).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_rndr_trap=0                              # (int   , init-time) default = '0x0'    : Implement trapping for RNDR and RNDRSS random number registers from ARMv8.8. (FEAT_RNG_TRAP)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_rounding_doubling_multiply_add_subtract=1  # (int   , init-time) default = '0x1'    : Implement the rounding doubling multiply add and subtract instructions from ARMv8.1 (FEAT_RDM).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.1 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_rprfm=0                                  # (bool  , init-time) default = '0'      : Support for RPRFM hint instruction (FEAT_RPRFM)
cluster1.has_sctlr2=0                                 # (int   , init-time) default = '0x0'    : Implement SCTLR2_ELx registers (FEAT_SCTLR2)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_sebep=0                                  # (int   , init-time) default = '0x0'    : Implement Synchronous-Exception-Based Event Profiling from ARMv9.4 (FEAT_SEBEP).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_secure_el2=1                             # (int   , init-time) default = '0x1'    : Implement support for Secure EL2 (FEAT_SEL2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_self_hosted_trace_extension=1            # (int   , init-time) default = '0x1'    : Implement support for the Self-hosted Trace Extensions from ARMv8.4 (FEAT_TRF).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_slc_hint=0                               # (int   , init-time) default = '0x0'    : Implement System Cache Location Hint (FEAT_SLCHINT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_small_page_table=1                       # (int   , init-time) default = '0x1'    : Implement small page table support which increases the maximum value of TxSZ field from ARMv8.4 (FEAT_TTST). Note: will be unimplemented only if both has_small_page_table=0x0 and has_secure_el2=0x0.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_software_lock=1                          # (bool  , init-time) default = '1'      : Implement software lock in memory-mapped CTI, PMU, and external debug interfaces
cluster1.has_spe_fds=1                                # (int   , init-time) default = '0x1'    : Implement SPE filter by data source from ARMv8.9 (FEAT_SPE_FDS)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_speculation_barrier_inst=1               # (int   , init-time) default = '0x1'    : Implement speculation barrier instruction (SB) from ARMv8.5 (FEAT_SB).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_speculative_sei=0                        # (bool  , init-time) default = '0'      : If true, the PE can generate SError interrupt exceptions from speculative reads of memory, including speculative instruction fetches
cluster1.has_spmu=0                                   # (int   , init-time) default = '0x0'    : Implement System PMU Extension from Armv8.9 (FEAT_SPMU).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_stage2_ap_speculative_update=0           # (bool  , init-time) default = '0'      : If true, stage1 TTW can speculatively update stage2 AP bit
cluster1.has_stage2_fwb=1                             # (int   , init-time) default = '0x1'    : Implement HCR_EL2.FWB, stage 2 control of memory types and cacheability (FEAT_S2FWB)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_stage2_xnx=1                             # (int   , init-time) default = '0x1'    : Implement the extended XN[1:0] stage 2 control from ARMv8.2 (FEAT_XNX).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.2 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_stage2_xnx_in_aarch32=1                  # (bool  , init-time) default = '1'      : Implement the extended XN[1:0] stage 2 control from ARMv8.2 for Aarch32 (FEAT_XNX).
cluster1.has_statistical_profiling=1                  # (bool  , init-time) default = '1'      : Whether Statistical Based Profiling is implemented (FEAT_SPE).
cluster1.has_supersections=1                          # (bool  , init-time) default = '1'      : Whether VMSAv8-32 supersection to support more than 32-bit PA using short descriptor is implemented.
cluster1.has_synchronous_load_atomics=1               # (bool  , init-time) default = '1'      : Report asynchronous abort due to unsupported load atomics as synchronous (Cacheable)
cluster1.has_synchronous_load_atomics_noncacheable=1  # (bool  , init-time) default = '1'      : Report asynchronous abort due to unsupported load atomics as synchronous (Non-Cacheable)
cluster1.has_synchronous_store_atomics=0              # (bool  , init-time) default = '0'      : Report asynchronous abort due to unsupported store atomics as synchronous (Cacheable)
cluster1.has_synchronous_store_atomics_noncacheable=0  # (bool  , init-time) default = '0'      : Report asynchronous abort due to unsupported store atomics as synchronous (Non-Cacheable)
cluster1.has_sysinstr128=0                            # (int   , init-time) default = '0x0'    : Support for System Instructions that can take 128-bit inputs (FEAT_SYSINSTR128)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_sysreg128=0                              # (int   , init-time) default = '0x0'    : Support for 128-bit System Registers (FEAT_SYSREG128)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_tcr2=0                                   # (int   , init-time) default = '0x0'    : Implement TCR2_ELx registers (FEAT_TCR2)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_tidcp1=1                                 # (int   , init-time) default = '0x1'    : Implement Armv8.8 EL0 use of implementation defined functionality (FEAT_TIDCP1)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_tlb_conflict_abort=0                     # (bool  , init-time) default = '0'      : Detected inconsistent TLB content generate aborts.
cluster1.has_tlb_pa_caching=0                         # (bool  , init-time) default = '0'      : Whether intermediate caching of translation table walks might include NonCoherent caches of previous valid walks. 0, NonCoherent caches might be included. 1, No NonCoherent caches included (FEAT_nTLBPA)
cluster1.has_tlbi_range=1                             # (int   , init-time) default = '0x1'    : Implement support for TLB Range Maintenance instructions (TLBI RVAE1, etc) from ARMv8.4 (FEAT_TLBIRANGE).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_tlbi_to_outer_shareable=1                # (int   , init-time) default = '0x1'    : Implement support for TLB Maintenance instructions that extend to the Outer Shareable domain (TLBI VAE1OS, etc) from ARMv8.4 (FEAT_TLBIOS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_tlbi_ttl=1                               # (int   , init-time) default = '0x1'    : Implement support for the TTL level hint in by-address TLB Maintenance instructions from ARMv8.4 (FEAT_TTL).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_tme=0                                    # (bool  , init-time) default = '0'      : If true, implements TME, the Transactional Memory Extension (FEAT_TME).
cluster1.has_translation_hardening=0                  # (int   , init-time) default = '0x0'    : Implement the Translation Hardening Extension (FEAT_THE)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_trbe=0                                   # (bool  , init-time) default = '0'      : If true, implements the Trace Buffer Extension (FEAT_TRBE).
cluster1.has_trbe_ext=0                               # (int   , init-time) default = '0x0'    : Implements the Trace Buffer external mode extension (FEAT_TRBE_EXT).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if Armv9.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_unaligned_single_copy_atomicity=1        # (int   , init-time) default = '0x1'    : Implement support for SCTLR_ELx.nAA from ARMv8.4, and A64 atomic, exclusive and acquire/release instructions accessing unaligned bytes inside a 16byte window will not generate alignment fault (FEAT_LSE2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_unsupported_exclusive_fault=1            # (bool  , init-time) default = '1'      : Report unsupported exclusive access with Unsupported Exclusive fault status (otherwise use external abort)
cluster1.has_v8_4_debug_extension=1                   # (int   , init-time) default = '0x1'    : Implement ARMv8.4 debug extensions (FEAT_Debugv8p4)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_4_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.4 (FEAT_PMUv3p4).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_5_debug_over_power_down=0             # (int   , init-time) default = '0x0'    : Implement ARMv8.5 Debug over powerdown (FEAT_DoPD).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_5_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.5 (FEAT_PMUv3p5).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_5_spe_extension=1                     # (int   , init-time) default = '0x1'    : Implement SPE extension from ARMv8.5 (FEAT_SPEv1p1).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.5 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_6_pmu_events=1                        # (int   , init-time) default = '0x1'    : Implements PMU events from ARMv8.6
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_7_fp_enhancements=1                   # (int   , init-time) default = '0x1'    : Implements the Floating Point enhancements from Armv8.7 (introduces FPCR.FIZ/AH/NEP, etc. (FEAT_AFP).)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_7_pmu_events=1                        # (int   , init-time) default = '0x1'    : Implement PMU events from ARMv8.7.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_7_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.7 (FEAT_PMUv3p7).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_7_spe_extension=1                     # (int   , init-time) default = '0x1'    : Implement SPE extension from ARMv8.7 (FEAT_SPEv1p2)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_7_spe_previous_branch_target=1        # (bool  , init-time) default = '1'      : Where FEAT_SPEv1p2 is implemented, whether the optional branch target feature is implemented
cluster1.has_v8_8_debug_extension=1                   # (int   , init-time) default = '0x1'    : Implement ARMv8.8 debug extensions (FEAT_Debugv8p8)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_8_pmu_events=1                        # (int   , init-time) default = '0x1'    : Implement PMU events from ARMv8.8 (FEAT_PMUv3).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_8_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.8 (FEAT_PMUv3p8).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_8_spe_extension=1                     # (int   , init-time) default = '0x1'    : Implement SPE extension from ARMv8.8 (FEAT_SPEv1p3)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.8 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_9_debug_extension=1                   # (int   , init-time) default = '0x1'    : Implement ARMv8.9 debug extensions (FEAT_Debugv8p9)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if ARMv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_9_pc_sample_based_profiling=1         # (int   , init-time) default = '0x1'    : Implement PC Sample-based Profiling from ARMv8.9 (FEAT_PCSRv8p9)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_9_pmu_extension=1                     # (int   , init-time) default = '0x1'    : Implement PMU extension from ARMv8.9 (FEAT_PMUv3p9).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_v8_9_spe_extension=1                     # (int   , init-time) default = '0x1'    : Implement SPE extension from ARMv8.9 (FEAT_SPEv1p4)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.9 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_vncr_el2=1                               # (int   , init-time) default = '0x1'    : Implement support for nested virtualization enhancements from ARMv8.4 (FEAT_NV2).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_wfet_and_wfit=1                          # (int   , init-time) default = '0x1'    : Implements WFE and WFI with Timeout from Armv8.7 (FEAT_WFxT)
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.has_writebuffer=0                            # (bool  , init-time) default = '0'      : Implement write accesses buffering before L1 cache. May affect ext_abort behaviour.
cluster1.has_xs=1                                     # (int   , init-time) default = '0x1'    : Implements Armv8.7 XS, TLBInXS, DSBnXS instruction (FEAT_XS).
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 1, feature is implemented if Armv8.7 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.hcptr_tta_behaviour=2                        # (int   , init-time) default = '0x2'    : Behaviour of HCPTR.TTA when there is no CP14 ETM interface. 0, RAZ/WI. 1, RAO/WI. 2, stateful.
cluster1.hcr_el2_miocnce_is_rw=0                      # (bool  , init-time) default = '0'      : If true, HCR_EL2.MIOCNCE is treated as R/W instead of RAZ/WI
cluster1.hcr_swio_res1=0                              # (bool  , init-time) default = '0'      : Whether HCR.SWIO and/or HCR_EL2.SWIO are RES1.
cluster1.hsr_uncond_cc=0                              # (bool  , init-time) default = '0'      : Condition codes reported in HSR as AL if it passes
cluster1.hvbar_reset_is_rvbar=0                       # (bool  , init-time) default = '0'      : If true then the reset value of HVBAR is RVBAR, if false the reset value is UNKNOWN.
cluster1.icache-hit_latency=0                         # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when icache-state_modelled=true.
cluster1.icache-log2linelen=0                         # (int   , init-time) default = '0x0'    : If nonzero, Log2 of the instruction cache line length in bytes (valid values in range 4-8).  Otherwise the value of cache-log2linelen is used.
cluster1.icache-maintenance_latency=0                 # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when icache-state_modelled=true.
cluster1.icache-miss_latency=0                        # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when icache-state_modelled=true.
cluster1.icache-nprefetch=1                           # (int   , init-time) default = '0x1'    : Number of next sequential instruction cache lines to prefetch. This is only used when icache-prefetch_enabled=true.
cluster1.icache-prefetch_enabled=0                    # (bool  , init-time) default = '0'      : Enable simulation of instruction cache prefetching. This is only used when icache-state_modelled=true.
cluster1.icache-prefetch_level=0                      # (int   , init-time) default = '0x0'    : 0 based cache level at which instructions are pre-fetched. This is only used when icache-prefetch_enabled=true.
cluster1.icache-read_access_latency=0                 # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for read accesses given in ticks per access (of size icache-read_bus_width_in_bytes).  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if icache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when icache-state_modelled=true.
cluster1.icache-read_bus_width_in_bytes=8             # (int   , init-time) default = '0x8'    : L1 I-Cache read bus width in bytes used to calculate per-access timing annotations
cluster1.icache-read_latency=0                        # (int   , run-time ) default = '0x0'    : L1 I-Cache timing annotation latency for read accesses given in ticks per byte accessed.icache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when icache-state_modelled=true.
cluster1.icache-size=32768                            # (int   , init-time) default = '0x8000' : L1 I-Cache size in bytes.
cluster1.icache-ways=2                                # (int   , init-time) default = '0x2'    : L1 I-Cache number of ways (sets are implicit from size).
cluster1.ignore_DBGPRCR_CWRR=0                        # (bool  , init-time) default = '0'      : Ignore writes to the deprecated DBGPRCR.CWRR bit.
cluster1.ignore_access_flag_update_by_at_ops=0        # (bool  , init-time) default = '0'      : If true, AT operations do not update access flag
cluster1.ignore_large_address_top_bits_in_page_walk=0  # (bool  , init-time) default = '0'      : Whether page table bits [15:12] are ignored if PA_SIZE < 52 and output address is configured < 52 with large page
cluster1.ignore_tag_check_dcc_load_store_in_ma_mode_when_tco_is_disabled=0  # (bool  , init-time) default = '0'      : Constrained unpredictable behavior for reads/writes to external debug interface DTR regs in memory access mode when PSTATE.TCO is 0. If true, tag check is ignored else, tag check is performed if required.
cluster1.ignore_traps_to_dcc_regs_in_debug=0          # (bool  , init-time) default = '0'      : Whether traps get ignored for the following registers in debug state:
                                                      #                                        : * AArch64: MDCCSR_EL0, OSDTREX_EL1, OSDTRTX_EL1, MDCCINT_EL1.
                                                      #                                        : * AArch32: DBGDSCRint, DBGDIDR, DBGDSAR, DBGDRAR,
                                                      #                                        : DBGDTRRXext, DBGDTRTXext, DBGDCCINT.
cluster1.imp_def_functionality_behaviour=0            # (int   , init-time) default = '0x0'    : Behaviour of IMPLEMENTATION DEFINED registers and system instructions.  0, UNDEF.  1, RAZ/WI.
cluster1.impdef_regs_and_unpred_from_implementation=  # (string, init-time) default = ''       : Configure implementation defined registers and unpredictable behaviour to match the specified implementation. Requires a license for the selected implementation model.User has to provide the default values for the published or configurable parameters through commandline arguments. Use ARM_Cortex-A<num> or ARM_<codename> for licensed pre-release cores.
cluster1.independent_cache_control_traps=0            # (int   , init-time) default = '0x0'    : Implement Independent Cache Control traps from ARMv8.5. 0, NO_SUPPORT. 1, SUPPORTED_BUT_NOT_FOR_TLB_MAINTENANCE_INSTRUCTIONS. 2, FULL_SUPPORT. (FEAT_EVT)
cluster1.insert_iesb_before_exception=0               # (bool  , init-time) default = '0'      : If true then inserts an IESB before taking with Exception otherwise has no effect and IESB is taken after PState is changed due to the Exception.
cluster1.instruction_tlb_size=0                       # (int   , init-time) default = '0x0'    : Number of stage1+2 itlb entries (or 0 for unified ITLB+DTLB)
cluster1.is_first_pcsr_sample_ignored=0               # (bool  , init-time) default = '0'      : If true, First read of PMPCSR register after reset returns 0xFFFFFFFF
cluster1.is_mt_res0=0                                 # (bool  , init-time) default = '0'      : If ARMv8.6 is not implemented, and PMUv3 is implemented, this parameter controls whether PMEVTYPER<n>.MT bit is RES0 or RW. For other implementations, this parameter has no effect
cluster1.is_tagged_nsh_treated_as_tagged=1            # (bool  , init-time) default = '1'      : Whether a tagged NonShared memory attribute is treated as tagged or not
cluster1.is_uniprocessor=0                            # (bool  , init-time) default = '0'      : Value for the U bit in MPIDR. true disables L1 cache coherency protocols
cluster1.isb_is_branch=0                              # (bool  , init-time) default = '0'      : If true, ISB is traced as an immediate branch. This allows to count ISB as a branch in debug extensions (e.g. PMU)
cluster1.ish_is_osh=0                                 # (bool  , init-time) default = '0'      : Whether Innershareable is same as OuterShareable
cluster1.itd_conditional_instructions_are_32bit=0     # (bool  , init-time) default = '0'      : When SCTLR_ELx.ITD=1, an IT instruction plus a T16 instruction are considered a single 32bit conditional instruction.
cluster1.jidr_is_undef_at_el0=0                       # (bool  , init-time) default = '0'      : If true, JIDR register access is UNDEF at EL0
cluster1.jmcr_is_undef_at_el0=0                       # (bool  , init-time) default = '0'      : If true, JMCR register access is UNDEF at EL0
cluster1.joscr_is_undef_at_el0=0                      # (bool  , init-time) default = '0'      : If true, JOSCR register access is UNDEF at EL0
cluster1.l2cache-hit_latency=0                        # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when dcache-state_modelled=true.
cluster1.l2cache-maintenance_latency=0                # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when dcache-state_modelled=true.
cluster1.l2cache-miss_latency=0                       # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when dcache-state_modelled=true.
cluster1.l2cache-read_access_latency=0                # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for read accesses given in ticks per access.  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l2cache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when dcache-state_modelled=true.
cluster1.l2cache-read_bus_width_in_bytes=8            # (int   , init-time) default = '0x8'    : L2 Cache read bus width in bytes used to calculate per-access timing annotations
cluster1.l2cache-read_latency=0                       # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for read accesses given in ticks per byte accessed.l2cache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when dcache-state_modelled=true.
cluster1.l2cache-size=524288                          # (int   , init-time) default = '0x80000' : L2 Cache size in bytes.
cluster1.l2cache-snoop_data_transfer_latency=0        # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for received snoop accesses that perform a data transfer given in ticks per byte accessed. This is only used when dcache-state_modelled=true.
cluster1.l2cache-snoop_issue_latency=0                # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for snoop accesses issued by this cache in total ticks. This is only used when dcache-state_modelled=true.
cluster1.l2cache-ways=16                              # (int   , init-time) default = '0x10'   : L2 Cache number of ways (sets are implicit from size).
cluster1.l2cache-write_access_latency=0               # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for write accesses given in ticks per access. If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l2cache-write_latency is set. This is only used when dcache-state_modelled=true.
cluster1.l2cache-write_bus_width_in_bytes=8           # (int   , init-time) default = '0x8'    : L2 Cache write bus width in bytes used to calculate per-access timing annotations
cluster1.l2cache-write_latency=0                      # (int   , run-time ) default = '0x0'    : L2 Cache timing annotation latency for write accesses given in ticks per byte accessed. l2cache-write_access_latency must be set to 0 for per-byte latencies to be applied. This is only used when dcache-state_modelled=true.
cluster1.l3cache-has_mpam=0                           # (bool  , init-time) default = '0'      : L3 Cache has MPAM support
cluster1.l3cache-hit_latency=0                        # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for hit.  Intended to model the tag-lookup time.  This is only used when dcache-state_modelled=true.
cluster1.l3cache-maintenance_latency=0                # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for cache maintenance operations given in total ticks. This is only used when dcache-state_modelled=true.
cluster1.l3cache-miss_latency=0                       # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for miss.  Intended to model the time for failed tag-lookup and allocation of intermediate buffers.  This is only used when dcache-state_modelled=true.
cluster1.l3cache-mpamf.bwa_width_ns=16                # (int   , init-time) default = '0x10'   : L3 Cache width of MPAM bandwidth allocation fields for non-secure accesses.
cluster1.l3cache-mpamf.bwa_width_s=16                 # (int   , init-time) default = '0x10'   : L3 Cache width of MPAM bandwidth allocation fields for secure accesses.
cluster1.l3cache-mpamf.cmax_width_ns=0                # (int   , init-time) default = '0x0'    : L3 Cache number of fractional bits in MPAM cache capacity partition control for non-secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cluster1.l3cache-mpamf.cmax_width_s=0                 # (int   , init-time) default = '0x0'    : L3 Cache number of fractional bits in MPAM cache capacity partition control for secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cluster1.l3cache-mpamf.cpbm_width_ns=0                # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for non-secure accesses. If 0, the feature is not implemented, and all ways are available.
cluster1.l3cache-mpamf.cpbm_width_rl=0                # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for realm accesses. If 0, the feature is not implemented, and all ways are available.
cluster1.l3cache-mpamf.cpbm_width_rt=0                # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for root accesses. If 0, the feature is not implemented, and all ways are available.
cluster1.l3cache-mpamf.cpbm_width_s=0                 # (int   , init-time) default = '0x0'    : L3 Cache width of MPAM cache portion bitmap for secure accesses. If 0, the feature is not implemented, and all ways are available.
cluster1.l3cache-mpamf.csu_num_mon_ns=0               # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for non-secure accesses.
cluster1.l3cache-mpamf.csu_num_mon_rl=0               # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for realm accesses.
cluster1.l3cache-mpamf.csu_num_mon_rt=0               # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for root accesses.
cluster1.l3cache-mpamf.csu_num_mon_s=0                # (int   , init-time) default = '0x0'    : L3 Cache number of MPAM cache storage usage monitors for secure accesses.
cluster1.l3cache-mpamf.has_esr=0                      # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_ESR, MPAMF_ECR, and MPAM error handling implemented.
cluster1.l3cache-mpamf.has_extd_esr=0                 # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_ESR is 64-bits.
cluster1.l3cache-mpamf.has_impl_idr=0                 # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_IMPL_IDR is present.
cluster1.l3cache-mpamf.has_mbwu_long_counter=0        # (bool  , init-time) default = '0'      : L3 Cache has long MBWU counter and capture registers.
cluster1.l3cache-mpamf.has_mpamfidr_ext=0             # (bool  , init-time) default = '0'      : MPAMF_IDR.EXT support
cluster1.l3cache-mpamf.has_partid_nrw=0               # (bool  , init-time) default = '0'      : Narrowing part ID register is present. This is global rather than per-instance.
cluster1.l3cache-mpamf.has_priority_partioning=0      # (bool  , init-time) default = '0'      : The selected resource has priority partitioning described in MPAMF_PRI_IDR.
cluster1.l3cache-mpamf.has_prod_id=0                  # (int   , init-time) default = '0x0'    : L3 Cache MPAMF_IIDR product ID supported.
cluster1.l3cache-mpamf.has_prod_rev=0                 # (int   , init-time) default = '0x0'    : L3 Cache MPAMF_IIDR product REVISION supported.
cluster1.l3cache-mpamf.has_prod_var=0                 # (int   , init-time) default = '0x0'    : L3 Cache MPAMF_IIDR product VARIENT supported.
cluster1.l3cache-mpamf.has_prop_ns=0                  # (bool  , init-time) default = '0'      : Enable memory bandwidth proportional stride control for non-secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cluster1.l3cache-mpamf.has_prop_s=0                   # (bool  , init-time) default = '0'      : Enable memory bandwidth proportional stride control for secure accesses. Only the register interface  is implemented - the control is NOT FUNCTIONAL.
cluster1.l3cache-mpamf.has_ris=0                      # (bool  , init-time) default = '0'      : L3 Cache has resource instance selection support.
cluster1.l3cache-mpamf.max_partid_ns=65535            # (int   , init-time) default = '0xffff' : L3 Cache Maximum value of non-secure PARTID supported.
cluster1.l3cache-mpamf.max_partid_rl=65535            # (int   , init-time) default = '0xffff' : L3 Cache Maximum value of realm PARTID supported for RME implementations.
cluster1.l3cache-mpamf.max_partid_rt=65535            # (int   , init-time) default = '0xffff' : L3 Cache Maximum value of root PARTID supported for RME implementations.
cluster1.l3cache-mpamf.max_partid_s=65535             # (int   , init-time) default = '0xffff' : L3 Cache Maximum value of secure PARTID supported.
cluster1.l3cache-mpamf.max_pmg_ns=255                 # (int   , init-time) default = '0xff'   : L3 Cache Maximum value of non-secure PMG supported.
cluster1.l3cache-mpamf.max_pmg_rl=255                 # (int   , init-time) default = '0xff'   : L3 Cache Maximum value of realm PMG supported for RME implementations.
cluster1.l3cache-mpamf.max_pmg_rt=255                 # (int   , init-time) default = '0xff'   : L3 Cache Maximum value of root PMG supported for RME implementations.
cluster1.l3cache-mpamf.max_pmg_s=255                  # (int   , init-time) default = '0xff'   : L3 Cache Maximum value of secure PMG supported.
cluster1.l3cache-mpamf.mbwu_long_counter_width=0      # (int   , init-time) default = '0x0'    : L3 Cache long MBWU counter width. 0: 63 bits, 1: 44 bits.
cluster1.l3cache-mpamf.no_impl_msmon=0                # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_IMPL_IDR does not describe resource monitors.
cluster1.l3cache-mpamf.no_impl_part=0                 # (bool  , init-time) default = '0'      : L3 Cache's MPAMF_IMPL_IDR does not describe resource partitioning controls.
cluster1.l3cache-mpamf.ris_max=0                      # (int   , init-time) default = '0x0'    : L3 Cache's largest resource instance selector value defined.
cluster1.l3cache-mpamf_base=0                         # (int   , init-time) default = '0x0'    : L3 Cache memory mapped MPAM registers base address
cluster1.l3cache-read_access_latency=0                # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for read accesses given in ticks per access (of size l3cache-read_bus_width_in_bytes).  If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l3cache-read_latency is set. This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus, this is only used when dcache-state_modelled=true.
cluster1.l3cache-read_bus_width_in_bytes=8            # (int   , init-time) default = '0x8'    : L3 Cache read bus width in bytes used to calculate per-access timing annotations
cluster1.l3cache-read_latency=0                       # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for read accesses given in ticks per byte accessed.l3cache-read_access_latency must be set to 0 for per-byte latencies to be applied.  This is in addition to the hit or miss latency, and intended to correspond to the time taken to transfer across the cache upstream bus. This is only used when dcache-state_modelled=true.
cluster1.l3cache-size=0                               # (int   , init-time) default = '0x0'    : L3 Cache size in bytes.
cluster1.l3cache-snoop_data_transfer_latency=0        # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for received snoop accesses that perform a data transfer given in ticks per byte accessed. This is only used when dcache-state_modelled=true.
cluster1.l3cache-snoop_issue_latency=0                # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for snoop accesses issued by this cache in total ticks. This is only used when dcache-state_modelled=true.
cluster1.l3cache-ways=16                              # (int   , init-time) default = '0x10'   : L3 Cache number of ways (sets are implicit from size).
cluster1.l3cache-write_access_latency=0               # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for write accesses given in ticks per access (of size l3cache-write_bus_width_in_bytes). If this parameter is non-zero, per-access latencies will be used instead of per-byte even if l3cache-write_latency is set. This is only used when dcache-state_modelled=true.
cluster1.l3cache-write_bus_width_in_bytes=8           # (int   , init-time) default = '0x8'    : L3 Cache write bus width in bytes used to calculate per-access timing annotations
cluster1.l3cache-write_latency=0                      # (int   , run-time ) default = '0x0'    : L3 Cache timing annotation latency for write accesses given in ticks per byte accessed. l3cache-write_access_latency must be set to 0 for per-byte latencies to be applied. This is only used when dcache-state_modelled=true.
cluster1.legacy_combining_exc_catch_trace=1           # (bool  , init-time) default = '1'      : Whether exception catch is traced as part of exception entry/exit in same cycle
cluster1.log2_trace_buffer_alignment=0                # (int   , init-time) default = '0x0'    : Log2 of trace buffer alignment constraint for output buffer (0->1B ... 11->2Kib)
cluster1.max_32bit_el=3                               # (int   , init-time) default = '0x3'    : Maximum exception level supporting AArch32 modes. -1: No Support for A32 at any EL, x:[0:3] - All the levels below supplied ELx supports A32
cluster1.mdselr_le_16_bps_wps_behaviour=0             # (int   , init-time) default = '0x0'    : Behaviour of MDSELR_EL1 and related traps/enables if fewer than 16 watchpoints and fewer than 16 breakpoints are implemented: 0 - MDSELR_EL1 is stateful 1 - MDSELR_EL1, EBWE, FGTS are RAZ/WI, traps and enables do not apply
cluster1.mec_support_level=0                          # (int   , init-time) default = '0x0'    : 0 -> Memory Encryption Contexts not implemented,  1 -> LEGACY_TZ_EN mode i.e. MEC register fields are stateful but only supports secure/non-secure states, 2 -> Memory Encryption Contexts fully implemented (FEAT_MEC).
cluster1.memory.acp.AxCACHE_mask=0                    # (int   , init-time) default = '0x0'    : Used with memory.acp.AxCACHE_pattern to define which memory types the ACP port accepts. All transactions which do not satisfy (AxCACHE & mask) == pattern will abort.
cluster1.memory.acp.AxCACHE_pattern=0                 # (int   , init-time) default = '0x0'    : Used with memory.acp.AxCACHE_mask to define which memory types the ACP port accepts. All transactions which do not satisfy (AxCACHE & mask) == pattern will abort.
cluster1.memory.l2_cache.is_inner_cacheable=1         # (bool  , init-time) default = '1'      : L2 cache obeys inner cacheable attributes (rather than outer cacheable attributes)
cluster1.memory.l2_cache.is_inner_shareable=1         # (bool  , init-time) default = '1'      : L2 cache obeys inner shareable attributes (rather than outer shareable attributes)
cluster1.memory_tagging_support_level=0               # (int   , init-time) default = '0x0'    : Specify the memory tagging extension support level: 0, not implemented. 1, instructions and registers only are implemented (FEAT_MTE). 2, implemented (FEAT_MTE2). 3, implemented with asymmetric handling of exceptions. 4, implemented (FEAT_MTE4).
cluster1.mixed_endian=1                               # (int   , init-time) default = '0x1'    : Implement support for mixed endianness. 0, not supported. 1, supported at all exception levels. 2, supported at EL0 only.
cluster1.mops_cpy_block_size=64                       # (int   , init-time) default = '0x40'   : Block size used for memcpy memory accesses
cluster1.mops_cpy_default_dir=0                       # (int   , init-time) default = '0x0'    : Default direction for non-overlapping memcpy operations: 0, forwards. 1, backwards
cluster1.mops_cpy_handle_async_exceptions=0           # (bool  , init-time) default = '0'      : Handle any pending async exceptions after copying a block of data, instad of waiting until instruction end.
cluster1.mops_cpy_post_size=10                        # (int   , init-time) default = '0xa'    : Percentage of data copied in memcpy 'E' instructions
cluster1.mops_cpy_pre_size=10                         # (int   , init-time) default = '0xa'    : Percentage of data copied in memcpy 'P' instructions
cluster1.mops_cpy_single_access=0                     # (bool  , init-time) default = '0'      : Execute memcpy as a single read and single write access
cluster1.mops_cpy_write_abort_before_read=0           # (bool  , init-time) default = '0'      : Report the data aborts and watchpoint of the write accesses, before those of the read accesses
cluster1.mops_cpy_zero_size_can_fault=1               # (bool  , init-time) default = '1'      : Fault because of mismatched implementation option when the operation is of size 0.
cluster1.mops_exec_order_can_fault=0                  # (bool  , init-time) default = '0'      : Enable exception on the Main/Epilogue instruction when executed after a mismatched Prologue/Main in a CPY/SET sequence, or after another random instruction
cluster1.mops_mmu_abort_far_aligned=0                 # (bool  , init-time) default = '0'      : If true, in case of an MMU abort on a MOPS instruction, report FAR aligned to current translation granule.
cluster1.mops_set_block_size=64                       # (int   , init-time) default = '0x40'   : Block size used for memset memory accesses
cluster1.mops_set_handle_async_exceptions=0           # (bool  , init-time) default = '0'      : Handle any pending async exceptions after setting a block of data, instad of waiting until instruction end.
cluster1.mops_set_post_size=10                        # (int   , init-time) default = '0xa'    : Percentage of data copied in memset 'E' instructions
cluster1.mops_set_pre_size=10                         # (int   , init-time) default = '0xa'    : Percentage of data copied in memset 'P' instructions
cluster1.mops_set_single_access=0                     # (bool  , init-time) default = '0'      : Execute memset as a single read and single write access
cluster1.mops_set_zero_size_can_fault=1               # (bool  , init-time) default = '1'      : Fault because of mismatched implementation option when the operation is of size 0.
cluster1.mops_setg_unaligned_does_mismatch_fault=0    # (bool  , init-time) default = '0'      : If true, in case of unaligned SETGM / SETGE, raise a mismatched memset exception because of impdef reasons, instead of alignment fault
cluster1.mops_wp_far_behaviour=0                      # (int   , init-time) default = '0x0'    : Set option for address stored in FAR/EDWARD after watchpoints hit by MOPS instructions
                                                      #                                        :  0 - FAR recorded matches lowest watchpointed address accessed by the instruction
                                                      #                                        :  1 - FAR recorded matches lowest address accessed by the instruction within same translation granule as watchpointed address
                                                      #                                        :  2 - FAR recorded matches highest watchpointed address accessed by the instruction that triggered the watchpoint
cluster1.mpam_force_ns_rao=0                          # (bool  , init-time) default = '0'      : Whether MPAM3_EL3.FORCE_NS bit is RAO/WI.
cluster1.mpam_frac=0                                  # (int   , init-time) default = '0x0'    : MPAM fractional revision number in ID_AA64PFR1_EL1.MPAM_frac field
cluster1.mpam_has_altsp=0                             # (bool  , init-time) default = '0'      : MPAM Whether MPAMIDR_EL1.HAS_ALTSP bit is set or clear
cluster1.mpam_has_hcr=0                               # (bool  , init-time) default = '0'      : MPAM Whether MPAMIDR_EL1 HAS_HCR bit is set or clear
cluster1.mpam_max_partid=65535                        # (int   , init-time) default = '0xffff' : MPAM Maximum PARTID Supported
cluster1.mpam_max_pmg=255                             # (int   , init-time) default = '0xff'   : MPAM Maximum PMG Supported
cluster1.mpam_max_vpmr=0                              # (int   , init-time) default = '0x0'    : MPAM Maximum VPMR Supported
cluster1.mpamidr_has_force_ns=0                       # (int   , init-time) default = '0x0'    : Whether MPAMIDR_EL1.HAS_FORCE_NS bit is set or clear.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.mpamidr_has_sdeflt=0                         # (int   , init-time) default = '0x0'    : Whether MPAMIDR_EL1.HAS_SDEFLT bit is set or clear.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.mpamidr_has_tidr=0                           # (int   , init-time) default = '0x0'    : Whether MPAMIDR_EL1.HAS_TIDR bit is set or clear
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.6 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.mpidr_layout=1                               # (int   , init-time) default = '0x1'    : Layout of MPIDR. 0 AFF0 is CPUID, 1 AFF1 is CPUID
cluster1.mpmm_config=                                 # (string, init-time) default = ''       : MPMMTUNE register value. The JSON schema is : 
                                                      #                                        : {
                                                      #                                        : "DT_THR":0,
                                                      #                                        : "MPMM_G2_TP":2,
                                                      #                                        : "MPMM_G2_ATHR":100,
                                                      #                                        : "MPMM_G1_TP":2,
                                                      #                                        : "MPMM_G1_ATHR":75,
                                                      #                                        : "MPMM_G0_TP":2,
                                                      #                                        : "MPMM_G0_ATHR":50
                                                      #                                        : }
                                                      #                                        : . The value given for threshold value is just an indication, not specific to any core. This parameter is used only when has_mpmm is set.
cluster1.mte_report_which_failed_address=first        # (string, init-time) default = 'first'  : Set to "first" or "last". Applicable only for MTE synchronous check. If "first" then report first failed address. If "last" then report the first address of last failed MTE granule or first address of transfer if it doesn't cross a granule boundary.
cluster1.mte_tminline=0                               # (int   , init-time) default = '0x0'    : Value of CTR_EL0.TminLine for reading purpose only. A value configured using this does not indicate the presence of separate tag cache. 0, TminLine evaluated from smallest data cache line.
cluster1.mvbar_reset_is_rvbar=1                       # (bool  , init-time) default = '1'      : If true then the reset value of MVBAR is RVBAR, if false the reset value is UNKNOWN.
cluster1.non_secure_vgic_alias_when_ns_only=0         # (int   , init-time) default = '0x0'    : If ! has_el3 and only non-secure side exists, then the normal position of the VGIC is a secure alias.  If this parameter is non-zero then in addition a non-secure alias of the VGIC will be placed at this position (aligned to 32 KB).
cluster1.num_loregion_descriptors=0                   # (int   , init-time) default = '0x0'    : Number of Limited Ordering Region descriptors implemented (if ARM v8.1 extensions are implemented) (FEAT_LOR).
cluster1.num_loregions=0                              # (int   , init-time) default = '0x0'    : Number of Limited Ordering Regions implemented excluding background region (if ARM v8.1 extensions are implemented) (FEAT_LOR).
cluster1.number_of_error_records=0                    # (int   , init-time) default = '0x0'    : Cores Number of Error records supported for RAS
cluster1.optimal_alignment_size=1                     # (int   , init-time) default = '0x1'    : Alignment boundary which does not incur additional performance penalty from ARMv8.5.
                                                      #                                        :   - 1, architectural misalignment is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
                                                      #                                        :   - 2, access crossing 4 byte boundary is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
                                                      #                                        :   - 3, access crossing 8 byte boundary is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
                                                      #                                        : 	...
                                                      #                                        :   - 12, access crossing 4 Kbyte boundary is used to set PMU event LDST_ALIGN_LAT and SPE event E[11]
                                                      #                                        : 
cluster1.output_attributes=ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS  # (string, init-time) default = 'ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS' : User-defined transform to be applied to bus attributes like MasterID, ExtendedID or UserFlags. Currently, only works for MPAM Attributes encoding into bus attributes.
cluster1.page_based_hardware_attributes=0             # (int   , init-time) default = '0x0'    : Implement the page based hardware attributes from ARMv8.2.  This parameter indicates which page table bits are available for hardware, where bits[3:0] correspond to PTE[62:59] and to TCR_ELx.HWUnyy (FEAT_HPDS2).
cluster1.par_ns_set_unknown_bit=1                     # (bool  , init-time) default = '1'      : Whether NS bit of PAR is set/clear when executing AT to perform non-secure regime translation. When true, NS is set to 1 else 0.
cluster1.pfar_is_valid=1                              # (bool  , init-time) default = '1'      : IMPLEMENTATION DEFINED choice to configure ESR_ELx.PFV: whether PFAR_ELx is valid or UNKNOWN when ESR_ELx.PFV is not forced to be 0.
cluster1.pfr1_csv2_frac=0                             # (int   , init-time) default = '0x0'    : Fractional revision number ID_AA64PFR1_EL1.CSV2_frac when ID_AA64PFR0_EL1.CSV==1 for CSV2 extension (FEAT_CSV2_1p1, FEAT_CSV2_1p2)
cluster1.pmb_idr_external_abort=0                     # (int   , init-time) default = '0x0'    : Describes how the PE manages External aborts on writes made by the Statistical Profiling Extension to the Profiling Buffer. 0, External abort is reported to SPE, From Armv8.8 and Armv9.3, the value 0 is not permitted. 1, External abort is ignored. 2, The External abort generates an SError and the error is not reported to SPE.
cluster1.pmb_idr_flag_updates=1                       # (bool  , init-time) default = '1'      : Defines whether the address translation performed by the Profiling Buffer manages the Access Flag and dirty state
cluster1.pmcr_disable_events_export=1                 # (bool  , init-time) default = '1'      : If true, export for PMU events is disabled. This configures PMCFGR.EX field.
cluster1.pmmir_el1_bus_slots=0                        # (int   , init-time) default = '0x0'    : Largest value by which BUS_ACCESS can increment over BUS_CYCLES cycles. From v8.7 PMU extension
cluster1.pmmir_el1_bus_width=0                        # (int   , init-time) default = '0x0'    : Width, in bytes, of accesses counted by BUS_ACCESS. From v8.7 PMU extension
cluster1.pms_idr_max_size=6                           # (int   , init-time) default = '0x6'    : Defines largest size for a single SPE record (rounded up to a power of 2)
cluster1.pmu-num_counters=8                           # (int   , init-time) default = '0x8'    : Number of PMU counters implemented
cluster1.pmu_async_exception_delay=0                  # (int   , init-time) default = '0x0'    : Configure PMU asynchronous exception delay in CPU cycles (FEAT_SEBEP)
cluster1.pmu_cycle_counter_counts_actual_cycles=0     # (bool  , init-time) default = '0'      : If true and Timing annotation is enabled, PMU cycle counter counts actual cycles, otherwise counts instructions executed
cluster1.pmu_has_chain_event=1                        # (bool  , init-time) default = '1'      : PMU (if present) implements event number 0x1e, CHAIN.
cluster1.pmu_precise_events=                          # (string, init-time) default = ''       : "Configure v9.4 Precise PMU events. {"pmu_events":["SW_INCR","PC_WRITE_RETIRED","BR_RETIRED","BR_IND_RETIRED","BR_RETURN_RETIRED","BR_RETURN_ANY_RETIRED","BR_IND_TAKEN_RETIRED","LD_RETIRED","ST_RETIRED","UNALIGNED_LD_ST","INST_RETIRED","EXCEP_TAKEN","EXCEP_RETURN","CHAIN"]}"
cluster1.pmu_threshold_bit_width=0                    # (int   , init-time) default = '0x0'    : Implement FEAT_PMUv3_TH and if so the width of PMEVTYPER<n>_ELO.TH in bits. 0, not implemented. 1-12 number of bits in PMEVTYPER<n>_EL0.TH.
cluster1.poison_range_end_addr=0                      # (int   , init-time) default = '0x0'    : End PA of poisoned range.
cluster1.poison_range_start_addr=0                    # (int   , init-time) default = '0x0'    : Start PA of poisoned range.
cluster1.pseudo_fault_generation_feature_register=    # (string, init-time) default = ''       : ARMv8.4 Standard Pseudo-fault generation feature register values. JSON schema for the parameter value is: [{"OF":false,"UC":false,"UEU":false,"UER":false,"UEO":false,"DE":false,"CE":0x0,"CI":false,"ER":false,"PN":false,"AV":false,"MV":false,"SYN":false,"R":false,"NA":false},other_psuedo-fault_generating_features_register_values]. Where OF, UC, UEU, UER, UEO, DE, CI, ER, PN, AV, MV, SYN, and R have valid false(NOT_SUPPORTED) and true(FEATURE_CONTROLLABLE), where CE can have 0(NOT_SUPPORTED), 1(NONSPECIFIC_CE_SUPPORTED) and 3(TRANSIENT_OR_PERSISTENT_CE_SUPPORTED) and NA can have false(component fakes detection on next access) or true(component fakes detection spontaneously). Effective only when ERXFR's INJ field allows it or has_ras_fault_injection is true.
cluster1.pstate_ssbs_reset=0                          # (bool  , init-time) default = '0'      : Reset value of pstate.ssbs
cluster1.pstate_ssbs_type=0                           # (int   , init-time) default = '0x0'    : Implement speculative store bypass safe feature from ARMv8.5. 0, Not supported. 1, Supported without MSR/MRS access to SSBS (FEAT_SSBS). 2, fully supported (FEAT_SSBS2).
cluster1.ptw_latency=0                                # (int   , run-time ) default = '0x0'    : Page table walker latency for TA (Timing Annotation), expressed in simulation ticks
cluster1.randomize_unknowns_at_reset=0                # (bool  , init-time) default = '0'      : Will fill in unknown bits in registers at reset with random value using register_reset_data as seed, it overrides scramble_unknowns_at_reset
cluster1.ras_errselr_undef_if_no_error_records=0      # (bool  , init-time) default = '0'      : If true, ERRSELR_EL1 will be undefined if ERRIDR_EL1 indicates that zero error records are implemented.
cluster1.ras_extra_configurations=                    # (string, init-time) default = ''       : Miscellaneous configurations for error records. An array of JSON objects. Note for ERXCTRL_EL1 register it only allows to define the mask and reset value for the IMPDEF fields, ie bits [63:32] and bit 1. E.g. [{"Index": 0, "ERXMISC0_mask": 0x0, "ERXMISC0_reset": 0x0, "ERXMISC1_mask": 0x0, "ERXMISC1_reset": 0x0, "ERXCTRL_EL1_mask": 0x0, "ERXCTRL_EL1_reset": 0x0}, {"Index": 1, "ERXMISC0_mask": 0x0, "ERXMISC0_reset": 0x0, "ERXSTATUS_IERR_mask": 0x300}]
cluster1.ras_frac=0                                   # (int   , init-time) default = '0x0'    : 0, No additional feature implemented. 1, Additional ERXMISC*, ERXPFG* registers and FaultInjection trap from RAS v1.1. implemented
cluster1.ras_pfg_clock_mhz=24                         # (int   , init-time) default = '0x18'   : RAS Pseudo-Fault generation clock rate in MHz
cluster1.register_reset_data=0                        # (int   , init-time) default = '0x0'    : Data used to fill register bits when they become UNKNOWN at reset.
cluster1.register_reset_data_hi=0                     # (int   , init-time) default = '0x0'    : Data used to fill the upper-half of 128-bit registers when the bits become UNKNOWN at reset.
cluster1.report_iside_cmo_ifsr=1                      # (bool  , init-time) default = '1'      : fault info for an iside cache maintenance operation is reported in the IFSR
cluster1.reserved_HMC_SSC_PAC_treated_disabled=0      # (bool  , init-time) default = '0'      : When DBG[B|W]CR.{HMC,SSC,PAC} bits configuration is reserved, this parameter controls whether breakpoints/watchpoints are treated as Disabled or not
cluster1.restore_fpsr_on_trapped_fp_exception=0       # (bool  , init-time) default = '0'      : If true, FPSR is restored to the value of the FPSR immediately before the instruction that generated the trapped floating-point exception.
cluster1.restriction_on_speculative_execution=0       # (int   , init-time) default = '0x0'    : Implements the ARMv8.5 security feature (Restrictions on the effects of speculation), ID_AA64PFR0_EL1.CSV2: 0: No disclosure whether branch targets trained in one context can affect speculative execution in a different context, 1: Branch targets trained in one context cannot affect speculative execution in a different hardware described context (SCXTNUM_ELx not supported), 2: Branch targets trained in one context cannot affect speculative execution in a different hardware described context (SCXTNUM_ELx supported) (FEAT_CSV2, FEAT_CSV2_2)., 3: FEAT_CSV2_3 is supported
cluster1.restriction_on_speculative_execution_aarch32=0  # (int   , init-time) default = '0x0'    : Implements the ARMv8.5 security feature (Restrictions on the effects of speculation), ID_PFR0.CSV2: 0: No disclosure whether branch targets trained in one context can affect speculative execution in a different context, 1: Branch targets trained in one context cannot affect speculative execution in a different hardware described context, 2: Branch targets trained in one context cannot affect speculative execution in a different hardware described context or at a different address in the same hardware described context (FEAT_CSV2, FEAT_CSV2_2).
cluster1.revision_number=0                            # (int   , init-time) default = '0x0'    : Cosmetic change to Variant field in MIDR/MIDR_EL1. Corresponds to the revision number X in rXpY.
cluster1.rgsr_res0_stateful=0                         # (bool  , init-time) default = '0'      : Whether RGSR read of RES0 bits return last written value
cluster1.rme_default_mecid_nonsecure=0                # (int   , init-time) default = '0x0'    : Default MECID value for NON-SECURE PAS
cluster1.rme_default_mecid_realm=0                    # (int   , init-time) default = '0x0'    : Default MECID value for REALM PAS
cluster1.rme_default_mecid_root=0                     # (int   , init-time) default = '0x0'    : Default MECID value for ROOT PAS
cluster1.rme_default_mecid_secure=0                   # (int   , init-time) default = '0x0'    : Default MECID value for SECURE PAS
cluster1.rme_level0_gpt_size=0                        # (int   , init-time) default = '0x0'    : The range of address space protected by each entry in the level 0 GPT (0->1GB 1->16GB, 2->64GB, 3->512GB
cluster1.rme_mecid_width=1                            # (int   , init-time) default = '0x1'    : Width of MECID in bits
cluster1.rme_support_level=0                          # (int   , init-time) default = '0x0'    : 0 -> Realm management extension not implemented,  1 -> LEGACY_TZ_EN mode i.e. RME register fields are stateful but only supports secure/non-secure states, 2 -> Realm management extension fully implemented (FEAT_RME).
cluster1.rmr_always_implemented=0                     # (bool  , init-time) default = '0'      : Always implement RMR_ELx, RMR, or HRMR at the highest implemented exception level, even if that exception level cannot use both AArch32 and AArch64.
cluster1.rndr_rndrrs_seed=0                           # (int   , init-time) default = '0x0'    : Initial seed for random engine used in RNDR register
cluster1.scheduler_mode=0                             # (int   , init-time) default = '0x0'    : Control the interleaving of instructions in this processor.  0, default long quantum. 1, low latency mode, short quantum and signal checking. 2, lock-breaking mode, long quantum with additional context switches near load-exclusive instructions. WARNING: This parameter is intended for validation purposes and may result in unwanted behaviour if altered!
cluster1.scr_nET_writeable=0                          # (bool  , init-time) default = '0'      : Whether SCR.nET is writeable. Writing to it is purely cosmetic (nET behavior not implemented)
cluster1.scramble_unknowns_at_reset=1                 # (bool  , init-time) default = '1'      : Will fill in unknown bits in registers at reset with register_reset_data
cluster1.set_mops_option=0                            # (int   , init-time) default = '0x0'    : Set option for Armv8.8 SET(FEAT_MOPS). 0, use default(i.e. use value configured through has_mops_option). 1, implemented using Option A. 2, implemented using Option B
cluster1.set_rasv10_for_armv84_and_higher=0           # (bool  , init-time) default = '0'      : ARMv8.4 mandates RAS System Architecture v1.1, but when there are no error records and FEAT_DoubleFault is not implemented then there is no functional difference between the RAS System Architecture v1.0 (that is, the RAS extension as in pre-ARMv8.4 implementations) and the RAS System Architecture v1.1 (also known as FEAT_RASv1p1).  This flag if true will set the RAS ID to declare RAS v1.0 rather than RAS v1.1 for ARMv8.4 and higher implementations.  If this is set and the core does not conform to the restrictions then this parameter is ignored.
cluster1.setg_mops_option=0                           # (int   , init-time) default = '0x0'    : Set option for Armv8.8 SETG(FEAT_MOPS). 0, use default(i.e. use value configured through has_mops_option). 1, implemented using Option A. 2, implemented using Option B
cluster1.skip_trace_on_write_to_oseccr_el1_when_oslock_is_unlocked=0  # (bool  , init-time) default = '0'      : If OSLSR_EL1.OSLK == 0, then OSECCR_EL1 returns an unknown value on reads and ignores writes. When true, also skips the traces on writes to OSECCR_EL1 when OSLSR_EL1.OSLK == 0.
cluster1.spe_counter_size=1                           # (int   , init-time) default = '0x1'    : Size of counter packet payload in Statistical Profiling Extension
                                                      #                                        :    - 1, Counter packet payloads are 12-bit saturating counters
                                                      #                                        :    - 2, Counter packet payloads are 16-bit saturating counters
cluster1.spsr_el3_is_mapped_to_spsr_mon=1             # (bool  , init-time) default = '1'      : Whether SPSR_EL3 is mapped to AArch32 register SPSR_mon
cluster1.spsr_m4_res0=0                               # (bool  , init-time) default = '0'      : Whether SPSR_ELx.M[4] bit should be RES0 for AARCH64 only implementations
cluster1.stage12_tlb_size=128                         # (int   , init-time) default = '0x80'   : Number of stage1+2 tlb entries.
cluster1.stage1_tlb_size=0                            # (int   , init-time) default = '0x0'    : Number of stage1 only tlb entries.
cluster1.stage1_walkcache_size=0                      # (int   , init-time) default = '0x0'    : Number of stage1 only walk cache entries.
cluster1.stage2_tlb_size=0                            # (int   , init-time) default = '0x0'    : Number of stage2 only tlb entries.
cluster1.stage2_walkcache_size=0                      # (int   , init-time) default = '0x0'    : Number of stage2 only walk cache entries.
cluster1.statistical_profiling_buffer_alignment=1     # (int   , init-time) default = '0x1'    : Statistical profiling alignment constraint for sample buffer
cluster1.statistical_profiling_random_interval_is_separate=0  # (bool  , init-time) default = '0'      : Statistical profiling random interval gets added to the main timer interval(false) or (true) runs as separate timer
cluster1.statistical_profiling_recommended_min_sampling=256  # (int   , init-time) default = '0x100'  : Statistical profiling recommended minimum sampling interval
cluster1.strex_fail_can_hit_watchpoint=0              # (bool  , init-time) default = '0'      : If true, a strex fail can hit watchpoint
cluster1.supports_multi_threading=1                   # (bool  , init-time) default = '1'      : Sets the MPIDR.MT bit. Setting this to true hints the the cluster is multi-threading compatible
cluster1.swp_with_xzr_is_st_atomic=1                  # (bool  , init-time) default = '1'      : If true, swp with dest as xzr is treated as store atomic
cluster1.sync_ext_abort_is_sync_serror=0              # (bool  , init-time) default = '0'      : Treat synchronous external aborts as synchronous SErrors (RASv8.9).  0, synchronous external abort.  1, synchronous serror.
cluster1.system_pmu_id=0                              # (int   , init-time) default = '0x0'    : When FEAT_SPMU is implemented, indicates the largest value s to select a System PMU <s>
cluster1.take_ccfail_tsc_trap=0                       # (bool  , init-time) default = '0'      : When take_ccfail_undef=1 this parameter controls whether or not an SMC instruction that is trapped by HCR_EL2.TSC but fails its condition code check generates a trap to EL2.
cluster1.take_ccfail_undef=1                          # (bool  , init-time) default = '1'      : UNDEF exception is taken even if condition code check fails
cluster1.tcr_ps_reserved_value_size=0                 # (int   , init-time) default = '0x0'    : Physical size treated when TCR.(I)PS is programmed with a reserved value. 0, 48 bits. 1, 52 bits. The parameter value is treated 0 if LPA is not supported.
cluster1.tcr_txsz_undersize_should_fault=1            # (bool  , init-time) default = '1'      : If large VA is not supported, Whether undersized TxSZ value should generate translation fault
cluster1.tdosa_traps_osdlr_if_no_os_double_lock=1     # (bool  , init-time) default = '1'      : MDCR_EL*.TDOSA enables trap on OSDLR_EL1 and DBGOSDLR when OS double-lock is not implemented.
cluster1.tidcp_traps_el0_undef_imp_def=1              # (bool  , init-time) default = '1'      : TIDCP has priority over UNDEF for accesses to IMPLEMENTATION DEFINED functionality from EL0
cluster1.tlb_latency=0                                # (int   , run-time ) default = '0x0'    : TLB latency for TA (Timing Annotation), expressed in simulation ticks
cluster1.tlbi_invalid_xt_behave_as_undef=0            # (bool  , init-time) default = '0'      : If true, TLBI instructions that don't take Xt as an argument behave as UNDEFINED if Xt != 0b11111
cluster1.tme_disable-read-write-set-optimizations=0   # (bool  , init-time) default = '0'      : If true, disables the read/write set related optimizations of the model.
cluster1.tme_imp-failures-can-retry=0                 # (bool  , init-time) default = '0'      : If true, IMP=1 failures introduced by the parameters:
                                                      #                                        : 	tme_wfe-fails-transactions
                                                      #                                        : 	tme_tcommit-fails-transactions
                                                      #                                        : 	tme_wakeup-from-wfe-always-fails-transactions
                                                      #                                        : will also report RTRY=1.
cluster1.tme_implementation-type=0                    # (int   , init-time) default = '0x0'    : Implementation type for TME.
                                                      #                                        : 
                                                      #                                        : The following options are available:
                                                      #                                        : 	0x0: Always fail starting transactions with the IMP cause.
                                                      #                                        : 	0x1: Fail on forbidden operations (e.g. some system register accesses) and at model's convenience.
                                                      #                                        : 	0x2: As 0x1 but also enable inter PE memory conflict checking.
                                                      #                                        : 
cluster1.tme_random-memory-access-fail-chance=0       # (int   , init-time) default = '0x0'    : If >0, add a pseudorandom chance for every memory access (loads, stores, TCOMMIT) inside a transaction to cause the transaction to fail with IMP.
cluster1.tme_read-set-size=0                          # (int   , init-time) default = '0x0'    : Size of the transactional read set in bytes, rounded up to the nearest integer number of transaction granules. 0 == unlimited
cluster1.tme_support-only-guaranteed-mem-attr=0       # (bool  , init-time) default = '0'      : If true, a transactional access to memory with a type not architecturally guaranteed to be supported will cause a transaction failure with IMP=1
cluster1.tme_tcommit-fails-transactions=0             # (bool  , init-time) default = '0'      : If true, executing TCOMMIT inside a transaction will cause it to fail with IMP=1
cluster1.tme_wakeup-from-wfe-always-fails-transactions=0  # (bool  , init-time) default = '0'      : If true, waking up from a WFE will always fail the transaction, even if not required
cluster1.tme_wfe-fails-transactions=0                 # (bool  , init-time) default = '0'      : If true, executing WFE inside a transaction will cause it to fail with IMP=1
cluster1.tme_write-set-size=0                         # (int   , init-time) default = '0x0'    : Size of the transactional write set in bytes, rounded up to the nearest integer number of transaction granules. 0 == unlimited
cluster1.trace_full_simd_reg_with_nep=0               # (bool  , init-time) default = '0'      : Whether full simd register is traced even if partial update is done when FPCR.NEP=1
cluster1.trace_has_sysreg_access=1                    # (bool  , init-time) default = '1'      : ETM trace registers support access via system registers
cluster1.trace_icc_registers_as_icv_when_redirected=0  # (bool  , init-time) default = '0'      : If true, update trace with ICV, instead of ICC when ICV registers are accessed depending on the core state.
cluster1.trace_physical_registers_when_host_virtualisation_enabled=0  # (int   , init-time) default = '0x0'    : When host virtualisation is enabled, trace sysreg accesses to physical register accessed (0=disabled, 1=Trace only ELR/SPSR_EL1 as ELR/SPSR_EL2, 2=Trace all redirected registers as physical registers
cluster1.trap_dc_cmo_to_pou_if_nop=1                  # (bool  , init-time) default = '1'      : Whether traps to DC CMO operations to PoU are ignored if the same is treated as NOP.
cluster1.trap_ic_cmo_to_pou_if_nop=1                  # (bool  , init-time) default = '1'      : Whether traps to IC CMO operations to PoU are ignored if the same is treated as NOP.
cluster1.trap_reserved_group3_id_regs=0               # (bool  , init-time) default = '0'      : Whether setting HCR_EL2.TID3 traps reserved group3 id registers.
cluster1.trbe_cmod=0                                  # (int   , init-time) default = '0x0'    : TRBE Customer Modified.
cluster1.trbe_des=0                                   # (int   , init-time) default = '0x0'    : Designer, JEP106 identification code.
cluster1.trbe_external_abort_handling=0               # (int   , init-time) default = '0x0'    : Describes how the PE manages External aborts on writes made by the Trace Buffer Unit to the trace buffer. (0->External abort is reported to TRBE. From Armv9.3, the value 0 is not permitted and will be 1 if Armv9.3 is implemented. 1-> External abort is ignored. 2->The External abort generates an SError and the error is not reported to TRBE.)
cluster1.trbe_has_hardware_translation_table_update=1  # (bool  , init-time) default = '1'      : If true, address translation performed by the Trace Buffer Extension manages the Access Flag and dirty state
cluster1.trbe_implemented_version=1                   # (int   , init-time) default = '0x1'    : Trace Buffer Extension implemented version, 1: FEAT_TRBE implemented (Armv9.0).
cluster1.trbe_mpam=0                                  # (int   , init-time) default = '0x0'    : TRBE MPAM support.
cluster1.trbe_part=0                                  # (int   , init-time) default = '0x0'    : Part number.
cluster1.trbe_partid_max=0                            # (int   , init-time) default = '0x0'    : Largest permitted TRBDEVID1.PARTID value.
cluster1.trbe_pmg_max=0                               # (int   , init-time) default = '0x0'    : Largest permitted TRBDEVID1.PMG value.
cluster1.trbe_revand=0                                # (int   , init-time) default = '0x0'    : TRBE component minor revision.
cluster1.trbe_revision=0                              # (int   , init-time) default = '0x0'    : TRBE architecture revision.
cluster1.treat-dcache-cmos-to-poc-as-nop=0            # (int   , init-time) default = '0x0'    : Whether dcache maintenance operations to the point of coherency are required for instruction to data coherence. 0 - Clean/Invalidate ops required, 1 - Clean/Invalidate ops not required and cannot generate faults, 2 - Clean/Invalidate ops not required but can generate faults
cluster1.treat-dcache-cmos-to-pou-as-nop=0            # (int   , init-time) default = '0x0'    : Whether dcache invalidation to the point of unification is required for instruction to data coherence. 0 - Invalidate ops required, 1 - Invalidate ops not required and cannot generate faults, 2 - Invalidate ops not required but can generate faults
cluster1.treat-dcache-invalidate-as-clean-invalidate=0  # (bool  , init-time) default = '0'      : Treat data cache invalidate operations as clean and invalidate.
cluster1.treat-icache-cmos-to-pou-as-nop=0            # (int   , init-time) default = '0x0'    : If has_coherent_icache is true, whether instruction cache invalidation operations to PoU which are treated as NOP can generate fault. 0 - cannot generate faults, 1 - can generate faults
cluster1.treat_PAC_as_NOP=0                           # (bool  , init-time) default = '0'      : Non-architecture parameter. Treat Pointer Authentication as NOP. When the parameter is true behavour of FEAT_PAuth instructions changes as following PAC* and AUT* and XPAC* instructions are NOP. Brach, load, return with authentication instructions do not check and change signature bits and ignore FEAT_PAuth traps.
cluster1.treat_forced_normal_as_device_for_excl_atomics=0  # (bool  , init-time) default = '0'      : Whether exclusive/atomic access is supported in same manner as access to device if stage1 is Device memory and final memory attribute forced to normal by FWB
cluster1.treat_pld_as_nop=0                           # (bool  , init-time) default = '0'      : If true, treat PLD as NOP.
cluster1.treat_pli_as_nop=0                           # (bool  , init-time) default = '0'      : If true, treat PLI as NOP.
cluster1.treat_wfi_wfe_as_nop=0                       # (bool  , init-time) default = '0'      : If true, never go into wait state for WFI or WFE instructions.
cluster1.truncate_pc_on_illegal_exception_return_to_aarch32=1  # (bool  , init-time) default = '1'      : On Illegal ERET to AArch32, truncate PC to 32-bits
cluster1.undef_ccsidr2_access_for_unimplemented_aarch32=0  # (bool  , init-time) default = '0'      : Whether access to CCSIDR2 is undef if AArch32 is implemented or not at EL1
cluster1.unification-level=1                          # (int   , init-time) default = '0x1'    : Level of Unification Inner Shareable for the cache hierarchy
cluster1.unification-uniprocessor-level=1             # (int   , init-time) default = '0x1'    : Level of Unification Uniprocessor for the cache hierarchy
cluster1.unpred_brb_iall_invalid_xt_behave_as_undef=0  # (bool  , init-time) default = '0'      : If true, BRB IALL instruction will behave as UNDEFINED if Xt != 0b11111
cluster1.unpred_edscr_ns_set_unknown_bit=0            # (bool  , init-time) default = '0'      : Unknown(x) bit in NS field in EDSCR can be configure to 0 or 1.
cluster1.unpred_edscr_rw_unknown_bits_read_as_1=0     # (bool  , init-time) default = '0'      : Unknown(x) bits in RW field in EDSCR are read as 1 instead of 0.
cluster1.unpred_extdbg_unknown_bits=0                 # (int   , init-time) default = '0x0'    : Data used to fill only in UNKNOWN bit-fields of external debug registers e.g., EDPFR and EDDFR.
cluster1.unpred_load_single_reg_overlap_with_wb=0     # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviours for single load with writeback(might impact certain load pair instructions) 0 Constraint_WBSUPPRESS, 1 Constraint_UNDEF, 2 Constraint_NOP
cluster1.unpred_mrsmsr_currentlymapped_undef=0        # (bool  , init-time) default = '0'      : UNPREDICTABLE register access (accessible from current mode using different instruction) modeled as NOP when false and UNDEF when true
cluster1.unpred_mrsmsr_protfailed_undef=0             # (bool  , init-time) default = '0'      : UNPREDICTABLE register access (not accessible from current PL and security state) modeled as NOP when false and UNDEF when true
cluster1.unpred_mte_tag_read_when_ata_controls_are_zero_or_untagged_attr=0  # (bool  , init-time) default = '0'      : Constrained unpredictable for MTE tag read when ATA controls are 0 or untagged attribute. false, Read as zero. true, Permitted to generate an external abort if a read of data from the same address would generate an external abort.
cluster1.unpred_mte_tag_store_to_device_mem_as_alignment_fault=0  # (bool  , init-time) default = '0'      : Constrained unpredictable choice for MTE instructions which store tags to memory locations marked as Device. false, Storing the data, if any, to the locations. true, Generating an Alignment Fault.
cluster1.unpred_nested_virtualization_nv_behaviour=0  # (int   , init-time) default = '0x0'    : Constrained unpredictable choices for HCR_EL2.NV=0 and HCR_EL2.NV1=1 with respect to nested virtualization
                                                      #                                        :    - 0, Behave as defined in the specification as per bit values
                                                      #                                        :    - 1, Behave as if HCR_EL2.NV=1 and HCR_EL2.NV1=1 for all purpose other than reading back HCR_EL2.NV
                                                      #                                        :    - 2, Behave as if HCR_EL2.NV=0 and HCR_EL2.NV1=0 for all purpose other than reading back HCR_EL2.NV1
                                                      #                                        : 
cluster1.unpred_par_attr_returns_mair=0               # (bool  , init-time) default = '0'      : If true, PAR_EL1.ATTR represents the memory attributes as per the MAIR value instead of the ones in the descriptor.
cluster1.unpred_store_exclusive_base_overlap=0        # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviours for store exclusive when s==n. 0 Constraint_NONE, 1 Constraint_UNDEF, 2 Constraint_NOP
cluster1.unpred_store_pair_and_single_reg_overlap_with_wb=0  # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviours for pair and single store with writeback(doesn't cover store exclusive) 0 Constraint_NONE, 1 Constraint_UNDEF, 2 Constraint_NOP
cluster1.unpred_tlbi_not_in_monitor_mode=0            # (int   , init-time) default = '0x0'    : Constrained unpredictable behaviors for AArch32 TLBI instructions executed in secure privileged mode other than Monitor mode. 0: Preferred behavior (default), 1: UNDEF, 2: NOP, 3: execute as if had been executed in Monitor mode
cluster1.unpred_tsize_aborts=0                        # (bool  , init-time) default = '0'      : Behaviour when TSize is out of range. 0, force into range. 1, translation fault, forces unpred_tsize_pamax_aborts to 1.
cluster1.unpred_tsize_pamax_aborts=0                  # (bool  , init-time) default = '0'      : Behaviour when stage 2 TSize exceeds the physical address size (or 40bits, from AArch32). 0, force into range. 1, translation fault.  Ignored if unpred_tsize_aborts is 1.
cluster1.unpred_vncr_el2_ress_mismatch=0              # (int   , init-time) default = '0x0'    : Constrained unpredictable choices when bits marked as RESS do not all have the same value for VNCR_EL2  - 0, Generating an EL2 translation regime translation abort on use of the VNCR_EL2 register
                                                      #                                        :   - 1, Reserved sign extended bits of VNCR_EL2 are same as bit[52] or bit[48] based on if large VA is supported or not, for all purposes other than reading back the register
                                                      #                                        : 
cluster1.unpred_zero_spsr_btype=1                     # (bool  , init-time) default = '1'      : Constrained unpredictable control to make SPSR_ELx.BTYPE 0 instead of PSTATE.BTYPE on synchronous exceptions other than Software Step, PC alignment fault, Instruction Abort, Breakpoint or Address Matching Vector Catch, Illegal Execution State, BRK instruction, Branch Target
cluster1.unpredictable_exclusive_abort_memtype=0      # (int   , init-time) default = '0x0'    : Cause MMU abort if exclusive access is not supported in certain memory type (0=exclusives allowed in all memory types, 1=exclusives abort in Device memory types, 2=exclusives abort in any type other than WB inner cacheable)
cluster1.unpredictable_hvc_behaviour=0                # (int   , init-time) default = '0x0'    : HVC unpredictable behaviour. 0, UNDEF. 1, NOP.
cluster1.unpredictable_smc_behaviour=0                # (int   , init-time) default = '0x0'    : SMC unpredictable behaviour. 0, UNDEF. 1, NOP.
cluster1.unpredictable_wfet_and_wfit_behaviour=1      # (int   , init-time) default = '0x1'    : WFET and WFIT unpredictable behaviour in debug state. 0, UNDEFINED. 1, NOP.
cluster1.unsupported_atomic_fault_type=0              # (int   , init-time) default = '0x0'    : Type of fault reported on unsupported atomic access. 0 = external abort if any reported by interconnect, 1 = precise unsupported atomic fault, 2 = precise external abort, 3 = imprecise external abort.
cluster1.use_Xt_as_LDG_STG_input=1                    # (bool  , init-time) default = '1'      : Use new MTE Instructions formats for LDG/ST(Z)(2)G, which use Xt as an input
cluster1.use_mte_eac_02_instructions_encoding=1       # (bool  , init-time) default = '1'      : Use new MTE Instructions encoding since MTE spec EAC 0.2 in ARMv8.5.
cluster1.use_mte_eac_08_tfsr_encoding=1               # (bool  , init-time) default = '1'      : Use new MTE TFSR_ELx encodings since MTE spec EAC 0.8 in ARMv8.5.
cluster1.use_rosetta_disass=1                         # (int   , init-time) default = '0x1'    : Use Rosetta disassembly library.
                                                      #                                        : 
                                                      #                                        : Possible values of this parameter are:
                                                      #                                        :   - 0, feature is not enabled.
                                                      #                                        :   - 1, feature is implemented if ARMv8.4 is enabled.
                                                      #                                        :   - 2, feature is implemented.
cluster1.use_sif_to_compute_pan=0                     # (bool  , init-time) default = '0'      : Where FEAT_PAN3 is implemented, whether SCR_EL3.SIF bit is used to determine instruction access permission for the purpose of PAN
cluster1.use_tlb_contig_hint=0                        # (bool  , init-time) default = '0'      : Translation table entries with the contiguous hint bit set generate large TLB entries.
cluster1.user_defined_rom_table_debug_power_config=   # (string, init-time) default = ''       : User defined ROM Table debug power domains for ED,CTI,PMU and TRACE, and DBGPCR configuration. The "version" field and "cores" array are mandatory. The "dbgpcr" array, if provided, must contain unique integers in the range [0, 32) describing which debug power domains have power control implemented. The "rom" and "dbgpcr" fields in objects in the "cores" array are only allowed when 'debug_rom_is_flat' is false. All power domain ID fields ("rom", "ed/pmu", "cti", "etm") must be in the range [0, 32). The "ed/pmu" field is mandatory. Example JSON for a hierarchical debug ROM layout: '{"version": 0, "dbgpcr": [0, 1], "cores":[{"dbgpcr": [1, 31], "rom": 0, "ed/pmu": 0, "cti": 31, "etm": 1}, {"ed/pmu": 0}]}'
cluster1.vpu_datapath_width=128                       # (int   , init-time) default = '0x80'   : VPU data path width
cluster1.walk_cache_latency=0                         # (int   , run-time ) default = '0x0'    : Walk cache latency for TA (Timing Annotation), expressed in simulation ticks
cluster1.warn_unpredictable_in_v7=1                   # (bool  , init-time) default = '1'      : If true, behaviour which is unpredictable in V7 yet is predictable in V8 will produce a warning
cluster1.watchpoint-log2secondary_restriction=0       # (int   , init-time) default = '0x0'    : log2 size of secondary restriction of FAR/EDWAR possible values on watchpoint hit for load/store operations.
cluster1.wfe_wakeup_delay=0                           # (int   , init-time) default = '0x0'    : Configure WFE wakeup delay in CPU cycles
cluster1.wfi_wakeup_delay=0                           # (int   , init-time) default = '0x0'    : Configure WFI wakeup delay in CPU cycles
cluster1.wnr_is_read_for_s2f_on_s1_atomic_instr_fault=0  # (bool  , init-time) default = '0'      : Whether WnR is 0 for stage2 fault on stage1 for atomic instructions
cluster1.wnr_is_read_for_s2f_on_s1_dbm_update=0       # (bool  , init-time) default = '0'      : Whether WnR is 0 for stage2 fault on stage1 descriptor dbm update
cluster1.wp_ignores_dbm_update=0                      # (bool  , init-time) default = '0'      : If true, dbm update is ignored on watchpoint hit
cluster1.wp_num_reporting=0                           # (int   , init-time) default = '0x0'    : When reporting of the watchpoint number on Watchpoint Exceptions and Debug Events is performed
                                                      #                                        :    0 - When FEAT_Debugv8p9 is implemented or otherwise required
                                                      #                                        :    1 - When FEAT_Debugv8p9 or FEAT_SME is implemented
cs_rom.entry_32=0                                     # (int   , init-time) default = '0x0'    : Offset of component 32
cs_rom.entry_33=0                                     # (int   , init-time) default = '0x0'    : Offset of component 33
cs_rom.entry_34=0                                     # (int   , init-time) default = '0x0'    : Offset of component 34
cs_rom.entry_35=0                                     # (int   , init-time) default = '0x0'    : Offset of component 35
cs_rom.entry_36=0                                     # (int   , init-time) default = '0x0'    : Offset of component 36
cs_rom.entry_37=0                                     # (int   , init-time) default = '0x0'    : Offset of component 37
cs_rom.entry_38=0                                     # (int   , init-time) default = '0x0'    : Offset of component 38
cs_rom.entry_39=0                                     # (int   , init-time) default = '0x0'    : Offset of component 39
cs_rom.entry_40=0                                     # (int   , init-time) default = '0x0'    : Offset of component 40
cs_rom.entry_41=0                                     # (int   , init-time) default = '0x0'    : Offset of component 41
cs_rom.entry_42=0                                     # (int   , init-time) default = '0x0'    : Offset of component 42
cs_rom.entry_43=0                                     # (int   , init-time) default = '0x0'    : Offset of component 43
cs_rom.entry_44=0                                     # (int   , init-time) default = '0x0'    : Offset of component 44
cs_rom.entry_45=0                                     # (int   , init-time) default = '0x0'    : Offset of component 45
cs_rom.entry_46=0                                     # (int   , init-time) default = '0x0'    : Offset of component 46
cs_rom.entry_47=0                                     # (int   , init-time) default = '0x0'    : Offset of component 47
cs_rom.entry_48=0                                     # (int   , init-time) default = '0x0'    : Offset of component 48
cs_rom.entry_49=0                                     # (int   , init-time) default = '0x0'    : Offset of component 49
cs_rom.entry_50=0                                     # (int   , init-time) default = '0x0'    : Offset of component 50
cs_rom.entry_51=0                                     # (int   , init-time) default = '0x0'    : Offset of component 51
cs_rom.entry_52=0                                     # (int   , init-time) default = '0x0'    : Offset of component 52
cs_rom.entry_53=0                                     # (int   , init-time) default = '0x0'    : Offset of component 53
cs_rom.entry_54=0                                     # (int   , init-time) default = '0x0'    : Offset of component 54
cs_rom.entry_55=0                                     # (int   , init-time) default = '0x0'    : Offset of component 55
cs_rom.entry_56=0                                     # (int   , init-time) default = '0x0'    : Offset of component 56
cs_rom.entry_57=0                                     # (int   , init-time) default = '0x0'    : Offset of component 57
cs_rom.entry_58=0                                     # (int   , init-time) default = '0x0'    : Offset of component 58
cs_rom.entry_59=0                                     # (int   , init-time) default = '0x0'    : Offset of component 59
cs_rom.entry_60=0                                     # (int   , init-time) default = '0x0'    : Offset of component 60
cs_rom.entry_61=0                                     # (int   , init-time) default = '0x0'    : Offset of component 61
cs_rom.entry_62=0                                     # (int   , init-time) default = '0x0'    : Offset of component 62
cs_rom.entry_63=0                                     # (int   , init-time) default = '0x0'    : Offset of component 63
dap.ap0_set_paddrdbg31=0                              # (bool  , init-time) default = '0'      : Set paddrdbg31 signal during accesses on AP0
dap.ap1_has_debug_rom=0                               # (bool  , init-time) default = '0'      : Whether AP1 has a Debug ROM
dap.ap1_rom_base_address=0                            # (int   , init-time) default = '0x0'    : ROM base address for AP 1
dap.ap1_set_paddrdbg31=0                              # (bool  , init-time) default = '0'      : Set paddrdbg31 signal during accesses on AP1
dapmemlogger.trace_debug=0                            # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
dapmemlogger.trace_snoops=0                           # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
dbgen=1                                               # (bool  , init-time) default = '1'      : Debug authentication signal dbgen
elfloader.elf=                                        # (string, init-time) default = ''       : ELF file
elfloader.impdef_copy=0                               # (bool  , init-time) default = '0'      : DEPRECATED: Use realm_copy or root_copy parameters. load ELF file to implementation defined memory spaces, if load file is not specified.
elfloader.lfile=                                      # (string, init-time) default = ''       : load file for large address mapping
elfloader.ns_copy=1                                   # (bool  , init-time) default = '1'      : copy whole file to NS memory space
elfloader.output_attributes_parameter_of_core=ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_SP[0], ExtendedID[37]=MPAM_SP[1], UserFlags[31:16]=IMPDEF2  # (string, init-time) default = 'ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_SP[0], ExtendedID[37]=MPAM_SP[1], UserFlags[31:16]=IMPDEF2' : Encoding of various attributes on the bus.
elfloader.realm_copy=0                                # (bool  , init-time) default = '0'      : load ELF file to REALM memory spaces, if load file is not specified
elfloader.root_copy=0                                 # (bool  , init-time) default = '0'      : load ELF file to ROOT memory spaces, if load file is not specified
gic_distributor.A3-affinity-supported=0               # (bool  , init-time) default = '0'      : Device supports affinity level 3 values that are non-zero.
gic_distributor.ARE-fixed-to-one=0                    # (bool  , init-time) default = '0'      : GICv2 compatibility is not supported and GICD_CTLR.ARE_* is always one
gic_distributor.CPU-affinities=0.0.0.0, 0.0.1.0, 0.0.2.0, 0.0.3.0, 0.1.0.0, 0.1.1.0, 0.1.2.0, 0.1.3.0  # (string, init-time) default = '0.0.0.0, 0.0.1.0, 0.0.2.0, 0.0.3.0, 0.1.0.0, 0.1.1.0, 0.1.2.0, 0.1.3.0' : A comma separated list of dotted quads containing the affinities of all PEs connected to this IRI. If CPU-affinities-file is specified, this parameter is ignored.
gic_distributor.CPU-affinities-file=                  # (string, init-time) default = ''       : A file containing comma separated list of dotted quads containing the affinities of all PEs connected to this IRI. If this parameter is specified, CPU-affinities parameter will be ignored even when it is given.
gic_distributor.DPG-ARE-only=0                        # (bool  , init-time) default = '0'      : Limit application of DPG bits to interrupt groups for which ARE=1
gic_distributor.DPG-bits-implemented=0                # (bool  , init-time) default = '0'      : Enable implementation of interrupt group participation bits or DPG bits in GICR_CTLR
gic_distributor.DS-fixed-to-zero=0                    # (bool  , init-time) default = '0'      : Enable/disable support of single security state
gic_distributor.GICD-alias=0                          # (int   , init-time) default = '0x0'    : In GICv2 mode: the base address for a 4k page alias of the first 4k of the Distributor page, in GICv3/GICv4 mode. the base address of a 64KB page containing message based SPI signalling register aliases(0:Disabled)
gic_distributor.GICD-legacy-registers-as-reserved=0   # (bool  , init-time) default = '0'      : When ARE is RAO/WI, makes superfluous registers in GICD reserved ( including for the purpose of STATUSR updates)
gic_distributor.GICD_CTLR-DS-1-means-secure-only=0    # (bool  , init-time) default = '0'      : If GICD_CTLR.DS=1, GICD supports a single security state which is secure if this is true, otherwise is non-secure.
gic_distributor.GICD_ITARGETSR-RAZWI=0                # (bool  , init-time) default = '0'      : If true, the GICD_ITARGETS registers are RAZ/WI
gic_distributor.GICD_PIDR=0                           # (int   , init-time) default = '0x0'    : The value for the GICD_PIDR registers, if non-zero. Note: fixed fields (device type etc.) will be overriden in this value.
gic_distributor.GICD_TYPER2=0                         # (int   , init-time) default = '0x0'    : GICD_TYPER2 value containing VID and VIL to define the width of vPEID for GICv4.1.
gic_distributor.GICR-clear-enable-supported=0         # (bool  , init-time) default = '0'      : When true, this sets the value of the RO bit GICR_CTLR.CES with the value of the parameter allow-LPIEN-clear, making it visible to software
gic_distributor.GICR-invalidate-registers-implemented=0  # (bool  , init-time) default = '0'      : When true, the registers GICR_INVLPIR, GICR_INVALLR and GICR_SYNCR are implemented
gic_distributor.GICR_PIDR=0                           # (int   , init-time) default = '0x0'    : The value for the GICR_PIDR registers, if non-zero. Note: fixed fields (device type etc.) will be overriden in this value.
gic_distributor.GICR_PROPBASER-read-only=0            # (bool  , init-time) default = '0'      : GICR_PROPBASER register is read-only.
gic_distributor.GICR_PROPBASER-reset-value=0          # (int   , init-time) default = '0x0'    : Value of GICR_PROPBASER on reset.
gic_distributor.GITS_BASER0-entry-bytes=8             # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER0 register.
gic_distributor.GITS_BASER0-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER0 register is RAZ/WI.
gic_distributor.GITS_BASER0-type=1                    # (int   , init-time) default = '0x1'    : Type field for GITS_BASER0 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections
gic_distributor.GITS_BASER1-entry-bytes=8             # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER1 register.
gic_distributor.GITS_BASER1-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER1 register is RAZ/WI.
gic_distributor.GITS_BASER1-type=0                    # (int   , init-time) default = '0x0'    : Type field for GITS_BASER1 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections
gic_distributor.GITS_BASER2-entry-bytes=8             # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER2 register.
gic_distributor.GITS_BASER2-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER2 register is RAZ/WI.
gic_distributor.GITS_BASER2-type=2                    # (int   , init-time) default = '0x2'    : Type field for GITS_BASER2 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections
gic_distributor.GITS_BASER3-entry-bytes=8             # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER3 register.
gic_distributor.GITS_BASER3-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER3 register is RAZ/WI.
gic_distributor.GITS_BASER3-type=0                    # (int   , init-time) default = '0x0'    : Type field for GITS_BASER3 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections
gic_distributor.GITS_BASER4-entry-bytes=8             # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER4 register.
gic_distributor.GITS_BASER4-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER4 register is RAZ/WI.
gic_distributor.GITS_BASER4-type=0                    # (int   , init-time) default = '0x0'    : Type field for GITS_BASER4 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections
gic_distributor.GITS_BASER5-entry-bytes=8             # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER5 register.
gic_distributor.GITS_BASER5-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER5 register is RAZ/WI.
gic_distributor.GITS_BASER5-type=0                    # (int   , init-time) default = '0x0'    : Type field for GITS_BASER5 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections
gic_distributor.GITS_BASER6-entry-bytes=8             # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER6 register.
gic_distributor.GITS_BASER6-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER6 register is RAZ/WI.
gic_distributor.GITS_BASER6-type=4                    # (int   , init-time) default = '0x4'    : Type field for GITS_BASER6 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections
gic_distributor.GITS_BASER7-entry-bytes=8             # (int   , init-time) default = '0x8'    : Number of bytes required per entry for GITS_BASER7 register.
gic_distributor.GITS_BASER7-indirect-RAZ=0            # (bool  , init-time) default = '0'      : Indirect field for GITS_BASER7 register is RAZ/WI.
gic_distributor.GITS_BASER7-type=0                    # (int   , init-time) default = '0x0'    : Type field for GITS_BASER7 register. 0 = Unimplemented; 1 = Devices; 2 = Virtual Processors; 3 = Physical Processors; 4 = Collections
gic_distributor.GITS_PIDR=0                           # (int   , init-time) default = '0x0'    : The value for the GITS_PIDR registers, if non-zero. Note: fixed fields (device type etc.) will be overriden in this value.
gic_distributor.ICFGR-PPI-mask=2863311530             # (int   , init-time) default = '0xaaaaaaaa' : Mask for writes to ICFGR registers that configure PPIs
gic_distributor.ICFGR-PPI-reset=0                     # (int   , init-time) default = '0x0'    : Reset value for ICFGR regesters that configure PPIs
gic_distributor.ICFGR-SGI-mask=0                      # (int   , init-time) default = '0x0'    : Mask for writes to ICFGR registers that configure SGIs
gic_distributor.ICFGR-SGI-reset=2863311530            # (int   , init-time) default = '0xaaaaaaaa' : Reset value for ICFGR registers that configure SGIs
gic_distributor.ICFGR-SPI-mask=2863311530             # (int   , init-time) default = '0xaaaaaaaa' : Mask for writes to ICFGR registers that configure SPIs
gic_distributor.ICFGR-SPI-reset=0                     # (int   , init-time) default = '0x0'    : Reset value for ICFGR regesters that configure SPIs
gic_distributor.ICFGR-rsvd-bit=0                      # (bool  , init-time) default = '0'      : If ARE=0, the value of reserved bits i.e. bit 0,2,4..30 of ICFGRn for n>0
gic_distributor.IGROUP-PPI-mask=65535                 # (int   , init-time) default = '0xffff' : Mask for writes to PPI bits in IGROUP registers
gic_distributor.IGROUP-PPI-reset=0                    # (int   , init-time) default = '0x0'    : Reset value for SGI bits in IGROUP registers
gic_distributor.IGROUP-SGI-mask=65535                 # (int   , init-time) default = '0xffff' : Mask for writes to SGI bits in IGROUP registers
gic_distributor.IGROUP-SGI-reset=0                    # (int   , init-time) default = '0x0'    : Reset value for SGI bits in IGROUP registers
gic_distributor.IIDR=0                                # (int   , init-time) default = '0x0'    : GICD_IIDR and GICR_IIDR value
gic_distributor.IRI-ID-bits=16                        # (int   , init-time) default = '0x10'   : Number of bits used to represent interrupts IDs in the Distributor and Redistributors, forced to 10 when none of LPIs, extended SPIs or extended PPIs is supported
gic_distributor.IROUTER-IRM-RAZ-WI=0                  # (bool  , init-time) default = '0'      : GICD_IROUTERn.InterruptRoutingMode is RAZ/WI
gic_distributor.ITS-BASER-force-page-alignement=1     # (bool  , init-time) default = '1'      : Force alignement of address writen to a GITS_BASER register to the page size configured
gic_distributor.ITS-ID-bits=16                        # (int   , init-time) default = '0x10'   : Number of interrupt bits supported by ITS.
gic_distributor.ITS-MOVALL-update-collections=0       # (bool  , init-time) default = '0'      : Whether MOVALL command updates the collection entires
gic_distributor.ITS-cache-invalidate-on-disable=0     # (bool  , init-time) default = '0'      : Sets the RO bit GITS_TYPER.INV. When true, after the following sequence: 1) GITS_CTLR.Enabled written 1-->0, 2) GITS_CTLR.Quiescent observed as 1, 3) GITS_BASER<n>.Valid written 1-->0, there is no cached information from the ITS memory structure pointed to by GITS_BASER<n>.
gic_distributor.ITS-collection-ID-bits=0              # (int   , init-time) default = '0x0'    : Number of collection bits supported by ITS (optional parameter, 0 => 16bits support and GITS_TYPER.CIL=0
gic_distributor.ITS-count=1                           # (int   , init-time) default = '0x1'    : Number of Interrupt Translation Services to be instantiated (0=none)
gic_distributor.ITS-cumulative-collection-tables=1    # (bool  , init-time) default = '1'      : When true, the supported amount of collections is the sum of GITS_TYPER.HCC and the number of collections supported in memory, otherwise, simply the number supported in memory only. Irrelevant when HCC=0
gic_distributor.ITS-device-bits=17                    # (int   , init-time) default = '0x11'   : Number of bits supported for ITS device IDs.
gic_distributor.ITS-entry-size=8                      # (int   , init-time) default = '0x8'    : Number of bytes required to store each entry in the ITT tables.
gic_distributor.ITS-hardware-collection-count=0       # (int   , init-time) default = '0x0'    : Number of hardware collections held exclusively in the ITS
gic_distributor.ITS-legacy-iidr-typer-offset=0        # (bool  , init-time) default = '0'      : Put the GITS_IIDR and GITS_TYPER registers at their older offset of 0x8 and 0x4 respectively
gic_distributor.ITS-shared-vPE-table=0                # (int   , init-time) default = '0x0'    : Number of affinity levels to which the vPE configuration table is shared. This parameter is valid when has-gicv4.1 is true.
gic_distributor.ITS-threaded-command-queue=1          # (bool  , init-time) default = '1'      : Enable execution of ITS commands in a separate thread which is sometimes required for cosimulation
gic_distributor.ITS-use-physical-target-addresses=1   # (bool  , init-time) default = '1'      : Use physical hardware adresses for targets in ITS commands -- must be true for distributed implementations
gic_distributor.ITS-vmovp-bit=0                       # (bool  , init-time) default = '0'      : Device supports software issuing a VMOVP to only one of the ITSs that has a mapping for a vPE. The device itself ensures synchronization of the VMOVP command across all ITSs that have mapping for that vPE.
gic_distributor.ITS0-base=788660224                   # (int   , init-time) default = '0x2f020000' : The ITS0 Base address
gic_distributor.ITS1-base=0                           # (int   , init-time) default = '0x0'    : Register base address for ITS1 (automatic if 0).
gic_distributor.ITS2-base=0                           # (int   , init-time) default = '0x0'    : Register base address for ITS2 (automatic if 0).
gic_distributor.ITS3-base=0                           # (int   , init-time) default = '0x0'    : Register base address for ITS3 (automatic if 0).
gic_distributor.LPI-cache-check-data=0                # (bool  , init-time) default = '0'      : Enable Cached LPI data against memory checking when available for cache type
gic_distributor.LPI-cache-type=1                      # (int   , init-time) default = '0x1'    : Cache type for LPIs, 0:No caching, 1:Full caching
gic_distributor.MSI_IIDR=0                            # (int   , init-time) default = '0x0'    : Value returned in MSI_IIDR registers.
gic_distributor.MSI_NS-frame0-base=0                  # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 0 registers.
gic_distributor.MSI_NS-frame0-max-SPI=0               # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 0. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame0-min-SPI=0               # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 0. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame1-base=0                  # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 1 registers.
gic_distributor.MSI_NS-frame1-max-SPI=0               # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 1. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame1-min-SPI=0               # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 1. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame2-base=0                  # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 2 registers.
gic_distributor.MSI_NS-frame2-max-SPI=0               # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 2. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame2-min-SPI=0               # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 2. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame3-base=0                  # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 3 registers.
gic_distributor.MSI_NS-frame3-max-SPI=0               # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 3. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame3-min-SPI=0               # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 3. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame4-base=0                  # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 4 registers.
gic_distributor.MSI_NS-frame4-max-SPI=0               # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 4. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame4-min-SPI=0               # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 4. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame5-base=0                  # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 5 registers.
gic_distributor.MSI_NS-frame5-max-SPI=0               # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 5. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame5-min-SPI=0               # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 5. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame6-base=0                  # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 6 registers.
gic_distributor.MSI_NS-frame6-max-SPI=0               # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 6. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame6-min-SPI=0               # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 6. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame7-base=0                  # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for non-secure MSI frame 7 registers.
gic_distributor.MSI_NS-frame7-max-SPI=0               # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by non-secure MSI frame 7. Set to 0 to disable frame.
gic_distributor.MSI_NS-frame7-min-SPI=0               # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by non-secure MSI frame 7. Set to 0 to disable frame.
gic_distributor.MSI_PIDR=0                            # (int   , init-time) default = '0x0'    : The value for the MSI_PIDR registers, if non-zero and distributor supports GICv2m. Note: fixed fields (device type etc.) will be overriden in this value.
gic_distributor.MSI_S-frame0-base=0                   # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 0 registers.
gic_distributor.MSI_S-frame0-max-SPI=0                # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 0. Set to 0 to disable frame.
gic_distributor.MSI_S-frame0-min-SPI=0                # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 0. Set to 0 to disable frame.
gic_distributor.MSI_S-frame1-base=0                   # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 1 registers.
gic_distributor.MSI_S-frame1-max-SPI=0                # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 1. Set to 0 to disable frame.
gic_distributor.MSI_S-frame1-min-SPI=0                # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 1. Set to 0 to disable frame.
gic_distributor.MSI_S-frame2-base=0                   # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 2 registers.
gic_distributor.MSI_S-frame2-max-SPI=0                # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 2. Set to 0 to disable frame.
gic_distributor.MSI_S-frame2-min-SPI=0                # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 2. Set to 0 to disable frame.
gic_distributor.MSI_S-frame3-base=0                   # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 3 registers.
gic_distributor.MSI_S-frame3-max-SPI=0                # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 3. Set to 0 to disable frame.
gic_distributor.MSI_S-frame3-min-SPI=0                # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 3. Set to 0 to disable frame.
gic_distributor.MSI_S-frame4-base=0                   # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 4 registers.
gic_distributor.MSI_S-frame4-max-SPI=0                # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 4. Set to 0 to disable frame.
gic_distributor.MSI_S-frame4-min-SPI=0                # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 4. Set to 0 to disable frame.
gic_distributor.MSI_S-frame5-base=0                   # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 5 registers.
gic_distributor.MSI_S-frame5-max-SPI=0                # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 5. Set to 0 to disable frame.
gic_distributor.MSI_S-frame5-min-SPI=0                # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 5. Set to 0 to disable frame.
gic_distributor.MSI_S-frame6-base=0                   # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 6 registers.
gic_distributor.MSI_S-frame6-max-SPI=0                # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 6. Set to 0 to disable frame.
gic_distributor.MSI_S-frame6-min-SPI=0                # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 6. Set to 0 to disable frame.
gic_distributor.MSI_S-frame7-base=0                   # (int   , init-time) default = '0x0'    : If non-zero, sets the base address used for secure MSI frame 7 registers.
gic_distributor.MSI_S-frame7-max-SPI=0                # (int   , init-time) default = '0x0'    : Maximum SPI ID supported by secure MSI frame 7. Set to 0 to disable frame.
gic_distributor.MSI_S-frame7-min-SPI=0                # (int   , init-time) default = '0x0'    : Minimum SPI ID supported by secure MSI frame 7. Set to 0 to disable frame.
gic_distributor.PA_SIZE=48                            # (int   , init-time) default = '0x30'   : Number of valid bits in physical address
gic_distributor.PPI-implemented-mask=65535            # (int   , init-time) default = '0xffff' : Mask of PPIs that are implemented. One bit per PPI bit 0 == PPI 16 (first PPI). This will affect other masks.
gic_distributor.SPI-count=224                         # (int   , init-time) default = '0xe0'   : Number of SPIs that are implemented.
gic_distributor.SPI-message-based-support=1           # (bool  , init-time) default = '1'      : Distributor supports message based signaling of SPI
gic_distributor.SPI-unimplemented=                    # (string, init-time) default = ''       : A comma spearated list of unimplemented SPIs ranges for sparse SPI definition(for ex: '35, 39-42, 73)'
gic_distributor.STATUSR-implemented=1                 # (bool  , init-time) default = '1'      : Determines whether the GICR_STATUSR register is implemented.
gic_distributor.add-output-cpu-wake-request-signal-from-redistributor=0  # (bool  , init-time) default = '0'      : if true, the redistributor will have the output signal cpu_wake_request from GIC to DSU and if false, the signals are not added to the redistributor
gic_distributor.allow-LPIEN-clear=0                   # (bool  , init-time) default = '0'      : Allow RW behaviour on GICR_CTLR.LPIEN isntead of set once
gic_distributor.chip-count=16                         # (int   , init-time) default = '0x10'   : The total number of chips supported.
gic_distributor.chip-id=0                             # (int   , init-time) default = '0x0'    : Chip ID when multichip operation is enabled.
gic_distributor.clear-ISPENDR-bit-for-level-sensitive-interrupt-when-acknowledged=0  # (bool  , init-time) default = '0'      : If true, acknowledgement of a level sensitive interrupt clears the corresponding bit in the ISPENDR register.
gic_distributor.common-lpi-configuration=0            # (int   , init-time) default = '0x0'    : Describes which re-distributors share (and must be configured with the same) LPI configuration table as described in GICR_TYPER( 0:All, 1:A.x.x.x, 2:A.B.x.x, 3:A.B.C.x
gic_distributor.common-vPE-table-affinity=            # (string, init-time) default = ''       : Affinity value list in the form of 'a.b.c.d, e.f.g.h, etc' given to the ITS(s) (where a.b.c.d corresponds to ITS0, e.f.g.h corresponds to ITS1 and so on). Under an affinity value the vPE configuration table is shared among redistributors where the level to be shared is defined by ITS-shared-vPE-table. This parameter is valid when has-gicv4.1 is true.
gic_distributor.consolidators=                        # (string, init-time) default = ''       : Specify consolidators' base addresses, interrupt line counts and base interrupt IDs, in the form 'baseAddr0:itlineCount0:baseINTID0, baseAddr1:itlineCount1:baseINTID1, [etc]' (eg '0x3f100000:64:4096, 0x3f200000:64:4224'). The consolidators' count is inferred from the list (maximum of 4). If not specified, the component contains no consolidators.
gic_distributor.delay-ITS-accesses=1                  # (bool  , init-time) default = '1'      : Delay accesses from the ITS until GICR_SYNCR is read.
gic_distributor.delay-redistributor-accesses=1        # (bool  , init-time) default = '1'      : Delay memory accesses from the redistributor until GICR_SYNCR is read.
gic_distributor.direct-lpi-support=0                  # (bool  , init-time) default = '0'      : Enable support for LPI operations through GICR registers
gic_distributor.enable-local-cross-chip-addressing=0  # (bool  , init-time) default = '0'      : If true, each distributor in a multichip system will use routing table address (ADDR) values programmed by local software, and will not be overwritten by the default chip. Otherwise, all the distributors will share the same routing table address values programmed in the default chip. This parameter is valid only if enable-multichip-operation is set.
gic_distributor.enable-multichip-operation=0          # (bool  , init-time) default = '0'      : Enables multi-chip operation between Distributors in distributed GIC IRI
gic_distributor.enable_protocol_checking=0            # (bool  , init-time) default = '0'      : Enable/disable protocol checking at cpu interface
gic_distributor.enabled=1                             # (bool  , init-time) default = '1'      : Enable GICv3 functionality; when false the component is inactive. This will be replaced by "has_gicv3" when GICv3 is replaced by GIC
gic_distributor.extended-ppi-count=0                  # (int   , init-time) default = '0x0'    : Number of extended PPI supported
gic_distributor.extended-spi-count=0                  # (int   , init-time) default = '0x0'    : Number of extended SPI supported
gic_distributor.fixed-routed-spis=                    # (string, init-time) default = ''       : Value of IROUTER[n] register in the form 'n=a.b.c.d, n=*'. The RM bit of IROUTER is 0 when n=a.b.c.d is used else 1 when n=* is used. n can be >= 32 and <= 1019
gic_distributor.group-enables-control-doorbell=0      # (bool  , init-time) default = '0'      : When true, GICR_VPENDBASER.{VGrp0En,VGrp1En} are cached to allow GIC to check group enables when virtual interrupt targeting this VCPU which is non-resident reaches Redistributor.
gic_distributor.has-gicv3=1                           # (bool  , init-time) default = '1'      : Enable GICv3 functionality; when false the component is inactive.
gic_distributor.has-two-security-states=1             # (bool  , init-time) default = '1'      : If true, has two security states
gic_distributor.has_VPENDBASER-dirty-flag-on-load=0   # (bool  , init-time) default = '0'      : GICR_VPENDBASER.Dirty reflects transient loading state when valid=1
gic_distributor.has_mpam=0                            # (bool  , init-time) default = '0'      : Enable MPAM support on ITS and RDs
gic_distributor.has_nmi=0                             # (bool  , init-time) default = '0'      : Enable support for Non-maskable Interrupts (NMIs). (FEAT_GICv3_NMI)
gic_distributor.has_rme=0                             # (bool  , init-time) default = '0'      : If true, Realm management extension is supported in GIC.
gic_distributor.ignore-generate-sgi-when-no-are=0     # (bool  , init-time) default = '0'      : Ignore GenerateSGI packets coming form the CPU interface if both ARE_S and ARE_NS are 0
gic_distributor.individual-doorbell-not-supported=0   # (bool  , init-time) default = '0'      : For IRI with support of virtual interrupt, individual doorbell is not supported when true.
gic_distributor.irouter-default-mask=                 # (string, init-time) default = ''       : Default Mask value for IROUTER[32..1019] register in the form 'a.b.c.d'
gic_distributor.irouter-default-reset=                # (string, init-time) default = ''       : Default Reset Value of IROUTER[32..1019] register in the form 'a.b.c.d' or *
gic_distributor.irouter-mask-values=                  # (string, init-time) default = ''       : Mask Value of IROUTER[n] register in the form 'n=a.b.c.d'.n can be >= 32 and <= 1019
gic_distributor.irouter-reset-values=                 # (string, init-time) default = ''       : Reset Value of IROUTER[n] register in the form 'n=a.b.c.d or n=*'.n can be >= 32 and <= 1019
gic_distributor.legacy-sgi-enable-rao=0               # (bool  , init-time) default = '0'      : Enables for SGI associated with an ARE=0 regime are RAO/WI
gic_distributor.local-SEIs=0                          # (bool  , init-time) default = '0'      : Generate SEI to signal internal issues
gic_distributor.local-VSEIs=0                         # (bool  , init-time) default = '0'      : Generate VSEI to signal internal issues
gic_distributor.lockable-SPI-count=0                  # (int   , init-time) default = '0x0'    : Number of SPIs that are locked down when CFGSDISABLE signal is asserted.  Only applies for GICv2.
gic_distributor.max-pe-on-chip=4                      # (int   , init-time) default = '0x4'    : Maximum number of cores on any single chip. This will be used to identify the target chip and core when multichip operation is enabled.
gic_distributor.monolithic=0                          # (bool  , init-time) default = '0'      : Indicate that the implementation is not distributed
gic_distributor.mpam_max_partid=65535                 # (int   , init-time) default = '0xffff' : Maximum valid PARTID
gic_distributor.mpam_max_pmg=255                      # (int   , init-time) default = '0xff'   : Maximum valid PMG
gic_distributor.multichip-threaded-dgi=1              # (bool  , init-time) default = '1'      : Enable sending multichip DGI messages in a separate thread. This parameter is valid only if enable-multichip-operation is set.
gic_distributor.non-ARE-core-count=8                  # (int   , init-time) default = '0x8'    : Maximum number of non-ARE cores; normally used to pass the cluster-level NUM_CORES parameter to the top-level redistributor.
gic_distributor.outer-cacheability-support=0          # (bool  , init-time) default = '0'      : Allow configuration of outer cachability attributes in ITS and Redistributor
gic_distributor.output_attributes=ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS  # (string, init-time) default = 'ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS' : User-defined transform to be applied to bus attributes like MasterID, ExtendedID or UserFlags. Currently, only works for MPAM Attributes encoding into bus attributes.
gic_distributor.print-memory-map=0                    # (bool  , init-time) default = '0'      : Print memory map to stdout
gic_distributor.priority-bits=5                       # (int   , init-time) default = '0x5'    : Number of implemented priority bits
gic_distributor.prog-mpidr=0                          # (int   , init-time) default = '0x0'    : Whether software or hardware can remove cores from a GIC configuration. (0: none, 1: prog - Secure software to remove cores during the boot up of a system. 2: stap - enables hardware to remove cores as GIC exits reset)
gic_distributor.redistributor-threaded-sync=1         # (bool  , init-time) default = '1'      : Enable execution of redistributor delayed transactions in a separate thread which is sometimes required for cosimulation
gic_distributor.reg-base=788529152                    # (int   , init-time) default = '0x2f000000' : Base for decoding GICv3/GICv4 registers.
gic_distributor.reg-base-per-redistributor=0.0.0.0=0x2f100000,0.0.1.0=0x2f120000,0.0.2.0=0x2f140000,0.0.3.0=0x2f160000,0.1.0.0=0x2f180000,0.1.1.0=0x2f1a0000,0.1.2.0=0x2f1c0000,0.1.3.0=0x2f1e0000  # (string, init-time) default = '0.0.0.0=0x2f100000,0.0.1.0=0x2f120000,0.0.2.0=0x2f140000,0.0.3.0=0x2f160000,0.1.0.0=0x2f180000,0.1.1.0=0x2f1a0000,0.1.2.0=0x2f1c0000,0.1.3.0=0x2f1e0000' : Base address for each redistributor in the form '0.0.0.0=0x2c010000, 0.0.0.1=0x2c020000'.  All redistributors must be specified and this overrides the reg-base parameter (except that reg-base will still be used for the top-level redistributor). If reg-base-per-redistributor-file is specified, this parameter is ignored.
gic_distributor.reg-base-per-redistributor-file=      # (string, init-time) default = ''       : Path to file containing the base address for each redistributor in the form '0.0.0.0=0x2c010000, 0.0.0.1=0x2c020000'.  All redistributors must be specified and this overrides the reg-base parameter (except that reg-base will still be used for the top-level redistributor). If this parameter is specified, reg-base-per-redistributor parameter will be ignored even when it is given.
gic_distributor.report-MSI-error-via-statusr=0        # (int   , init-time) default = '0x0'    : Report MSI error via GITS_STATUSR. (0:unsupported, 1:report by GITS_STATUSR, 2:report by GITS_STATUSR and interrupt as well).
gic_distributor.sgi-range-selector-support=0          # (bool  , init-time) default = '0'      : Device has support for the Range Selector feature for SGI
gic_distributor.single-set-support=0                  # (bool  , init-time) default = '0'      : When true, forces redistributors to recall interrupts with a clear rather than issue a second Set command
gic_distributor.supports-shareability=1               # (bool  , init-time) default = '1'      : Device supports shareability attributes on outgoing memory bus (i.e. is modelling an ACElite port rather than an AXI4 port).
gic_distributor.trace-speculative-lpi-property-update=0  # (bool  , init-time) default = '0'      : Trace LPI property updates performed on speculative accesses (useful for debugging LPI)
gic_distributor.vPE-table-entry-size-in-doubleword=5  # (int   , init-time) default = '0x5'    : The size of one entry of a vPE configuration table in double word. The value decremented by one is shown at GICR_VPROPBASER.Entry_Size. Current model mandates the minimum entry size to be 4 doublewords. When lower value is given, it is truncated to 4.
gic_distributor.virtual-lpi-support=0                 # (bool  , init-time) default = '0'      : GICv4 Virtual LPIs and Direct injection of Virtual LPIs supported
gic_distributor.virtual-priority-bits=5               # (int   , init-time) default = '0x5'    : Number of implemented virtual priority bits
gic_distributor.wakeup-on-reset=0                     # (bool  , init-time) default = '0'      : Go against specification and start redistributors in woken-up state at reset. This allows software that was written for previous versions of the GICv3 specification to work correctly. This should not be used for production code or when the distributor is used separately from the core fast model.
gicv3.gicv2-only=0                                    # (bool  , init-time) default = '0'      : When using the GICv3 model, pretend to be a GICv2 system.
gpu.gpu.revision=r0p0                                 # (string, init-time) default = 'r0p0'   : Revision of the RTL that the model represents. Valid values: r0p0
has-gicv4.1=0                                         # (bool  , init-time) default = '0'      : Enable GICv4.1 functionality; when false the component is inactive.
niden=1                                               # (bool  , init-time) default = '1'      : Debug authentication signal niden
pci.ahci_pci.ahci.force_mode=NCQ                      # (string, init-time) default = 'NCQ'    : Force disk to report support for at most PIO/DMA/NCQ mode (only for testing/bring-up purposes). PIO mode is always supported. Use NCQ for maximum performance (default).
pci.ahci_pci.ahci.image_path=                         # (string, init-time) default = ''       : Comma separated list of zero or more disk images (up to 32). Each image represents one SATA disk which is connected to one port of the AHCI controller. Empty list elements are allowed and result in a SATA port which has no disk attached. Empty string (default) means: One SATA port with no disk attached. Use 'truncate -s 4T disk.img' to create a 4 TByte sparse image. Use 'dd if=/dev/zero of=disk.img bs=1M count=42' to create a 42 MByte non-sparse image.
pci.ahci_pci.ahci.run_async=0                         # (bool  , init-time) default = '0'      : Do host I/O in a background thread asynchronously. Enabling this makes the simulation non-deterministic and may or may not improve performance. Default is 'false' (do all disk accesses synchronously).
pci.ahci_pci.bus=0                                    # (int   , init-time) default = '0x0'    : Bus number for this device
pci.ahci_pci.buslogger.trace_debug=0                  # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.ahci_pci.buslogger.trace_snoops=0                 # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pci.ahci_pci.device=3                                 # (int   , init-time) default = '0x3'    : Device number on this bus
pci.ahci_pci.diagnostics=0                            # (int   , init-time) default = '0x0'    : Diagnostics level
pci.ahci_pci.pcidevice.atc_size=0                     # (int   , init-time) default = '0x0'    : The maximum number of ATC entries. 0 is effectively a large number.
pci.ahci_pci.pcidevice.ats_supported=0                # (bool  , init-time) default = '0'      : The device can use ATS.
pci.ahci_pci.pcidevice.bar0_64bit=0                   # (bool  , init-time) default = '0'      : If BAR 0 is 64 bits wide, if region size is non zero
pci.ahci_pci.pcidevice.bar0_log2_size=13              # (int   , init-time) default = '0xd'    : Log2 of the size the region pointed to by BAR 0, zero is reserved means bar is not used
pci.ahci_pci.pcidevice.bar1_log2_size=13              # (int   , init-time) default = '0xd'    : Log2 of the size the region pointed to by BAR 1, zero is reserved means bar is not used
pci.ahci_pci.pcidevice.bar2_64bit=0                   # (bool  , init-time) default = '0'      : If BAR 2 is 64 bits wide, if region size is non zero
pci.ahci_pci.pcidevice.bar2_log2_size=12              # (int   , init-time) default = '0xc'    : Log2 of the size the region pointed to by BAR 2, zero is reserved means bar is not used
pci.ahci_pci.pcidevice.bar3_log2_size=13              # (int   , init-time) default = '0xd'    : Log2 of the size the region pointed to by BAR 3, zero is reserved means bar is not used
pci.ahci_pci.pcidevice.bar4_64bit=0                   # (bool  , init-time) default = '0'      : If BAR 4 is 64 bits wide, if region size is non zero
pci.ahci_pci.pcidevice.bar4_log2_size=12              # (int   , init-time) default = '0xc'    : Log2 of the size the region pointed to by BAR 4, zero is reserved means bar is not used
pci.ahci_pci.pcidevice.bar5_log2_size=13              # (int   , init-time) default = '0xd'    : Log2 of the size the region pointed to by BAR 5, zero is reserved means bar is not used
pci.ahci_pci.pcidevice.dmalogger.trace_debug=0        # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.ahci_pci.pcidevice.dmalogger.trace_snoops=0       # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pci.ahci_pci.pcidevice.express_capability_device_type=0  # (int   , init-time) default = '0x0'    : PCI Express Capabilities Device Type, bits 4:7 in capabilites register.  0 is PCIe EndPoint, 9 is RCiEP.
pci.ahci_pci.pcidevice.incoming_memory_logger.trace_debug=0  # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.ahci_pci.pcidevice.incoming_memory_logger.trace_snoops=0  # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pci.ahci_pci.pcidevice.lost_mastered_transactions.trace_debug=0  # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.ahci_pci.pcidevice.lost_mastered_transactions.trace_snoops=0  # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pci.ahci_pci.pcidevice.lost_transactions_to_pcie.trace_debug=0  # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.ahci_pci.pcidevice.lost_transactions_to_pcie.trace_snoops=0  # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pci.ahci_pci.pcidevice.msix_pba_logger.trace_debug=0  # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.ahci_pci.pcidevice.msix_pba_logger.trace_snoops=0  # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pci.ahci_pci.pcidevice.msix_support=1                 # (bool  , init-time) default = '1'      : Enable device support for MSI-X
pci.ahci_pci.pcidevice.msix_table_logger.trace_debug=0  # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.ahci_pci.pcidevice.msix_table_logger.trace_snoops=0  # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pci.ahci_pci.pcidevice.msix_upsize=0                  # (bool  , init-time) default = '0'      : Upsize the MSI-X transaction to 64 bit and place the BDF bits [47:32]
pci.ahci_pci.pcidevice.pasid_execution_permission_supported=1  # (bool  , init-time) default = '1'      : The device can emit PASIDs with the Execute bit set
pci.ahci_pci.pcidevice.pasid_global_invalidate_supported=1  # (bool  , init-time) default = '1'      : The device can receive ATC Invalidates with the global invalidate flag set.
pci.ahci_pci.pcidevice.pasid_max_width=20             # (int   , init-time) default = '0x14'   : The maximum PASID width the device can emit
pci.ahci_pci.pcidevice.pasid_privileged_mode_supported=1  # (bool  , init-time) default = '1'      : The device can emit PASIDs with the Privileged Mode bit set
pci.ahci_pci.pcidevice.pasid_supported=0              # (bool  , init-time) default = '0'      : If set then the PCIe device can emit PASID (SubstreamIDs)
pci.ahci_pci.pcidevice.pcie_version=1                 # (int   , init-time) default = '0x1'    : PCIe version , bits 0:3 in capabilites register.  1 is PCIe3.0.  2 is PCIe4.0.
pci.ahci_pci.pcidevice.power_mgmt_capability=1        # (bool  , init-time) default = '1'      : Device supports Power-Management capabilities
pci.ahci_pci.pcidevice.pri_capacity=255               # (int   , init-time) default = '0xff'   : The maximum number of PRI credits that this device will advertise in its PRI Extended Capability Header.
pci.ahci_pci.pcidevice.pri_prg_response_pasid_required=1  # (bool  , init-time) default = '1'      : The PRG responses from the SMMU requires a PASID attached.
pci.ahci_pci.pcidevice.pri_supported=0                # (bool  , init-time) default = '0'      : The device can use PRI (requires ATS).
pci.ahci_pci.pcidevice.seed=305419896                 # (int   , init-time) default = '0x12345678' : The random number generator seed for the ATC
pci.ahci_pci.pcidevice.to_client_memory_logger.trace_debug=0  # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.ahci_pci.pcidevice.to_client_memory_logger.trace_snoops=0  # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pci.pci_smmuv3.enable_device_id_checks=1              # (bool  , init-time) default = '1'      : Enable warning messages from SMMUv3 regarding Device ID checks
pci.pci_smmuv3.mmu.PRESET_REL_base_address=0          # (int   , init-time) default = '0x0'    : If using preset addresses (SMMU_IDR1.QUEUES_PRESET/TABLES_PRESET) then
                                                      #                                        : the queue and table base registers become fixed.  If SMMU_IDR1.REL
                                                      #                                        : then the addresses are relative to the base of the register file and
                                                      #                                        : this parameter tells the model what address to add to the queue/table
                                                      #                                        : addresses to calculate the actual address.
                                                      #                                        : 
                                                      #                                        : This is for 'embedded implementations' where the memory for these
                                                      #                                        : structures is held within the SMMU itself or in a 'close' RAM.  The
                                                      #                                        : model does not contain any RAM and the integrator must supply a RAM at
                                                      #                                        : the appropriate address.
                                                      #                                        : 
                                                      #                                        : If the preset tables/queues overlap, the RAM has to implement separate
                                                      #                                        : secure and non-secure address spaces.
                                                      #                                        : 
                                                      #                                        : See also:
                                                      #                                        :   * TABLES_PRESET_smmu_{,s_,r_}strtab_base
                                                      #                                        :   * TABLES_PRESET_smmu_{,s_,r_}strtab_base_cfg
                                                      #                                        :   * QUEUES_PRESET_smmu_{,s_,r_}cmdq_base
                                                      #                                        :   * QUEUES_PRESET_smmu_{,s_,r_}eventq_base
                                                      #                                        :   * QUEUES_PRESET_smmu_{,r_}priq_base (no secure PRIQ)
pci.pci_smmuv3.mmu.QUEUES_PRESET_smmu_cmdq_base=0     # (int   , init-time) default = '0x0'    : If SMMU_IDR1.QUEUES_PRESET == 1 then this is the value that appears in
                                                      #                                        : SMMU_CMDQ_BASE and SMMU_CMDQ_BASE becomes read-only.
                                                      #                                        : 
                                                      #                                        : See also parameter PRESET_REL_base_address.
pci.pci_smmuv3.mmu.QUEUES_PRESET_smmu_eventq_base=0   # (int   , init-time) default = '0x0'    : If SMMU_IDR1.QUEUES_PRESET == 1 then this is the value that appears in
                                                      #                                        : SMMU_EVENTQ_BASE and SMMU_EVENTQ_BASE becomes read-only.
                                                      #                                        : 
                                                      #                                        : See also parameter PRESET_REL_base_address.
pci.pci_smmuv3.mmu.QUEUES_PRESET_smmu_priq_base=0     # (int   , init-time) default = '0x0'    : If SMMU_IDR1.QUEUES_PRESET == 1 and SMMU_IDR0.PRI == 1 then this is
                                                      #                                        : the value that appears in SMMU_PRIQ_BASE and SMMU_PRIQ_BASE becomes
                                                      #                                        : read-only.
                                                      #                                        : 
                                                      #                                        : See also parameter PRESET_REL_base_address.
pci.pci_smmuv3.mmu.QUEUES_PRESET_smmu_s_cmdq_base=0   # (int   , init-time) default = '0x0'    : If SMMU_IDR1.QUEUES_PRESET == 1 and SMMU_S_IDR1.SECURE_IMPL == 1 then
                                                      #                                        : this is the value that appears in SMMU_S_CMDQ_BASE and
                                                      #                                        : SMMU_S_CMDQ_BASE becomes read-only.
                                                      #                                        : 
                                                      #                                        : See also parameter PRESET_REL_base_address.
pci.pci_smmuv3.mmu.QUEUES_PRESET_smmu_s_eventq_base=0  # (int   , init-time) default = '0x0'    : If SMMU_IDR1.QUEUES_PRESET == 1 and SMMU_S_IDR1.SECURE_IMPL == 1 then
                                                      #                                        : this is the value that appears in SMMU_S_EVENTQ_BASE and
                                                      #                                        : SMMU_S_EVENTQ_BASE becomes read-only.
                                                      #                                        : 
                                                      #                                        : See also parameter PRESET_REL_base_address.
pci.pci_smmuv3.mmu.SMMU_AIDR=1                        # (int   , init-time) default = '0x1'    : SMMU_AIDR contains the Major and Minor architectural revisions numbers
pci.pci_smmuv3.mmu.SMMU_IDR0=135259839                # (int   , init-time) default = '0x80fe6bf' : SMMU_IDR0.
                                                      #                                        : The following fields are further combined with the port
                                                      #                                        : conf_system_supports_{sev,httu,btm,cohacc}:-
                                                      #                                        :   * sev
                                                      #                                        :   * httu
                                                      #                                        :   * btm
                                                      #                                        :   * cohacc
                                                      #                                        : 
                                                      #                                        : NOTE that SMMU_IDR0.RME_IMPL is the value that the SMMU should have
                                                      #                                        : if the SMMU is currently RME-aware.  It will be forced to zero if the
                                                      #                                        : SMMU has been forced to be unaware of RME by legacy_tz_en.
pci.pci_smmuv3.mmu.SMMU_IDR1=242457872                # (int   , init-time) default = '0xe739d10' : SMMU_IDR1.
pci.pci_smmuv3.mmu.SMMU_IDR2=0                        # (int   , init-time) default = '0x0'    : SMMU_IDR2 holds the BA_VATOS field.
pci.pci_smmuv3.mmu.SMMU_IDR3=20                       # (int   , init-time) default = '0x14'   : SMMU_IDR3 is reserved.
pci.pci_smmuv3.mmu.SMMU_IDR4=0                        # (int   , init-time) default = '0x0'    : SMMU_IDR4 is Imp def.
pci.pci_smmuv3.mmu.SMMU_IDR5=65629                    # (int   , init-time) default = '0x1005d' : SMMU_IDR5 contains, amongst others the output address encoded size (OAS).
pci.pci_smmuv3.mmu.SMMU_IDR6=0                        # (int   , init-time) default = '0x0'    : SMMU_IDR6 is RES0 if Enhanced Command Queues do not exist (SMMU_IDR1.ECMDQ == 0).
                                                      #                                        : 
                                                      #                                        : Otherwise, SMMU_IDR6 contains information about the configuration of
                                                      #                                        : the ECMDQs.
pci.pci_smmuv3.mmu.SMMU_IIDR=0                        # (int   , init-time) default = '0x0'    : SMMU_IIDR contains fields for the implementer, product revision, etc.
pci.pci_smmuv3.mmu.SMMU_MPAMIDR=0                     # (int   , init-time) default = '0x0'    : SMMUv3.2: If SMMU_IDR3.MPAM == 1 then SMMU_MPAMIDR holds further ID
                                                      #                                        : information for Memory Partitioning And Monitoring (MPAM) extension.
                                                      #                                        : 
                                                      #                                        : This is optional in SMMUv3.2 and is backported to SMMUv3.1.
pci.pci_smmuv3.mmu.SMMU_ROOT_IDR0=0                   # (int   , init-time) default = '0x0'    : If SMMU_ROOT_IDR0 is 0 then the SMMU is RME-unaware.
                                                      #                                        : 
                                                      #                                        : Otherwise...
                                                      #                                        : 
                                                      #                                        : legacy_tz_en is a pin that when high disables RME and the
                                                      #                                        : SMMU_ROOT_IDR0 register reads as zero.
                                                      #                                        : 
                                                      #                                        : The effective value of legacy_tz_en is derived from
                                                      #                                        :   * the last signalled value sampled at negedge of reset
                                                      #                                        :   * or if never signalled, the inverse of ROOT_IMPL (bit[0]) of this
                                                      #                                        :     parameter.
                                                      #                                        : 
                                                      #                                        : Thus, ROOT_IMPL should be zero if we want legacy_tz_en to start as
                                                      #                                        : high regardless of the actual configuration we want in the
                                                      #                                        : SMMU_ROOT_IDR0 register when the SMMU is RME-aware.
                                                      #                                        : 
                                                      #                                        : In other words, if the SMMU is to be RME-aware, then all parameters
                                                      #                                        : should be configured as though the SMMU is currently RME-aware with
                                                      #                                        : the exception that SMMU_ROOT_IDR0.ROOT_IMPL is the inverse of the
                                                      #                                        : default value of legacy_tz_en.
                                                      #                                        : 
                                                      #                                        : SMMU_ROOT_IDR0.BGPTM is the default value of the pin
                                                      #                                        : conf_system_supports_bgptm.
pci.pci_smmuv3.mmu.SMMU_ROOT_IIDR=0                   # (int   , init-time) default = '0x0'    : The value of the SMMU_ROOT_IIDR register.  If is zero then will
                                                      #                                        : be the same as SMMU_IIDR.
pci.pci_smmuv3.mmu.SMMU_S_IDR0=0                      # (int   , init-time) default = '0x0'    : Secure IDR0 register.
pci.pci_smmuv3.mmu.SMMU_S_IDR1=0                      # (int   , init-time) default = '0x0'    : SMMU_S_IDR1 Indicates if there is a secure side by bit 31.
pci.pci_smmuv3.mmu.SMMU_S_IDR2=0                      # (int   , init-time) default = '0x0'    : SMMU_S_IDR2 Reserved
pci.pci_smmuv3.mmu.SMMU_S_IDR3=0                      # (int   , init-time) default = '0x0'    : SMMU_S_IDR3 Reserved
pci.pci_smmuv3.mmu.SMMU_S_IDR4=0                      # (int   , init-time) default = '0x0'    : SMMU_S_IDR4 IMP DEF
pci.pci_smmuv3.mmu.SMMU_S_IDR6=0                      # (int   , init-time) default = '0x0'    : SMMU_S_IDR6 is RES0 if Secure Enhanced Command Queues do not exist (SMMU_S_IDR0.ECMDQ == 0).
                                                      #                                        : 
                                                      #                                        : Otherwise, SMMU_S_IDR6 contains information about the configuration of
                                                      #                                        : the ECMDQs.
pci.pci_smmuv3.mmu.SMMU_S_MPAMIDR=0                   # (int   , init-time) default = '0x0'    : SMMUv3.2: If SMMU_IDR3.MPAM == 1 then SMMU_S_MPAMIDR holds further ID
                                                      #                                        : information for Memory Partitioning And Monitoring (MPAM) extension.
                                                      #                                        : 
                                                      #                                        : This is optional in SMMUv3.2 and is backported to SMMUv3.1.
pci.pci_smmuv3.mmu.TABLES_PRESET_smmu_s_strtab_base=0  # (int   , init-time) default = '0x0'    : If SMMU_IDR1.TABLES_PRESET == 1 and SMMU_S_IDR1.SECURE_IMPL == 1 then
                                                      #                                        : this is the value that appears in SMMU_S_STRTAB_BASE and
                                                      #                                        : SMMU_S_STRTAB_BASE becomes read-only.
                                                      #                                        : 
                                                      #                                        : See also parameter PRESET_REL_base_address.
pci.pci_smmuv3.mmu.TABLES_PRESET_smmu_s_strtab_base_cfg=0  # (int   , init-time) default = '0x0'    : If SMMU_IDR1.TABLES_PRESET == 1 and SMMU_S_IDR1.SECURE_IMPL == 1 then
                                                      #                                        : this is the value that appears in SMMU_S_STRTAB_BASE_CFG and
                                                      #                                        : SMMU_S_STRTAB_BASE_CFG becomes read-only.
                                                      #                                        : 
                                                      #                                        : See also parameter PRESET_REL_base_address.
pci.pci_smmuv3.mmu.TABLES_PRESET_smmu_strtab_base=0   # (int   , init-time) default = '0x0'    : If SMMU_IDR1.TABLES_PRESET == 1 then this is the value that appears in
                                                      #                                        : SMMU_STRTAB_BASE and SMMU_STRTAB_BASE becomes read-only.
                                                      #                                        : 
                                                      #                                        : See also parameter PRESET_REL_base_address.
pci.pci_smmuv3.mmu.TABLES_PRESET_smmu_strtab_base_cfg=0  # (int   , init-time) default = '0x0'    : If SMMU_IDR1.TABLES_PRESET == 1 then this is the value that appears in
                                                      #                                        : SMMU_STRTAB_BASE_CFG and SMMU_STRTAB_BASE_CFG becomes read-only.
                                                      #                                        : 
                                                      #                                        : See also parameter PRESET_REL_base_address.
pci.pci_smmuv3.mmu.all_error_messages_through_trace=0  # (bool  , init-time) default = '0'      : Some conditions in the SMMU are so strange that the software
                                                      #                                        : programming the SMMU has done something wrong.  At this point
                                                      #                                        : messages are output to either ArchMsg.Error.* or ArchMsg.Warning.* or to
                                                      #                                        : the error stream of the simulator.  Outputting to the error stream of
                                                      #                                        : the simulator may cause it to return with a non-zero exit status.
                                                      #                                        : 
                                                      #                                        : If you set this option to true then instead of using the error stream
                                                      #                                        : of the simulator it will always use a trace stream allowing
                                                      #                                        : the simulation to exit with a zero exit status.
pci.pci_smmuv3.mmu.allow_non_secure_access_to_SMMU_S_INIT=0  # (bool  , init-time) default = '0'      : If the system has no software operating as a secure agent then set this parameter.
                                                      #                                        : This allows non-secure accesses to the SMMU_S_INIT register and allows the
                                                      #                                        : non-secure software to reset the TLB, clearing out any 'secure' TLB entries.
                                                      #                                        : 
                                                      #                                        : If the SMMU does not implement the security extensions
                                                      #                                        : (SMMU_S_IDR1.SECURE_IMPL == 0) then this parameter is ignored.
pci.pci_smmuv3.mmu.apply_ste_instcfg_privcfg_on_all_ats_translated_accesses=0  # (bool  , init-time) default = '0'      : If SMMU_IDR1.ATTR_PERMS_OVR == 0 then this parameter is ignored.
                                                      #                                        : 
                                                      #                                        : Otherwise, if this parameter is:
                                                      #                                        : 
                                                      #                                        :   * false: STE.INSTCFG/PRIVCFG will only be applied to
                                                      #                                        :     ATS-TranslatedTransactions if STE.EATS==split-stage.
                                                      #                                        : 
                                                      #                                        :   * true: STE.INSTCFG/PRIVCFG will be applied to all
                                                      #                                        :     ATS-TranslatedTransactions regardless of the value of STE.EATS.
pci.pci_smmuv3.mmu.ats_split_stage_dbm_update_do_with_ATSRequest=0  # (int   , init-time) default = '0x0'    : When doing split-stage ATS, then the DBM update for the final stage 2
                                                      #                                        : descriptor can be done either whilst processing the ATS request or
                                                      #                                        : delayed until it actually sees the PCIe Translated Transaction using
                                                      #                                        : the stage 2 descriptor.
                                                      #                                        : 
                                                      #                                        :   0 -- do when see actual transaction
                                                      #                                        :   1 -- do when processing the ATS request
                                                      #                                        :   2 -- do it randomly with 50% chance.
pci.pci_smmuv3.mmu.axi_stream_msi_TDEST=0             # (int   , init-time) default = '0x0'    : ID of the AXI stream subordinate port on the GIC that receives SMMU originated MSIs sent directly.
                                                      #                                        : The name of the GIC port is axi_stream_msi_s.
                                                      #                                        : 
                                                      #                                        : NOTE that if axi_stream_msi_addr_to_match[1:0] != 0, or the address is above OAS then this is
                                                      #                                        : effectively disabled.
                                                      #                                        : 
                                                      #                                        : See also:
                                                      #                                        :   * axi_stream_msi_addr_to_match
                                                      #                                        :   * axi_stream_msi_TID
pci.pci_smmuv3.mmu.axi_stream_msi_TID=0               # (int   , init-time) default = '0x0'    : ID of the AXI stream manager port that sends SMMU TCU originated MSIs directly to the GIC.
                                                      #                                        : The name of the SMMU port is axi_stream_msi_m.
                                                      #                                        : 
                                                      #                                        : NOTE that if axi_stream_msi_addr_to_match[1:0] != 0, or the address is above OAS then this is
                                                      #                                        : effectively disabled.
                                                      #                                        : 
                                                      #                                        : See also:
                                                      #                                        :   * axi_stream_msi_addr_to_match
                                                      #                                        :   * axi_stream_msi_TDEST
pci.pci_smmuv3.mmu.axi_stream_msi_addr_to_match=-1    # (int   , init-time) default = '0xffffffffffffffff' : If the last two bits are 0, any SMMU-originated MSI which exactly matches the address will be sent
                                                      #                                        : through the AXI stream port axi_stream_msi_m which is usually connected to the GIC.
                                                      #                                        : 
                                                      #                                        : This parameter drives the value of the axi_stream_msi_addr_to_match_s port at simmulation reset. For
                                                      #                                        : every reset after that, the value of the port will be sampled and used if changed.
                                                      #                                        : 
                                                      #                                        : NOTE that the entire address must match, including bits [1:0].  As MSIs are 32 bit aligned then if
                                                      #                                        : axi_stream_msi_addr_to_match[1:0] != 0, or the address is above OAS then this is effectively
                                                      #                                        : disabled.
                                                      #                                        : 
                                                      #                                        : See also:
                                                      #                                        :   * axi_stream_msi_TID
                                                      #                                        :   * axi_stream_msi_TDEST
pci.pci_smmuv3.mmu.behaviour_of_sampled_at_reset_signals=0  # (int   , init-time) default = '0x0'    : Some configuration signals into the SMMU are sampled on negedge of
                                                      #                                        : reset.
                                                      #                                        : 
                                                      #                                        : However, it can sometimes be hard to arrange to drive a configuration
                                                      #                                        : pin before the negedge of reset.
                                                      #                                        : 
                                                      #                                        : The configuration pins are sampled:
                                                      #                                        :    0 -- at negedge reset.
                                                      #                                        :    1 -- at negedge reset, but if a later change occurs at the same
                                                      #                                        :         simulated time, and no transactions have occurred, then they will
                                                      #                                        :         be resampled and the SMMU reset again.
pci.pci_smmuv3.mmu.cmdq_max_number_of_commands_to_buffer=10  # (int   , init-time) default = '0xa'    : The command queues can buffer fetched commands and commands before issuing them.
                                                      #                                        : This parameter is roughly the maximum number of commands to do this for.
                                                      #                                        : The programmer visible effects are that just because the CONS pointer shows a
                                                      #                                        : command has been _consumed_ does not necessarily mean that it has been issued
                                                      #                                        : (and completed).  Higher values will accentuate this effect.
pci.pci_smmuv3.mmu.hide_warning_E0PD_differs_from_what_would_be_cached=0  # (bool  , init-time) default = '0'      : When this parameter is set to true, warnings that the effective E0PD value differs from what would
                                                      #                                        : be cached in the TLB are disabled. False (warnings are showed) by default.
pci.pci_smmuv3.mmu.hide_warning_NoStreamID_transaction_for_unsupported_PAS_or_MPAM_SP=0  # (bool  , init-time) default = '0'      : When RME is not supported then a NoStreamID transaction with
                                                      #                                        : PAS[1] == 1 or MPAM_SP[1] == 1 is treated as though PAS[1] == 0 and
                                                      #                                        : MPAM_SP[1] == 0.  This is usually a system construction error and is
                                                      #                                        : not expected to occur.
                                                      #                                        : 
                                                      #                                        : The SMMU will warn when this occurs, but the warning can be hidden by
                                                      #                                        : setting this parameter.
pci.pci_smmuv3.mmu.howto_identify=use-identify        # (string, init-time) default = 'use-identify' : If 'use-identify' then will use the 'identify' port to determine the
                                                      #                                        : SSD, StreamID, SubStreamID.  Otherwise, this string extracts them from
                                                      #                                        : the transaction's attributes.
                                                      #                                        : 
                                                      #                                        : Examples:-
                                                      #                                        : 
                                                      #                                        :     SEC_SID=ExtendedID[63], SSV=ExtendedID[62], SubstreamID=ExtendedID[51:32], StreamID=ExtendedID[31:0]
                                                      #                                        :     nSEC_SID=ExtendedID[63], StreamID=ExtendedID[55:24], nSSV=ExtendedID[20], SubstreamID=ExtendedID[19:0]
                                                      #                                        :     StreamID[31:24]=0, StreamID[23:0]=ExtendedID[23:0], SSV=1[0], ...
                                                      #                                        : 
                                                      #                                        : The StreamID (32 b) is valid if SIDV is 1 or both SIDV and
                                                      #                                        : nSIDV are unused.
                                                      #                                        : 
                                                      #                                        : The StreamID is secure if SEC_SID is true.
                                                      #                                        : 
                                                      #                                        : The SubstreamID (20 b) is valid if SSV is true.
                                                      #                                        : 
                                                      #                                        : NoStreamID transactions are identified by SIDV == 0 and the SSD is the
                                                      #                                        : PAS of the transaction and SEC_SID is not used.
                                                      #                                        : 
                                                      #                                        : nSEC_SID, nSSV, nSIDV are available with negative logic.  Negative and
                                                      #                                        : positive logic symbols for the same attribute is a error.  Different
                                                      #                                        : attributes are independent and can use negative or positive logic.
pci.pci_smmuv3.mmu.howto_identify_NoStreamID_extra_info=  # (string, init-time) default = ''       : The behavior of this parameter depends on 'howto_identify'
                                                      #                                        :   * if it equals 'use-identify' then this must be "", otherwise there is an error.
                                                      #                                        :   * if it identifies a NoStreamID transaction (SIDV=0) then this parameter includes one or more of
                                                      #                                        :       * MPAM_SP
                                                      #                                        :       * MPAM_PARTID
                                                      #                                        :       * MPAM_PMG
                                                      #                                        :       * MECID
                                                      #                                        :       * HWATTR_KIND_0
                                                      #                                        :   * in any other case, this parameter is ignored.
                                                      #                                        : Fields set in this parameter MUST NOT overlap the SIDV/nSIDV fields in 'howto_identify'
                                                      #                                        : 
                                                      #                                        : Example:-
                                                      #                                        : 
                                                      #                                        :    MPAM_PMG[7:0]=ExtendedID[62:55], MPAM_PARTID[15:0]=ExtendedID[54:39],
                                                      #                                        :      MPAM_SP[1:0]=ExtendedID[38:37], MECID[15:0]=UserFlags[31:16]
                                                      #                                        :      HWATTR_KIND_0[3:0]=ExtendedID[42:39]
pci.pci_smmuv3.mmu.httu_early_st2_permission_fault_if_af_update_at_stage1=0  # (int   , init-time) default = '0x0'    : If a stage 1 descriptor needs an HTTU update, but the descriptor is
                                                      #                                        : unwriteable at stage 2 and also a stage 1 permission fault occurs,
                                                      #                                        : then the architecture permits either the stage 1 or stage 2 permission
                                                      #                                        : fault to be recorded.
                                                      #                                        : 
                                                      #                                        :   0 -- stage 1 permission check
                                                      #                                        :        check stage 1 descriptor writeable at stage 2 if AF- or DBM-update required
                                                      #                                        : 
                                                      #                                        :   1 -- check stage 1 descriptor writeable at stage 2 if AF-update required
                                                      #                                        :        stage 1 permission check
                                                      #                                        :        check stage 1 descriptor writeable at stage 2 if DBM-update required
                                                      #                                        : 
                                                      #                                        :   2 -- do behaviour 1 or 2 randomly with a 50% chance.
pci.pci_smmuv3.mmu.httu_memory_types_supported=rawaWB, raWB, waWB, naWB  # (string, init-time) default = 'rawaWB, raWB, waWB, naWB' : This is a comma-separated list of memory types that are IMPLEMENTATION
                                                      #                                        : DEFINED as supporting HTTU.  However, the system must have Far Atomic
                                                      #                                        : support for the specified memory address and memory type.
                                                      #                                        : 
                                                      #                                        : Device types:
                                                      #                                        :   * nGnRnE, nGnRE, nGRE, GRE
                                                      #                                        : 
                                                      #                                        : Normal memory types are composed of an 'inner' and an 'outer'
                                                      #                                        : cacheability.  The model only supports types where the inner and outer
                                                      #                                        : are identical.
                                                      #                                        : 
                                                      #                                        :   * Normal non-cacheable types
                                                      #                                        :      * nc_nb, nc
                                                      #                                        :   * Cacheable types are of the form (na?|(ra)?(wa)?)(WT|WB)(tr)?
                                                      #                                        :      * na/ra/wa -- no/read/write allocate
                                                      #                                        :      * WT/WB -- write through/write back
                                                      #                                        :      * tr -- transient
                                                      #                                        :      * exceptions:
                                                      #                                        :          * 'na' and 'tr' are incompatible
                                                      #                                        :          * without 'na' then you must specify at least one of ra/wa.
                                                      #                                        :            Example: "WT" is illegal, "raWT" is legal.
                                                      #                                        : 
                                                      #                                        : rawaWB is always supported and it is optional.
                                                      #                                        : 
                                                      #                                        : Examples:
                                                      #                                        :   * "rawaWB, raWB, waWB, naWB" -- only the WB type is supported
                                                      #                                        :   * "nc" -- rawaWB and the normal non-cacheable type are supported
pci.pci_smmuv3.mmu.imp_def_L1CD_L2Ptr_out_of_range=0  # (int   , init-time) default = '0x0'    : If an L1CD.L2Ptr is out of range of IAS/OAS as appropriate then what
                                                      #                                        : happens is controlled by this parameter:
                                                      #                                        :    0 -- if is an IPA, then Stage 2 Translation Fault,
                                                      #                                        :       if is a PA then truncate to OAS
                                                      #                                        :    1 -- generate C_BAD_SUBSTREAMID if an IPA and > IAS, or if a PA and > OAS.
                                                      #                                        :    2 -- generate C_BAD_SUBSTREAMID if an IPA and > IAS, or F_CD_FETCH if a PA and > OAS.
                                                      #                                        :    3 -- truncate the IPA or PA to IAS/OAS as appropriate
                                                      #                                        : 
                                                      #                                        : NOTE that if the model is configured as SMMUv3.1 then this parameter
                                                      #                                        : is IGNORED, and behaves as though this parameter was set to 1.  The
                                                      #                                        : SMMUv3.1 architecture actually allows more behaviours but the model
                                                      #                                        : will only implement this one.
                                                      #                                        : 
                                                      #                                        : NOTE that the SMMUv3.0 allows more behaviours than can be expressed by
                                                      #                                        : this parameter.
pci.pci_smmuv3.mmu.imp_def_PID0=131                   # (int   , init-time) default = '0x83'   : If imp_def_has_PID_CID is true then this is the PID0 value.
pci.pci_smmuv3.mmu.imp_def_PID1=180                   # (int   , init-time) default = '0xb4'   : If imp_def_has_PID_CID is true then this is the PID1 value.
pci.pci_smmuv3.mmu.imp_def_PID2=11                    # (int   , init-time) default = '0xb'    : If imp_def_has_PID_CID is true then this is the PID2 value.
pci.pci_smmuv3.mmu.imp_def_PID3=0                     # (int   , init-time) default = '0x0'    : If imp_def_has_PID_CID is true then this is the PID3 value.
pci.pci_smmuv3.mmu.imp_def_PID4=4                     # (int   , init-time) default = '0x4'    : If imp_def_has_PID_CID is true then this is the PID4 value.
pci.pci_smmuv3.mmu.imp_def_S1ContextPtr_out_of_range=0  # (int   , init-time) default = '0x0'    : If an STE is fetched that uses a stage 1 then if:
                                                      #                                        :   - Stage 1 only and S1ContextPtr > OAS, or
                                                      #                                        :   - Stage 1+2 and S1ContextPtr > IAS
                                                      #                                        : then what happens is IMP DEF and this parameter controls the behaviour:-
                                                      #                                        :    0 -- stage 1 only -- C_BAD_STE
                                                      #                                        :      -- stage 1+2    -- C_BAD_STE
                                                      #                                        :    1 -- stage 1 only -- C_BAD_STE
                                                      #                                        :      -- stage 1+2    -- truncate to IAS
                                                      #                                        :    2 -- stage 1 only -- truncate to OAS
                                                      #                                        :      -- stage 1+2    -- C_BAD_STE
                                                      #                                        :    3 -- stage 1 only -- truncate to OAS
                                                      #                                        :      -- stage 1+2    -- truncate to IAS
                                                      #                                        :    4 -- stage 1 only -- truncate to OAS
                                                      #                                        :      -- stage 1+2    -- Stage 2 translation fault
                                                      #                                        :    5 -- stage 1 only -- C_BAD_STE
                                                      #                                        :      -- stage 1+2    -- Stage 2 translation fault
                                                      #                                        : The architecture also allows for F_CD_FETCH, but the model does not
                                                      #                                        : support this.
                                                      #                                        : 
                                                      #                                        : NOTE that in SMMUv3.1 then the only allowed values of this parameter
                                                      #                                        : are 0 or 5.
pci.pci_smmuv3.mmu.imp_def_alloccfg=0                 # (int   , init-time) default = '0x0'    : ALLOCCFG overrides the read/write/transient hints on cacheable types.
                                                      #                                        : However these are hints and an implementation may choose to treat them
                                                      #                                        : differently.
                                                      #                                        :   0 -- apply the alloc hints as architecturally specified
                                                      #                                        :   1 -- ignore all ALLOCCFG fields (treated as zero)
pci.pci_smmuv3.mmu.imp_def_ats_attribute_stashing=0   # (int   , init-time) default = '0x0'    : The SMMU architecture allows an ATS request to return the attributes
                                                      #                                        : with which to make the Translated Access.  PCIe does not define any
                                                      #                                        : transaction attributes in the ARM sense and so the mechanism for doing
                                                      #                                        : this is IMP DEF.  Usually this would be done by packing them into the
                                                      #                                        : high order address bits of the return response.
                                                      #                                        : 
                                                      #                                        : In the model, then the representation of the ATS reply returns the
                                                      #                                        : attributes directly and it is up to the ATC whether it wants to use
                                                      #                                        : them or not.
                                                      #                                        : 
                                                      #                                        : The parameter configures what to place in those architectural
                                                      #                                        : attributes in the ATS Reply.
                                                      #                                        : 
                                                      #                                        :   0 -- the architectural attributes
                                                      #                                        :   1 -- Inner Write Back, Outer Write Back, Inner Shared, read and
                                                      #                                        :        write allocate, User-Data
                                                      #                                        :   2 -- Inner Write Back, Outer Write Back, Outer Shared, read and
                                                      #                                        :        write allocate, User-Data
                                                      #                                        : 
                                                      #                                        : The SMMU cannot force an ATC to use these attributes, it is simply the
                                                      #                                        : attributes that are returned in the non-PCIe part of the ATS reply.
pci.pci_smmuv3.mmu.imp_def_cohacc_effect=0            # (int   , init-time) default = '0x0'    : SMMU_IDR0.COHACC is a system property.  However, the exact nature of
                                                      #                                        : the transactions that the SMMU emits is an IMP DEF property when
                                                      #                                        : COHACC == 0:
                                                      #                                        :    0 -- COHACC == 0 forces the output attributes of SMMU-generated
                                                      #                                        :       accesses to non-shared.
                                                      #                                        :    1 -- The only effect of COHACC is what is reported in SMMU_IDR0.COHACC
                                                      #                                        :       and has no effect on the output attributes of SMMU-generated
                                                      #                                        :       accesses.
pci.pci_smmuv3.mmu.imp_def_effective_ATTR_TYPES_OVR_is_false_per_port=  # (string, init-time) default = ''       : SMMU_IDR1.ATTR_TYPES_OVR == 1 means that the STE and SMMU_(S_)GBPA
                                                      #                                        : MTCFG/SHCFG/ALLOCCFG have an effect.
                                                      #                                        : 
                                                      #                                        : However, an implementation is allowed to ignore this being one for
                                                      #                                        : specific ports and _not_ apply the overrides MTCFG/SHCFG/ALLOCCFG
                                                      #                                        : despite SMMU_IDR1.ATTR_TYPES_OVR == 1.
                                                      #                                        : 
                                                      #                                        : This parameter is a comma-separated lists of port ranges (indexed from
                                                      #                                        : 0) for those ports where SMMU_IDR1.ATTR_TYPES_OVR behaves as 0.  For
                                                      #                                        : example:
                                                      #                                        : 
                                                      #                                        :   0, 10-20, 40
pci.pci_smmuv3.mmu.imp_def_has_PID_CID=1              # (bool  , init-time) default = '1'      : If this is true then the SMMU model will have the standard PID/CID
                                                      #                                        : ID registers.  Only the PID0..PID4 registers can be customized and
                                                      #                                        : the parameters imp_def_PID0..imp_def_PID4 are used.
pci.pci_smmuv3.mmu.imp_def_ns_bit_for_s_vatos_on_s1_bypass=0  # (int   , init-time) default = '0x0'    : When a Secure VATOS operations for a translation that bypasses stage 1
                                                      #                                        : by S1DSS then the output NS bit is the same as the input NS bit of the
                                                      #                                        : translation.
                                                      #                                        : 
                                                      #                                        : The architecture does not provide an input NS bit in the
                                                      #                                        : SMMU_S_VATOS_ADDR register and it is treated as an IMP DEF value.
                                                      #                                        : 
                                                      #                                        : This parameter specifies that value:
                                                      #                                        :   0 -- secure
                                                      #                                        :   1 -- non-secure
                                                      #                                        :   2 -- random
pci.pci_smmuv3.mmu.imp_def_ras_allow_non_secure_accesses_if_supports_secure=0  # (bool  , init-time) default = '0'      : If two security worlds are supported, i.e.:
                                                      #                                        :   SMMU_S_IDR1.SECURE_IMPL == 1
                                                      #                                        : then if this parameter is true, then non-secure accesses are allowed
                                                      #                                        : to access any RAS registers (see parameter 'ras').  Otherwise,
                                                      #                                        : non-secure accesses are RAZ/WI.
                                                      #                                        : 
                                                      #                                        : If only a single security state (non-secure) is supported, then this
                                                      #                                        : parameter is ignored and non-secure accesses are always allowed.
pci.pci_smmuv3.mmu.imp_def_reset_unknown_fields_to_zero=0  # (bool  , init-time) default = '0'      : Many fields and registers in the SMMUv3 architecture reset to an
                                                      #                                        : UNKNOWN value.  However, many implementations will choose to reset to
                                                      #                                        : 0.  By setting this parameter to true then those fields will be
                                                      #                                        : initialised to zero.
pci.pci_smmuv3.mmu.imp_def_rme_gpf_syndrome_for_PMCG_MSIs=other_gpf  # (string, init-time) default = 'other_gpf' : An MSI access from a PMCG that experiences a GPF is permitted to be
                                                      #                                        : reported as either of:
                                                      #                                        : 
                                                      #                                        :   * REASON = GERROR and FAULTCODE = OTHER_GPF
                                                      #                                        :   * REASON = TRANSACTION
                                                      #                                        : 
                                                      #                                        : The values of this string are one of:
                                                      #                                        :   * other_gpf
                                                      #                                        :   * transaction
                                                      #                                        : 
                                                      #                                        : See also the parameter imp_def_rme_gpf_syndrome_for_RAS_MSIs
pci.pci_smmuv3.mmu.imp_def_rme_gpf_syndrome_for_RAS_MSIs=other_gpf  # (string, init-time) default = 'other_gpf' : An MSI access from a RAS record interrupt that experiences a GPF is
                                                      #                                        : permitted to be reported as either of:
                                                      #                                        : 
                                                      #                                        :    * REASON = GERROR and FAULTCODE = OTHER_GPF
                                                      #                                        :    * REASON = TRANSACTION
                                                      #                                        : 
                                                      #                                        : The values of this string are one of:
                                                      #                                        :   * other_gpf
                                                      #                                        :   * transaction
                                                      #                                        : 
                                                      #                                        : See also the parameter imp_def_rme_gpf_syndrome_for_PMCG_MSIs
pci.pci_smmuv3.mmu.imp_def_rme_mpam_info_from_NoStreamID_on_gpt_walks_ignored=0  # (bool  , init-time) default = '0'      : The MPAM related fields set in 'howto_identify_NoStreamID_extra_info' are ignored when this
                                                      #                                        : parameter is set. This parameter only makes sense when 'howto_identify' equals 'use-identify' so in
                                                      #                                        : any other case it must be false.
                                                      #                                        : 
                                                      #                                        : When this parameter is set:
                                                      #                                        :   * MPAM_SP = PAS
                                                      #                                        :   * MPAM_PARTID = 0
                                                      #                                        :   * MPAM_PMG = 0
pci.pci_smmuv3.mmu.imp_def_split_ATS_attributes_is_stage1=0  # (bool  , init-time) default = '0'      : If using split stage ATS, then it is IMP DEF whether the stage 1 attributes
                                                      #                                        : are returned to the ATS request or stage 2.
                                                      #                                        : 
                                                      #                                        : This only has a meaning if the SMMU can stash attributes in the ATS response.
pci.pci_smmuv3.mmu.imp_def_truncate_out_of_range_streamids_on_invalidate_commands=0  # (bool  , init-time) default = '0'      : If this parameter is true then the StreamID fields of the following
                                                      #                                        : commands will be truncated to (S_)SIDSIZE:
                                                      #                                        : 
                                                      #                                        :   * CMD_ATC_INV
                                                      #                                        :   * CMD_CFGI_STE
                                                      #                                        :   * CMD_CFGI_STE_RANGE
                                                      #                                        :   * CMD_CFGI_CD
                                                      #                                        :   * CMD_CFGI_CD_ALL
                                                      #                                        : 
                                                      #                                        : Otherwise, these commands will NOP.
pci.pci_smmuv3.mmu.imp_def_v3_atos_fault=0            # (int   , init-time) default = '0x0'    : For an IPA to PA ATOS translation that encounters a Stage 1 Address
                                                      #                                        : Size Fault then the PAR.REASON field reports:
                                                      #                                        :    * in SMMUv3.1, 'Stage 1' (0)
                                                      #                                        :    * in SMMUv3.0, 'Stage 1' (0) or 'Input' (3) depending on the
                                                      #                                        :      implementation.
                                                      #                                        : 
                                                      #                                        : This parameter is ignored for SMMUv3.1.
                                                      #                                        : 
                                                      #                                        : For SMMUv3.0 then the values are:
                                                      #                                        :    0 -- report as 'Input' (3)
                                                      #                                        :    1 -- report as 'Stage 1' (0)
pci.pci_smmuv3.mmu.mec_attribute_transform=           # (string, init-time) default = ''       : If MPAM is supported, this is applied to _all_ downstream transactions
                                                      #                                        : to transport the MPAM information.
                                                      #                                        :   * ""/"none" -- no transform
                                                      #                                        :   * How to alter the output attributes. Example:
                                                      #                                        :       "UserFlags[31:16]=MECID[15:0]"
                                                      #                                        : 
                                                      #                                        : 
                                                      #                                        : RHS/LHS Symbols:
                                                      #                                        :   * ExtendedID/MasterID/UserFlags.
                                                      #                                        : 
                                                      #                                        : RHS Symbols:
                                                      #                                        :   * MECID
                                                      #                                        :   * numeric literals.
                                                      #                                        : 
                                                      #                                        : Any bits with no transform are unchanged.
                                                      #                                        : 
                                                      #                                        : NOTE:
                                                      #                                        :   * attribute transforms applied before this:
                                                      #                                        :     * for client transactions 'output_attribute_transform'/'output_attribute_transform_for_NoStreamID'.
                                                      #                                        :     * for table walks 'tw_qs_attribute_transform'.
                                                      #                                        :     * for MSIs 'msi_attribute_transform'.
                                                      #                                        :     * if MPAM is enabled 'mpam_attribute_transform'.
pci.pci_smmuv3.mmu.mpam_attribute_transform=ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS  # (string, init-time) default = 'ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_NS' : If MPAM is supported, this is applied to _all_ downstream transactions
                                                      #                                        : to transport the MPAM information.
                                                      #                                        :   * ""/"none" -- no transform
                                                      #                                        :   * How to alter the output attributes. Example:
                                                      #                                        :       "ExtendedID[62:55]=MPAM_PMG, ExtendedID[54:39]=MPAM_PARTID, ExtendedID[38]=MPAM_SP[0]"
                                                      #                                        : 
                                                      #                                        : RHS/LHS Symbols:
                                                      #                                        :   * ExtendedID/MasterID/UserFlags.
                                                      #                                        : 
                                                      #                                        : RHS Symbols:
                                                      #                                        :   * MPAM_PARTID
                                                      #                                        :   * MPAM_PMG
                                                      #                                        :   * MPAM_NS
                                                      #                                        :   * MPAM_SP
                                                      #                                        :   * numeric literals
                                                      #                                        : 
                                                      #                                        : Any bits with no transform are unchanged.
                                                      #                                        : 
                                                      #                                        : NOTE:
                                                      #                                        :   * attribute transforms applied before this:
                                                      #                                        :     * for client transactions 'output_attribute_transform'/'output_attribute_transform_for_NoStreamID'.
                                                      #                                        :     * for table walks 'tw_qs_attribute_transform'.
                                                      #                                        :     * for MSIs 'msi_attribute_transform'.
                                                      #                                        :   * 'mec_attribute_transform' is applied after this.
                                                      #                                        :   * for translated transactions from client devices then MPAM_NS = ! SEC_SID.
pci.pci_smmuv3.mmu.msi_attribute_transform=ExtendedID[31:0]=smmu_msi_device_id, MasterID=0xFFFFffff  # (string, init-time) default = 'ExtendedID[31:0]=smmu_msi_device_id, MasterID=0xFFFFffff' : Transform downstream attributes of MSI transactions.
                                                      #                                        :   * ""/"none" -- no transform
                                                      #                                        :   * How to alter output attributes of SMMU-generated MSIs. Example:
                                                      #                                        :       "UserFlags[15:0]=smmu_msi_device_id[31:16], MasterID[15:0]=smmu_msi_device_id[15:0],
                                                      #                                        :        ExtendedID=0"
                                                      #                                        : 
                                                      #                                        : RHS/LHS Symbols:
                                                      #                                        :   * ExtendedID/MasterID/UserFlags
                                                      #                                        : 
                                                      #                                        : RHS Symbols:
                                                      #                                        :   * the parameter smmu_msi_device_id
                                                      #                                        :   * the symbol 'interrupt_kind'
                                                      #                                        :      * 0/1     -- EVENTQ s/ns
                                                      #                                        :      * 2       -- PRIQ
                                                      #                                        :      * 3/4     -- CMD_SYNC s/ns
                                                      #                                        :      * 5/6     -- GERROR s/ns
                                                      #                                        :      * 7/8     -- PMCG s/ns
                                                      #                                        :      * 9/10/11 -- RAS FHI/ERI/CRI
                                                      #                                        :   * HWATTR_KIND_0: PBHA information
                                                      #                                        :   * numeric literals.
                                                      #                                        : 
                                                      #                                        : ExtendedID/MasterID/UserFlags start with values {0, 0xFFFFffff, 0} respectively.
                                                      #                                        : 
                                                      #                                        : Any bits with no transform are unchanged.
                                                      #                                        : 
                                                      #                                        : This transform can be used to determine the DeviceID passed to the GIC
                                                      #                                        : to distinguish MSIs generated by the SMMU from those generated by client devices.
                                                      #                                        : 
                                                      #                                        : NOTE:
                                                      #                                        :   * see also 'output_attribute_transform' and enable_device_id_checks.
pci.pci_smmuv3.mmu.msi_ra_wa_tr=7                     # (int   , init-time) default = '0x7'    : A bitmap of the Read Allocation, Write Allocate and Transient hints for
                                                      #                                        : MSIs to cacheable memory:
                                                      #                                        :    bit[0] Transient
                                                      #                                        :    bit[1] Write Allocate
                                                      #                                        :    bit[2] Read Allocate
                                                      #                                        : If not Write Allocate then it will be forced to Read Allocate as a limitation
                                                      #                                        : of AMBA.
pci.pci_smmuv3.mmu.non_arch_incoming_stronger_than_iWB_oWB_forces_output_iNC_oNC_or_stronger=  # (string, init-time) default = ''       : If not empty, then this enables a specific non-architectural behaviour
                                                      #                                        : on the comma-separated list of port indexes, or ranges.  For
                                                      #                                        : example:
                                                      #                                        : 
                                                      #                                        :   0, 10-20, 40
                                                      #                                        : 
                                                      #                                        : In the normal translation process, then the input attributes are
                                                      #                                        : usually replaced by the attributes from the page tables or
                                                      #                                        : SMMU_(S_)GBPA.
                                                      #                                        : 
                                                      #                                        : The behaviour is:
                                                      #                                        : 
                                                      #                                        :    if incoming attributes are iWB-oWB
                                                      #                                        :     use the architectural attributes
                                                      #                                        :    else
                                                      #                                        :     use the stronger of iNC-oNC-osh and the architectural attributes.
                                                      #                                        : 
                                                      #                                        : This is useful if the ports represent transactions from the PCIe
                                                      #                                        : subsystem and the PCIe devices output:
                                                      #                                        :   * iWB-oWB if not No_Snoop -> output is architectural attributes
                                                      #                                        :   * iNC-oNC-osh if No_Snoop -> output is iNC-oNC-osh or stronger
pci.pci_smmuv3.mmu.number_of_ports=1                  # (int   , init-time) default = '0x1'    : The number of port pairs that the SMMU has.
pci.pci_smmuv3.mmu.out_of_range_CMD_ATC_INV_Size=0    # (int   , init-time) default = '0x0'    : If CMD_ATC_INV.Size > 52 then the model is allowed to:-
                                                      #                                        :    0 -- raise CERROR_ILL
                                                      #                                        :    1 -- treat as NOP
                                                      #                                        : 
                                                      #                                        : The architecture also allows for an UNKNOWN invalidate size to be used
                                                      #                                        : as well but the model does not support this.
pci.pci_smmuv3.mmu.output_attribute_transform=ExtendedID[31:0]=DeviceID  # (string, init-time) default = 'ExtendedID[31:0]=DeviceID' : Transform downstream attributes of StreamID transactions.
                                                      #                                        : 
                                                      #                                        :   * ""/"none": no transform
                                                      #                                        :   * How to alter output attributes. Example:
                                                      #                                        : 
                                                      #                                        :       "ExtendedID[15:0]=DeviceID[15:0], UserFlags[31]=nSSV, UserFlags[19:0]=SubstreamID,
                                                      #                                        :        MasterID[10]=MasterID[11], MasterID[11]=MasterID[10]"
                                                      #                                        : 
                                                      #                                        : RHS/LHS Symbols:
                                                      #                                        :   * ExtendedID/MasterID/UserFlags: incoming/outgoing attributes.
                                                      #                                        : 
                                                      #                                        : RHS Symbols:
                                                      #                                        :   * DeviceID: StreamID + translated_device_id_base
                                                      #                                        :   * StreamID/SubstreamID/SSV/SEC_SID
                                                      #                                        :   * nSSV/nSEC_SID/: negative logic versions.
                                                      #                                        :   * St1PBHA/St2PBHA: Page Based Hardware Attributes from leaf descriptors (zero if not used).
                                                      #                                        :   * STE_IMPDEF1: STE[127:116]
                                                      #                                        :   * HWATTR_KIND_0: PBHA information
                                                      #                                        :   * numeric literals.
                                                      #                                        :   * SIDV = 1, nSIDV = 0 (fixed values to indicate StreamID)
                                                      #                                        : 
                                                      #                                        : Any bits with no transform are unchanged.
                                                      #                                        : 
                                                      #                                        : NOTE:
                                                      #                                        :   * 'mpam_attribute_transform' and 'mec_attribute_transform' are applied in order after this.
                                                      #                                        :   * see also 'output_attribute_transform_for_NoStreamID' for NoStreamID transactions.
pci.pci_smmuv3.mmu.output_attribute_transform_for_NoStreamID=ExtendedID[31:0]=0, ExtendedID[32]=1  # (string, init-time) default = 'ExtendedID[31:0]=0, ExtendedID[32]=1' : Transform downstream attributes of NoStreamID transactions.
                                                      #                                        : 
                                                      #                                        :   * ""/"none": no transform
                                                      #                                        :   * How to alter output attributes. Example:
                                                      #                                        : 
                                                      #                                        :   "ExtendedID[15:0]=0, UserFlags[31]=1, UserFlags[19:0]=0, MasterID[10]=MasterID[11],
                                                      #                                        :    MasterID[11]=MasterID[10]"
                                                      #                                        : 
                                                      #                                        : RHS/LHS Symbols:
                                                      #                                        :   * ExtendedID/MasterID/UserFlags: incoming/outgoing attributes.
                                                      #                                        : 
                                                      #                                        : RHS Symbols:
                                                      #                                        :   * SIDV = 0, nSIDV = 1 (fixed values to indicate NoStreamID)
                                                      #                                        :   * PAS
                                                      #                                        :   * numeric literals.
                                                      #                                        : 
                                                      #                                        : Any bits with no transform are unchanged.
                                                      #                                        : 
                                                      #                                        : NOTE:
                                                      #                                        :   * 'mpam_attribute_transform' and 'mec_attribute_transform' are applied in order after this.
                                                      #                                        :   * see also 'output_attribute_transform' for StreamID transactions.
pci.pci_smmuv3.mmu.output_id_routed_transform=Address[43:12]=StreamID, PAS=SSD  # (string, init-time) default = 'Address[43:12]=StreamID, PAS=SSD' : The SMMU generates the following ID-routed transaction on the
                                                      #                                        : pvbus_id_routed_m bus:
                                                      #                                        :     * ATC Invalidate
                                                      #                                        :     * PRI Response
                                                      #                                        : 
                                                      #                                        : This parameter expresses how the SMMU should express:
                                                      #                                        :     * the StreamID
                                                      #                                        :     * the Trusted (T) bit
                                                      #                                        : 
                                                      #                                        : The value is a comma-separated list of assignments:
                                                      #                                        : 
                                                      #                                        :      Address[27:12]=StreamID[15:0], ExtendedID[60]=T, ExtendedID[15:0]=StreamID[31:16]
                                                      #                                        : 
                                                      #                                        : Address bits[11:0] cannot be used.
                                                      #                                        : 
                                                      #                                        : The LHS can be one of:
                                                      #                                        :     * PAS
                                                      #                                        :     * MasterID/ExtendedID/UserFlags
                                                      #                                        :     * Address
                                                      #                                        : 
                                                      #                                        : The RHS can be one of:
                                                      #                                        :     * a numeric constant
                                                      #                                        :     * SSD
                                                      #                                        :     * T or negative version nT
                                                      #                                        :     * StreamID
                                                      #                                        : 
                                                      #                                        : For realm (or 'Trusted') transactions, then SSD=0b11, T=1, nT=0.
                                                      #                                        : For non-secure (or 'Non-Trusted') transactions, then SSD=0b01, T=0, nT=1
pci.pci_smmuv3.mmu.percent_commit=20                  # (int   , init-time) default = '0x14'   : Percentage of times that a read of a register with Update will commit the update.
                                                      #                                        : 0 means commit immediately.
pci.pci_smmuv3.mmu.percent_commit_Update_clear=20     # (int   , init-time) default = '0x14'   : Percentage of times that a read of a register with a pending Update clear will
                                                      #                                        : lower the Update flag.
pci.pci_smmuv3.mmu.pmu=                               # (string, init-time) default = ''       : What to instantiate as a PMU.
                                                      #                                        : 
                                                      #                                        : NOTE that all events and counters are intended for demonstration
                                                      #                                        : purposes only and should not be treated as in any way reflecting
                                                      #                                        : accurate values for a real implementation.  The model's internal
                                                      #                                        : representation of actions differ significantly from real hardware and
                                                      #                                        : the particular value obtained from the counters should not be used for
                                                      #                                        : benchmarking.
                                                      #                                        : 
                                                      #                                        : Values of this parameter are:
                                                      #                                        :   * "" -- no PMU
                                                      #                                        :   * "distributed-0"
                                                      #                                        :   * "distributed-1"
                                                      #                                        : 
                                                      #                                        : distributed-0:
                                                      #                                        :   * a PMCG per TBU (number_of_ports, up to 63 ports)
                                                      #                                        :   * a single PMCG for a TCU
                                                      #                                        :   * Connect a debugger to see the configuration.
                                                      #                                        : 
                                                      #                                        : distributed-1:
                                                      #                                        :   * same as distributed-0, except for supporting MSIs and MPAM
                                                      #                                        :     on the MSIs if MPAM is supported by rest of the SMMU.
pci.pci_smmuv3.mmu.ports_that_ignore_PnU_InD_on_transactions_with_no_SubstreamID=0-63  # (string, init-time) default = '0-63'   : Some bus systems (notably PCIe) do not support marking a transaction
                                                      #                                        : as Privileged/User or Instruction/Data unless the transaction has a
                                                      #                                        : SubstreamID.
                                                      #                                        : 
                                                      #                                        : This accepts a comma separated list of numbers and ranges, for example:
                                                      #                                        : 
                                                      #                                        :   0, 10-12, 15
                                                      #                                        : 
                                                      #                                        : If the number P is named in this list then the upstream pvbus_s[P]
                                                      #                                        : will have all transactions with no Substream considered to be User and
                                                      #                                        : Data.
pci.pci_smmuv3.mmu.prefetch_only_requests=0           # (int   , init-time) default = '0x0'    : The simulator supports 'prefetch-only' DMI requests, which can occur
                                                      #                                        : for anytime for any reason and are intended to be invisible to the end
                                                      #                                        : execution of the model and to the user.
                                                      #                                        : 
                                                      #                                        :   0 -- deny all prefetch-only requests
                                                      #                                        :   1 -- use debug requests for any page table walks
                                                      #                                        :     -- form and use debug TLB/cache entries
                                                      #                                        :     -- any faults will not record, but deny the prefetch request
                                                      #                                        :   2 -- treat prefetch-only requests like normal transactions
                                                      #                                        :     -- use normal page table walk transactions
                                                      #                                        :     -- use and form normal TLB/cache entries
                                                      #                                        :     -- faults will alter the programmer visible state of the SMMU
                                                      #                                        : 
                                                      #                                        : 0 is the safest.
                                                      #                                        : 
                                                      #                                        : 1 treats the access like a debug request and requires that debug page
                                                      #                                        : table walks are treated correctly downstream.  Any descriptors that
                                                      #                                        : need HTTU to allow the transaction to proceed will fail the request.
                                                      #                                        : 
                                                      #                                        : 2 is dangerous, it use real transactions and reports faults that are
                                                      #                                        : unphysical.  Real transactions can be wait()ed and this disobeys the
                                                      #                                        : SystemC spec for get_direct_mem_ptr().
pci.pci_smmuv3.mmu.ras=                               # (string, init-time) default = ''       : What to instantiate for RAS handling.
                                                      #                                        : 
                                                      #                                        : Values of this parameter are:
                                                      #                                        :   * "" -- no RAS records
                                                      #                                        :   * "mmu600"
                                                      #                                        :   * "mmu700"
                                                      #                                        : 
                                                      #                                        : mmu600:
                                                      #                                        :   * only a corrected errors reported.
                                                      #                                        : 
                                                      #                                        : See also imp_def_ras_allow_non_secure_accesses_if_supports_secure.
pci.pci_smmuv3.mmu.reset_value_of_SMMU_GBPA=0         # (int   , init-time) default = '0x0'    : Reset value of SMMU_GBPA
pci.pci_smmuv3.mmu.reset_value_of_SMMU_S_GBPA=0       # (int   , init-time) default = '0x0'    : Reset value of SMMU_S_GBPA
pci.pci_smmuv3.mmu.rme_ats_request_pa_strategy=0      # (int   , init-time) default = '0x0'    : When RME_IMPL == 0, the PA of an ATS Request's response is permitted
                                                      #                                        : but not required to undergo a GPT check:
                                                      #                                        : 
                                                      #                                        :   0 -- do not check the PA
                                                      #                                        :   1 -- do the check against the PA
                                                      #                                        :   2 -- check the PA 50% of the time
                                                      #                                        : 
                                                      #                                        : Translated transactions are required to always undergo a GPT check whatever
                                                      #                                        : happens.
                                                      #                                        : 
                                                      #                                        : This parameter is ignored if RME_IMPL==1 and the PA is required to be
                                                      #                                        : checked.
pci.pci_smmuv3.mmu.rme_l0gpt_entry_covers_log2size_in_bytes=30  # (int   , init-time) default = '0x1e'   : Each L0GPT entry covers:
                                                      #                                        :    2**rme_l0gpt_entry_covers_log2size_in_bytes
                                                      #                                        : bytes of address space.
                                                      #                                        : 
                                                      #                                        : The valid values for this parameter are:
                                                      #                                        :   * 30, 34, 36, 39
                                                      #                                        : 
                                                      #                                        : This parameter is reported in an encoded format as the read-only field:
                                                      #                                        :   SMMU_ROOT_GPT_BASE_CFG.L0GPTSZ
pci.pci_smmuv3.mmu.rme_speculation_control=           # (string, init-time) default = ''       : This is a comma-separated list of flags that control when and how the
                                                      #                                        : model will perform speculation for RME.
pci.pci_smmuv3.mmu.root_register_page_offset=0        # (int   , init-time) default = '0x0'    : This is the offset from SMMU_BASE of the Root register file page which
                                                      #                                        : is 64 KiB in size.  It must not overlap any other part of the register
                                                      #                                        : map.
pci.pci_smmuv3.mmu.seed=305419896                     # (int   , init-time) default = '0x12345678' : Used to seed the pseudo-random number generator that the SMMU model uses.
pci.pci_smmuv3.mmu.separate_tw_msi_qs_port=0          # (bool  , init-time) default = '0'      : True if there is a separate port which is used to walk configuration tables,
                                                      #                                        : translation tables, issue MSIs and access the queues.  If this is false then
                                                      #                                        : pvbus_m[0] will be used.
pci.pci_smmuv3.mmu.size_of_cd_cache=0                 # (int   , init-time) default = '0x0'    : The number of entries in the cache holding CD structures.
                                                      #                                        : If this is zero then it is treated as a large number ('infinite') but it is bounded
                                                      #                                        : so that the host memory usage of the cache is also bounded.
pci.pci_smmuv3.mmu.size_of_gpttlb=0                   # (int   , init-time) default = '0x0'    : The number of entries in the GPT TLB.
                                                      #                                        : If this is zero then it is treated as a large number ('infinite') but it is bounded
                                                      #                                        : so that the host memory usage of the cache is also bounded.
pci.pci_smmuv3.mmu.size_of_l1cd_cache=0               # (int   , init-time) default = '0x0'    : The number of entries in the cache holding L1CD descriptors.
                                                      #                                        : If this is zero then it is treated as a large number ('infinite') but it is bounded
                                                      #                                        : so that the host memory usage of the cache is also bounded.
pci.pci_smmuv3.mmu.size_of_l1ste_cache=0              # (int   , init-time) default = '0x0'    : The number of entries in the cache holding L1STE descriptors.
                                                      #                                        : If this is zero then it is treated as a large number ('infinite') but it is bounded
                                                      #                                        : so that the host memory usage of the cache is also bounded.
pci.pci_smmuv3.mmu.size_of_register_file=1048576      # (int   , init-time) default = '0x100000' : This is the power of two size that the register file occupies in the
                                                      #                                        : memory map.  It is used to generate a mask for the addresses received
                                                      #                                        : on pvbus_control_s to decode the desired register offset.
                                                      #                                        : 
                                                      #                                        : The default for this parameter is 1 MiB.
pci.pci_smmuv3.mmu.size_of_ste_cache=0                # (int   , init-time) default = '0x0'    : The number of entries in the cache holding STE structures.
                                                      #                                        : If this is zero then it is treated as a large number ('infinite') but it is bounded
                                                      #                                        : so that the host memory usage of the cache is also bounded.
pci.pci_smmuv3.mmu.size_of_tlb=0                      # (int   , init-time) default = '0x0'    : The number of entries in the TLB.
                                                      #                                        : If this is zero then it is treated as a large number ('infinite') but it is bounded
                                                      #                                        : so that the host memory usage of the cache is also bounded.
pci.pci_smmuv3.mmu.smmu_msi_device_id=65536           # (int   , init-time) default = '0x10000' : When appropriately enabled, assume that MSIs that are generated by the
                                                      #                                        : SMMU are presented to the GIC with this DeviceID.
                                                      #                                        : 
                                                      #                                        : See parameter msi_attribute_transform and enable_device_id_checks.
pci.pci_smmuv3.mmu.smmuv33_begin_offset_of_qcp0=0     # (int   , init-time) default = '0x0'    : This is the offset from SMMU_BASE of the first QCP page.  The
                                                      #                                        : architecture requires that if more than one world of QCPs are present
                                                      #                                        : then they are in the order non-secure and then secure QCPs and form
                                                      #                                        : one continuous address space in the register file.
pci.pci_smmuv3.mmu.support_for_httu_when_starts_disallowed=0  # (int   , init-time) default = '0x0'    : SMMU_IDR0.HTTU describes to the programmer whether the SMMU and system
                                                      #                                        : support HTTU.  Typically an SMMU that is capable of HTTU will have a
                                                      #                                        : configuration pin that says whether the system supports HTTU or not.
                                                      #                                        : 
                                                      #                                        : The SMMU model determines SMMU_IDR0.HTTU as follows:
                                                      #                                        :   * If the parameter SMMU_IDR0 indicates any kind of support for
                                                      #                                        :     HTTU, then the configuration pin turns support on and off between
                                                      #                                        :     that value and no support for HTTU.
                                                      #                                        :   * If the parameter SMMU_IDR0 indicates no HTTU support, allow the
                                                      #                                        :     pin to turn on support to that specified by this parameter.
                                                      #                                        : 
                                                      #                                        : Values for this parameter are the same as for the SMMU_IDR0.HTTU field:
                                                      #                                        :   * 0 -- no support for HTTU
                                                      #                                        :   * 1 -- AF flag only
                                                      #                                        :   * 2 -- AF flag and DBM update
pci.pci_smmuv3.mmu.tlb_when_do_f_tlb_conflict_on_overlap=0  # (int   , init-time) default = '0x0'    : If a TLB entry is created by a walk and it overlaps an existing entry.
                                                      #                                        : Then there are some architectural situations where the result is
                                                      #                                        : known.  For all others, then an implementation is allowed to use an
                                                      #                                        : UNPREDICTABLE combination of the two entries, or it can generate
                                                      #                                        : F_TLB_CONFLICT:
                                                      #                                        : 
                                                      #                                        :     0 -- never generate
                                                      #                                        :     1 -- sometimes generate
                                                      #                                        :     2 -- always generate
                                                      #                                        : 
                                                      #                                        : Conflicts between global and non-global entries are not detected by
                                                      #                                        : the model.
pci.pci_smmuv3.mmu.translated_device_id_base=0        # (int   , init-time) default = '0x0'    : When appropriately enabled, assume that client device accesses are
                                                      #                                        : translated to a DeviceID as seen by the GIC of:
                                                      #                                        :      StreamID + translated_device_id_base
                                                      #                                        : 
                                                      #                                        : See parameter output_attribute_transform and enable_device_id_checks.
pci.pci_smmuv3.mmu.treat_debug_read_accesses_as_speculative_accesses=0  # (bool  , init-time) default = '0'      : The SMMU architecture has the concept of speculative accesses.  If you
                                                      #                                        : set this flag to true, then debug read accesses flowing from the
                                                      #                                        : upstream system through the SMMU will be interpreted as speculative.
                                                      #                                        : 
                                                      #                                        : The difference is that a speculative read will:
                                                      #                                        :   * participate in HTTU
                                                      #                                        :   * if it encounters a (non-HTTU) fault will always return abort
                                                      #                                        : 
                                                      #                                        : Debug writes are still considered as debug accesses.  All speculative
                                                      #                                        : writes would be aborted and this is not a useful behaviour for the
                                                      #                                        : SMMU to emulate.
pci.pci_smmuv3.mmu.tw_qs_attribute_transform=         # (string, init-time) default = ''       : Transform downstream attributes of table walk and queue transactions.
                                                      #                                        : 
                                                      #                                        :     * ""/"none" -- no transform
                                                      #                                        :     * How to alter the output attributes. Example:
                                                      #                                        : 
                                                      #                                        :         "ExtendedID[35:32]=HWATTR_KIND_0"
                                                      #                                        : 
                                                      #                                        : RHS/LHS Symbols:
                                                      #                                        :   * ExtendedID/MasterID/UserFlags
                                                      #                                        : 
                                                      #                                        : RHS Symbols:
                                                      #                                        :   * HWATTR_KIND_0: PBHA information
                                                      #                                        :   * numeric literals.
                                                      #                                        : 
                                                      #                                        : ExtendedID/MasterID/UserFlags start with values {0, 0xFFFFffff, 0} respectively.
                                                      #                                        : 
                                                      #                                        : Any bits with no transform are unchanged.
                                                      #                                        : 
                                                      #                                        : NOTE:
                                                      #                                        :   * see also 'output_attribute_transform' and 'msi_attribute_transform'.
pci.pci_smmuv3.mmu.unpred_httu_percent_do_discretionary_AF=50  # (int   , init-time) default = '0x32'   : If a descriptor could have a discretionary update of the AF flag on
                                                      #                                        : then what is the percentage of the time that the AF update should occur.
pci.pci_smmuv3.mmu.unpred_httu_percent_do_discretionary_DBM=50  # (int   , init-time) default = '0x32'   : If a descriptor could have a discretionary DBM update to make the
                                                      #                                        : descriptor WriteableDirty then what is the percent of the time
                                                      #                                        : time that the DBM update should occur.
pci.pci_smmuv3.mmu.unpred_translated_access_out_of_range_of_oas=1  # (int   , init-time) default = '0x1'    : If a Translated Access is presented to the SMMU that is > OAS then it
                                                      #                                        : is CONSTRAINED UNPRED as to whether the transaction will either:
                                                      #                                        :    0 -- be truncated to OAS and go downstream
                                                      #                                        :    1 -- be aborted, no event written
pci.pci_smmuv3.mmu.wait_atos_ticks=0                  # (int   , init-time) default = '0x0'    : This is the time to wait before doing an ATOS operation.
                                                      #                                        : If bit 32 is set (0x1_0000_0000) then the time waited for is
                                                      #                                        : a uniform randomly distributed time [0,max(2,(t & 0xFFFFffff))).
pci.pci_smmuv3.mmu.wait_cmdq_ticks=0                  # (int   , init-time) default = '0x0'    : This is the time to wait before doing something on the command queue.
                                                      #                                        : If bit 32 is set (0x1_0000_0000) then the time waited for is
                                                      #                                        : a uniform randomly distributed time [0,max(2,(t & 0xFFFFffff))).
pci.pci_smmuv3.mmu.wait_eventq_ticks=0                # (int   , init-time) default = '0x0'    : This is the time to wait before doing something on the event queue.
                                                      #                                        : If bit 32 is set (0x1_0000_0000) then the time waited for is
                                                      #                                        : a uniform randomly distributed time [0,max(2,(t & 0xFFFFffff))).
pci.pci_smmuv3.mmu.wait_misc_async_actions_ticks=0    # (int   , init-time) default = '0x0'    : This is the time to wait before doing an async action that could
                                                      #                                        : be delayed is performed.
                                                      #                                        : If bit 32 is set (0x1_0000_0000) then the time waited for is
                                                      #                                        : a uniform randomly distributed time [0,max(2,(t & 0xFFFFffff))).
pci.pci_smmuv3.mmu.wait_msi_ticks=0                   # (int   , init-time) default = '0x0'    : This is the time to wait before sending an MSI.
                                                      #                                        : If bit 32 is set (0x1_0000_0000) then the time waited for is
                                                      #                                        : a uniform randomly distributed time [0,max(2,(t & 0xFFFFffff))).
pci.pci_smmuv3.mmu.wait_pri_req_ticks=0               # (int   , init-time) default = '0x0'    : This is the time to wait before processing a PRI Request.
                                                      #                                        : If bit 32 is set (0x1_0000_0000) then the time waited for is
                                                      #                                        : a uniform randomly distributed time [0,max(2,(t & 0xFFFFffff))).
pci.pci_smmuv3.mmu.wait_pri_resp_ticks=1              # (int   , init-time) default = '0x1'    : This is the time to wait before sending a PRI Response back to the
                                                      #                                        : PCIe subsystem.
                                                      #                                        : When a PRI Response is an auto-response then the ATC might immediately
                                                      #                                        : make a new ATS request, that immediately fails, that immediately makes
                                                      #                                        : a PRI Request, that auto-responds, etc.  To break this loop, then we
                                                      #                                        : introduce a minimum time on all PRI Responses to give other components
                                                      #                                        : in the system a chance to run.
                                                      #                                        : If bit 32 is set (0x1_0000_0000) then the time waited for is
                                                      #                                        : a uniform randomly distributed time [0,max(2,(t & 0xFFFFffff))).
pci.pci_smmuv3.mmu.when_fetch_vms=0                   # (int   , init-time) default = '0x0'    : Architecturally, there is flexibility in how a VMS is cached and thus:
                                                      #                                        :   * when it will be fetched
                                                      #                                        :   * the prioritization of F_VMS_FETCH.
                                                      #                                        : 
                                                      #                                        : Of the many architecturally-allowed options, the model offers two:
                                                      #                                        : 
                                                      #                                        :   0 -- fetched and cached immediately after the STE is fetched
                                                      #                                        :   1 -- fetched and cached immediately after the CD is fetched
                                                      #                                        : 
                                                      #                                        : In both cases, then the VMS is cached in the STE and CMD_CFGI_VMS_PIDM
                                                      #                                        : is a NOP.
pci.pci_smmuv3.mmu.width_of_agbpa_impdef=16           # (int   , init-time) default = '0x10'   : Width of the SMMU_s_AGBPA.IMPDEF field.
pci.pci_smmuv3_msirewriter.GITS_TRANSLATE64R_OFFSET=65608  # (int   , init-time) default = '0x10048' : It is an offset from ITS0-Base.
pci.pci_smmuv3_msirewriter.enable_rewriting=1         # (bool  , init-time) default = '1'      : Enable rewriting.
pci.pci_smmuv3_msirewriter.log=0                      # (int   , init-time) default = '0x0'    : Log level, 0 is off.
pci.pcidevice0.aer_supported=0                        # (bool  , init-time) default = '0'      : Advanced Error Reporting supported
pci.pcidevice0.aspm_optionality_compliant=1           # (bool  , init-time) default = '1'      : Enable ASPM optionality compliance
pci.pcidevice0.atc_size=0                             # (int   , init-time) default = '0x0'    : The maximum number of ATC entries. 0 is effectively a large number
pci.pcidevice0.ats_supported=1                        # (bool  , init-time) default = '1'      : If set then the PCIe function supports Address Translation Services(ATS)
pci.pcidevice0.bar0_64bit=0                           # (bool  , init-time) default = '0'      : If BAR 0 is 64 bits wide, if region size is non zero
pci.pcidevice0.bar0_log2_size=12                      # (int   , init-time) default = '0xc'    : Log2 of the size the region pointed to by BAR 0, zero is reserved means bar is not used
pci.pcidevice0.bar0_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 0 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice0.bar1_log2_size=0                       # (int   , init-time) default = '0x0'    : Log2 of the size the region pointed to by BAR 1, zero is reserved means bar is not used
pci.pcidevice0.bar1_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 1 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice0.bar2_64bit=0                           # (bool  , init-time) default = '0'      : If BAR 2 is 64 bits wide, if region size is non zero
pci.pcidevice0.bar2_log2_size=12                      # (int   , init-time) default = '0xc'    : Log2 of the size the region pointed to by BAR 2, zero is reserved means bar is not used
pci.pcidevice0.bar2_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 2 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice0.bar3_log2_size=0                       # (int   , init-time) default = '0x0'    : Log2 of the size the region pointed to by BAR 3, zero is reserved means bar is not used
pci.pcidevice0.bar3_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 3 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice0.bar4_64bit=0                           # (bool  , init-time) default = '0'      : If BAR 4 is 64 bits wide, if region size is non zero
pci.pcidevice0.bar4_log2_size=12                      # (int   , init-time) default = '0xc'    : Log2 of the size the region pointed to by BAR 4, zero is reserved means bar is not used
pci.pcidevice0.bar4_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 4 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice0.bar5_log2_size=0                       # (int   , init-time) default = '0x0'    : Log2 of the size the region pointed to by BAR 5, zero is reserved means bar is not used
pci.pcidevice0.bar5_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 5 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice0.certificate_filename=                  # (string, init-time) default = ''       : Filename containing a                     X-509 Certificate issued for this DOE device in DER format
pci.pcidevice0.device=0                               # (int   , init-time) default = '0x0'    : Device number on this bus
pci.pcidevice0.device_signature_filename=             # (string, init-time) default = ''       : Filename contianing                     a unique signature for this DOE device
pci.pcidevice0.diagnostics=0                          # (int   , init-time) default = '0x0'    : Diagnostics level
pci.pcidevice0.digest_filename=                       # (string, init-time) default = ''       : Filename containing a                     SHA-256 DIGEST of the device-certificate issued for this DOE device
pci.pcidevice0.doe_supported=0                        # (bool  , init-time) default = '0'      : The device supports Data Object Exchange extended capability.
pci.pcidevice0.enable_pcie_cxl_dvsec=0                # (bool  , init-time) default = '0'      : PCIE CXL DVSEC capability enabled
pci.pcidevice0.error_injection_supported=0            # (bool  , init-time) default = '0'      : Error injection capability supported
pci.pcidevice0.express_capability_device_type=0       # (int   , init-time) default = '0x0'    : PCI Express Capabilities Device Type, bits 4:7 in capabilites register.  0 is PCIe EndPoint, 9 is RCiEP.
pci.pcidevice0.ext_fmt_field_supported=1              # (bool  , init-time) default = '1'      : Enable extended format field support
pci.pcidevice0.extended_tag_supported=1               # (bool  , init-time) default = '1'      : Enable Extended Tag field support
pci.pcidevice0.function=0                             # (int   , init-time) default = '0x0'    : Function number
pci.pcidevice0.ide_supported=0                        # (bool  , init-time) default = '0'      : The device supports Integrity and Data Encryption extended capability.
pci.pcidevice0.interrupt_pin_index=1                  # (int   , init-time) default = '0x1'    : Interrupt pin used by this function 1:INTA, 2:INTB, 3:INTC, 4:INTD
pci.pcidevice0.is_hidden=0                            # (bool  , init-time) default = '0'      : Hide this endpoint and prevent it from being discovered
pci.pcidevice0.link_port_number=0                     # (int   , init-time) default = '0x0'    : Port number for PCIe link
pci.pcidevice0.msix_support=1                         # (bool  , init-time) default = '1'      : Enable device support for MSI-X
pci.pcidevice0.msix_upsize=0                          # (bool  , init-time) default = '0'      : Upsize the MSI-X transaction to 64 bit and place the BDF bits [47:32]
pci.pcidevice0.multi_function=0                       # (bool  , init-time) default = '0'      : Is this endpoint part of a multi function device
pci.pcidevice0.pasid_execution_permission_supported=1  # (bool  , init-time) default = '1'      : The device can emit PASIDs with the Execute bit set
pci.pcidevice0.pasid_global_invalidate_supported=1    # (bool  , init-time) default = '1'      : The device can receive ATC Invalidates with the global invalidate flag set
pci.pcidevice0.pasid_max_width=20                     # (int   , init-time) default = '0x14'   : The maximum PASID width the device can emit
pci.pcidevice0.pasid_privileged_mode_supported=1      # (bool  , init-time) default = '1'      : The device can emit PASIDs with the Privileged Mode bit set
pci.pcidevice0.pasid_supported=0                      # (bool  , init-time) default = '0'      : If set then the PCIe device can emit PASID (SubstreamIDs)
pci.pcidevice0.pcie_version=2                         # (int   , init-time) default = '0x2'    : PCIe version , bits 0:3 in capabilites register.  1 is PCIe3.0.  2 is PCIe4.0.
pci.pcidevice0.power_mgmt_capability=1                # (bool  , init-time) default = '1'      : Device supports Power-Management capabilities
pci.pcidevice0.pri_capacity=255                       # (int   , init-time) default = '0xff'   : The maximum number of PRI credits that this device will advertise in its PRI Extended Capability Header
pci.pcidevice0.pri_prg_response_pasid_required=1      # (bool  , init-time) default = '1'      : The PRG responses from the SMMU requires a PASID attached
pci.pcidevice0.pri_supported=1                        # (bool  , init-time) default = '1'      : If set then the PCIe function supports Page Request Interface(requires ATS)
pci.pcidevice0.rber_supported=1                       # (bool  , init-time) default = '1'      : Enable role-based error reporting 
pci.pcidevice0.seed=305419896                         # (int   , init-time) default = '0x12345678' : The random number generator seed for the ATC
pci.pcidevice0.slot_and_root_status_msi_idx=0         # (int   , init-time) default = '0x0'    : MSI index for slot and root status changes
pci.pcidevice0.tag_10bit_completer_supported=1        # (bool  , init-time) default = '1'      : Enable 10 bit tag completer support
pci.pcidevice0.tag_10bit_requester_supported=1        # (bool  , init-time) default = '1'      : Enable 10 bit tag requester support
pci.pcidevice0.uses_client_based_atc=0                # (bool  , init-time) default = '0'      : ATC in this endpoint is controlled by client device
pci.pcidevice1.aer_supported=0                        # (bool  , init-time) default = '0'      : Advanced Error Reporting supported
pci.pcidevice1.aspm_optionality_compliant=1           # (bool  , init-time) default = '1'      : Enable ASPM optionality compliance
pci.pcidevice1.atc_size=0                             # (int   , init-time) default = '0x0'    : The maximum number of ATC entries. 0 is effectively a large number
pci.pcidevice1.ats_supported=1                        # (bool  , init-time) default = '1'      : If set then the PCIe function supports Address Translation Services(ATS)
pci.pcidevice1.bar0_64bit=0                           # (bool  , init-time) default = '0'      : If BAR 0 is 64 bits wide, if region size is non zero
pci.pcidevice1.bar0_log2_size=12                      # (int   , init-time) default = '0xc'    : Log2 of the size the region pointed to by BAR 0, zero is reserved means bar is not used
pci.pcidevice1.bar0_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 0 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice1.bar1_log2_size=0                       # (int   , init-time) default = '0x0'    : Log2 of the size the region pointed to by BAR 1, zero is reserved means bar is not used
pci.pcidevice1.bar1_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 1 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice1.bar2_64bit=0                           # (bool  , init-time) default = '0'      : If BAR 2 is 64 bits wide, if region size is non zero
pci.pcidevice1.bar2_log2_size=12                      # (int   , init-time) default = '0xc'    : Log2 of the size the region pointed to by BAR 2, zero is reserved means bar is not used
pci.pcidevice1.bar2_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 2 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice1.bar3_log2_size=0                       # (int   , init-time) default = '0x0'    : Log2 of the size the region pointed to by BAR 3, zero is reserved means bar is not used
pci.pcidevice1.bar3_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 3 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice1.bar4_64bit=0                           # (bool  , init-time) default = '0'      : If BAR 4 is 64 bits wide, if region size is non zero
pci.pcidevice1.bar4_log2_size=12                      # (int   , init-time) default = '0xc'    : Log2 of the size the region pointed to by BAR 4, zero is reserved means bar is not used
pci.pcidevice1.bar4_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 4 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice1.bar5_log2_size=0                       # (int   , init-time) default = '0x0'    : Log2 of the size the region pointed to by BAR 5, zero is reserved means bar is not used
pci.pcidevice1.bar5_prefetchable=0                    # (bool  , init-time) default = '0'      : If BAR 5 is prefetchable(true), or non-prefetchable(false)
pci.pcidevice1.certificate_filename=                  # (string, init-time) default = ''       : Filename containing a                     X-509 Certificate issued for this DOE device in DER format
pci.pcidevice1.device=2                               # (int   , init-time) default = '0x2'    : Device number on this bus
pci.pcidevice1.device_signature_filename=             # (string, init-time) default = ''       : Filename contianing                     a unique signature for this DOE device
pci.pcidevice1.diagnostics=0                          # (int   , init-time) default = '0x0'    : Diagnostics level
pci.pcidevice1.digest_filename=                       # (string, init-time) default = ''       : Filename containing a                     SHA-256 DIGEST of the device-certificate issued for this DOE device
pci.pcidevice1.doe_supported=0                        # (bool  , init-time) default = '0'      : The device supports Data Object Exchange extended capability.
pci.pcidevice1.enable_pcie_cxl_dvsec=0                # (bool  , init-time) default = '0'      : PCIE CXL DVSEC capability enabled
pci.pcidevice1.error_injection_supported=0            # (bool  , init-time) default = '0'      : Error injection capability supported
pci.pcidevice1.express_capability_device_type=0       # (int   , init-time) default = '0x0'    : PCI Express Capabilities Device Type, bits 4:7 in capabilites register.  0 is PCIe EndPoint, 9 is RCiEP.
pci.pcidevice1.ext_fmt_field_supported=1              # (bool  , init-time) default = '1'      : Enable extended format field support
pci.pcidevice1.extended_tag_supported=1               # (bool  , init-time) default = '1'      : Enable Extended Tag field support
pci.pcidevice1.function=0                             # (int   , init-time) default = '0x0'    : Function number
pci.pcidevice1.ide_supported=0                        # (bool  , init-time) default = '0'      : The device supports Integrity and Data Encryption extended capability.
pci.pcidevice1.interrupt_pin_index=1                  # (int   , init-time) default = '0x1'    : Interrupt pin used by this function 1:INTA, 2:INTB, 3:INTC, 4:INTD
pci.pcidevice1.is_hidden=0                            # (bool  , init-time) default = '0'      : Hide this endpoint and prevent it from being discovered
pci.pcidevice1.link_port_number=0                     # (int   , init-time) default = '0x0'    : Port number for PCIe link
pci.pcidevice1.msix_support=1                         # (bool  , init-time) default = '1'      : Enable device support for MSI-X
pci.pcidevice1.msix_upsize=0                          # (bool  , init-time) default = '0'      : Upsize the MSI-X transaction to 64 bit and place the BDF bits [47:32]
pci.pcidevice1.multi_function=0                       # (bool  , init-time) default = '0'      : Is this endpoint part of a multi function device
pci.pcidevice1.pasid_execution_permission_supported=1  # (bool  , init-time) default = '1'      : The device can emit PASIDs with the Execute bit set
pci.pcidevice1.pasid_global_invalidate_supported=1    # (bool  , init-time) default = '1'      : The device can receive ATC Invalidates with the global invalidate flag set
pci.pcidevice1.pasid_max_width=20                     # (int   , init-time) default = '0x14'   : The maximum PASID width the device can emit
pci.pcidevice1.pasid_privileged_mode_supported=1      # (bool  , init-time) default = '1'      : The device can emit PASIDs with the Privileged Mode bit set
pci.pcidevice1.pasid_supported=0                      # (bool  , init-time) default = '0'      : If set then the PCIe device can emit PASID (SubstreamIDs)
pci.pcidevice1.pcie_version=2                         # (int   , init-time) default = '0x2'    : PCIe version , bits 0:3 in capabilites register.  1 is PCIe3.0.  2 is PCIe4.0.
pci.pcidevice1.power_mgmt_capability=1                # (bool  , init-time) default = '1'      : Device supports Power-Management capabilities
pci.pcidevice1.pri_capacity=255                       # (int   , init-time) default = '0xff'   : The maximum number of PRI credits that this device will advertise in its PRI Extended Capability Header
pci.pcidevice1.pri_prg_response_pasid_required=1      # (bool  , init-time) default = '1'      : The PRG responses from the SMMU requires a PASID attached
pci.pcidevice1.pri_supported=1                        # (bool  , init-time) default = '1'      : If set then the PCIe function supports Page Request Interface(requires ATS)
pci.pcidevice1.rber_supported=1                       # (bool  , init-time) default = '1'      : Enable role-based error reporting 
pci.pcidevice1.seed=305419896                         # (int   , init-time) default = '0x12345678' : The random number generator seed for the ATC
pci.pcidevice1.slot_and_root_status_msi_idx=0         # (int   , init-time) default = '0x0'    : MSI index for slot and root status changes
pci.pcidevice1.tag_10bit_completer_supported=1        # (bool  , init-time) default = '1'      : Enable 10 bit tag completer support
pci.pcidevice1.tag_10bit_requester_supported=1        # (bool  , init-time) default = '1'      : Enable 10 bit tag requester support
pci.pcidevice1.uses_client_based_atc=0                # (bool  , init-time) default = '0'      : ATC in this endpoint is controlled by client device
pci.pcivirtioblockdevice0.image_path=                 # (string, init-time) default = ''       : image file path
pci.pcivirtioblockdevice0.quiet=0                     # (bool  , init-time) default = '0'      : Don't print warnings on malformed commands/descriptors
pci.pcivirtioblockdevice0.read_only=0                 # (bool  , init-time) default = '0'      : Only allow device to be read
pci.pcivirtioblockdevice0.secure_accesses=0           # (bool  , init-time) default = '0'      : Make device generate transactions with NS=0
pci.pcivirtioblockdevice0.transaction_attributes=0    # (int   , init-time) default = '0x0'    : Transaction attributes used by device.
                                                      #                                        : 	0x0 - inner-shared real access.
                                                      #                                        : 	0x1 - outer-shared real access.
                                                      #                                        : 	0x2 - outer-shared debug access.
pci.pcivirtioblockdevice1.image_path=                 # (string, init-time) default = ''       : image file path
pci.pcivirtioblockdevice1.quiet=0                     # (bool  , init-time) default = '0'      : Don't print warnings on malformed commands/descriptors
pci.pcivirtioblockdevice1.read_only=0                 # (bool  , init-time) default = '0'      : Only allow device to be read
pci.pcivirtioblockdevice1.secure_accesses=0           # (bool  , init-time) default = '0'      : Make device generate transactions with NS=0
pci.pcivirtioblockdevice1.transaction_attributes=0    # (int   , init-time) default = '0x0'    : Transaction attributes used by device.
                                                      #                                        : 	0x0 - inner-shared real access.
                                                      #                                        : 	0x1 - outer-shared real access.
                                                      #                                        : 	0x2 - outer-shared debug access.
pci.pvbus2pci.diagnostics_level=0                     # (int   , init-time) default = '0x0'    : Diagnostics level
pci.pvbus2pci.start_bus_number=0                      # (int   , init-time) default = '0x0'    : Start bus number
pci.smmulogger.trace_debug=0                          # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.smmulogger.trace_snoops=0                         # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pci.tbu0_pre_smmu_logger.trace_debug=0                # (bool  , init-time) default = '0'      : Enable tracing of debug transactions
pci.tbu0_pre_smmu_logger.trace_snoops=0               # (bool  , init-time) default = '0'      : Enable tracing of ACE snoop requests
pctl.Affinity-shifted=1                               # (bool  , init-time) default = '1'      : Whether core number is reflected in Affinity1 instead of Affinity0
pctl.CPU-affinities=0.0.0.0, 0.0.1.0, 0.0.2.0, 0.0.3.0, 0.1.0.0, 0.1.1.0, 0.1.2.0, 0.1.3.0  # (string, init-time) default = '0.0.0.0, 0.0.1.0, 0.0.2.0, 0.0.3.0, 0.1.0.0, 0.1.1.0, 0.1.2.0, 0.1.3.0' : Definition of which cores are attached to the control pins, as a comma separated list of affinity dotted quads
pctl.enable_lock_step=0                               # (bool  , init-time) default = '0'      : If lock step is enabled, the number of available cores get reduced to half
pctl.startup=0.0.0.*                                  # (string, init-time) default = '0.0.0.*' : Comma-separated list of cores (wildcards allowed) to be powered up at startup or system reset
pctl.use_in_cluster_ppu=0                             # (bool  , init-time) default = '0'      : Set this to true if base power controller is connected to V9 core where in-cluster PPU is used, false, otherwise.
pctl.use_pchannel_for_threads=0                       # (bool  , init-time) default = '0'      : Set this to true if the pchannel is connected to cpus with thread support.
rlpiden=1                                             # (bool  , init-time) default = '1'      : Debug authentication signal rlpiden
rtpiden=1                                             # (bool  , init-time) default = '1'      : Debug authentication signal rtpiden
semihosting-enable=1                                  # (bool  , init-time) default = '1'      : Enable semihosting for all cores
spiden=1                                              # (bool  , init-time) default = '1'      : Debug authentication signal spiden
spniden=1                                             # (bool  , init-time) default = '1'      : Debug authentication signal spniden
test_engine.device0.bandwidth_per_transaction_in_bytes_per_tick=100  # (int   , init-time) default = '0x64'   : The bandwidth of the device for each in-flight transaction, in bytes/tick of clk_in.  This is only a rough guess.  If you are uninterested in trying to run cores and the engine simultaneously then set this to a large number.
test_engine.device0.max_number_of_inflight_transactions=10  # (int   , init-time) default = '0xa'    : The maximum number of in-flight transactions allowed.
test_engine.device0.seed=305419896                    # (int   , init-time) default = '0x12345678' : The seed to use for initialising the random number generators.
v8ect.has_CTIAUTHSTATUS=1                             # (bool  , init-time) default = '1'      : Has the optional CTIAUTHSTATUS register
v8ect.has_CTIDEVID_INOUT=1                            # (bool  , init-time) default = '1'      : Has the option of input gate in cross trigger matrix
v8ect.number-of-channels=4                            # (int   , init-time) default = '0x4'    : Number of channels in cross trigger matrix
#------------------------------------------------------------------------------
